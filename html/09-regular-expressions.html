<HTML>
<head>
<TITLE>SYMBOLIC PROCESSING IN PASCAL - Chapter 9</TITLE>
</head>

<body>

<H1>Regular expressions</H1>
<P>
This chapter gives a brief introduction to formal language theory,
up to the definition of regular expressions.
Then the technique introduced in the previous chapter
is used to construct a program which reads
regular expressions and then writes the strings in the language
defined by the expression.
<H2>Some formal language theory</H2>
<P>
In the same way as (unordered) sets are treated in set theory,
(ordered) sequences or strings are treated formally
in what is known as formal language theory.
This section only gives a very simple introduction
which is just adequate for describing what the program
in the next section does.
<H3>Strings and operations on strings</H3>
<P>
<P>
In the following, let A be any finite set of elements.
The set A may be the set of coins in my pocket,
or the set of days of the week,
or the set <CODE>{</CODE>John, 42, London<CODE>}</CODE>,
consisting of the person John,
the number 42 and the city London,
or the set of English words,
or the set of ASCII characters.
In formal language theory the set A is often called the <EM>alphabet</EM>.
We now define <EM>strings</EM> over an alphabet
(sometimes called <EM>words</EM> over an alphabet):
a string S over an alphabet A is a sequence of elements of A.
For example,
the sequence <CODE><</CODE>42, London, 42, 42<CODE>></CODE> is a string over the third set
just mentioned.
The following is a string over the set of vowels:
<CODE><e, i, i, e, u></CODE>.
If the alphabet consists of just letters,
we allow the alternative notation <CODE>"eiieu"</CODE>.
It is convenient to allow the empty string  <CODE>""</CODE>.
This may be formalised by the following recursive definition:
<XMP>
1) The null string "" is a string over any alphabet A.
2) IF x is an element of the alphabet A,
        and S is a string over the alphabet A
   THEN the string consisting of x followed by the elements of S
        is a string over the alphabet A.
</XMP>
An important binary operation on strings is <EM>concatenation</EM>;
We use the underscore <CODE>"_"</CODE> as the explicit infix
symbol for concatenation.
Just as the sum of 2 and 3, written 2 + 3, is 5,
so the concatenation of <CODE>"abc"</CODE> and <CODE>"de"</CODE>,
written <CODE>"abc"_"de"</CODE>,
is <CODE>"abcde"</CODE>.
Concatenation is associative --- hence no brackets are needed
for multiple concatenations, and the null string is the left
and right identity.
Every string has a non-negative length,
the null string has length 0,
and the concatenation of two strings has a length
which is the sum of the lengths of the two strings concatenated.
The n-fold concatenation of a string with itself is called its
n-th <EM>power</EM>.
For example, the 3-rd power of <CODE>"abc"</CODE>,
written: <CODE>"abc"</CODE>^3 ,
is <CODE>"abcabcabc"</CODE>.
The length of the n-th power of a string is
the n-th product of the length of the string.
Clearly, the n-th power of the null string <CODE>""</CODE> is just <CODE>""</CODE>,
the 1-st power of any string is itself,
and by definition the 0-th power of any string is <CODE>""</CODE>.
Another view which is sometimes useful is that a string over alphabet A
is a function from an initial segment of the natural numbers into A;
this view makes indexing primary ---
for example, using <CODE>[</CODE> and <CODE>]</CODE>
containing a numeric expression as the index,
<CODE>"abcd"[2]</CODE> = <CODE>"b"</CODE>.
<H3>Languages and operations on languages</H3>
<P>
A <EM>language</EM> over an alphabet A is defined to be a set
of strings over A.
For example,
the finite set <CODE>{"ae", "eea", "i"}</CODE> is a finite language
over the set of vowels,
the infinite set <CODE>{"0", "1", "10", "11", "100", "101", "110", "111", ...}</CODE>
is the infinite language of binary numerals for natural numbers
over the alphabet of binary digits,
and the infinite set
<CODE>{"", "a", "aa", "aaa", "aaaa", ...}</CODE>
is the infinite language of all strings over the alphabet <CODE>{a}</CODE>.
<P>
Since languages are sets, the usual set theoretic operations apply;
they are:
the binary operations of intersection, union, difference and symmetric
difference,
and a binary operation of complementation with respect to all strings
over a given alphabet.
Only union will be important in what follows;
in the literature it is often called <EM>alternation</EM>,
written as an infix operator <CODE>'|'</CODE>,
so <CODE>L | M</CODE> is the union or alternation of the two languages <CODE>L</CODE> and <CODE>M</CODE>.
<P>
Another important operation on languages arises not because
languages are sets but because they are composed of strings,
and strings can be concatenated.
If <CODE>S</CODE> and <CODE>T</CODE> are two strings, then their unit sets are the
languages <CODE>{S}</CODE> and <CODE>{T}</CODE>,
their concatenation is <CODE>S _ T</CODE>,
and the unit set of their concatenation is <CODE>{S _ T}</CODE>,
which we now also write as <CODE>{S}_{T}</CODE>,
as the <EM>concatenation</EM> of two <EM>languages</EM>.
More generally,
if <CODE>L</CODE> and <CODE>M</CODE> are two languages,
then their concatenation <CODE>L _ M</CODE> is defined to be
the language consisting of strings concatenated from two parts,
the first from <CODE>L</CODE> and the second from <CODE>M</CODE>.
The unit language <CODE>{""}</CODE>,
whose only element is the null string,
is the left and right identity
of concatenation of languages.
We shall write <CODE>0</CODE> for <CODE>{""}</CODE>,
and it is important to distinguish it from the empty language,
the null set <CODE>{}</CODE>, which is the left and right identity of alternation.
<P>
The n-fold concatenation of a language
<CODE>L</CODE> with itself is its n-th <EM>power</EM>,
written <CODE>L</CODE>^n ,
and note that the 1-st power, <CODE>L</CODE>^1 , is just <CODE>L</CODE>,
and by definition the 0-th power of L, <CODE>L</CODE>^0 , is just 0,
the language <CODE>{""}</CODE>.
The union of all powers,
<CODE>L</CODE>^0  <CODE>|</CODE> <CODE>L</CODE>^1  <CODE>|</CODE>
<CODE>L</CODE>^2  <CODE>|</CODE> <CODE>L</CODE>^3  <CODE>| ...</CODE>,
The union of all positive powers,
<CODE>L</CODE>^1  <CODE>|</CODE> <CODE>L</CODE>^2  <CODE>|</CODE> <CODE>L</CODE>^3  <CODE>| ...</CODE>,
is written <CODE>L+</CODE> and called the positive closure of <CODE>L</CODE>.
The union of the first two powers,
<CODE>L</CODE>^0  <CODE>|</CODE> <CODE>L</CODE>^1 ,
is written <CODE>L?</CODE>, and might be called the optional closure of <CODE>L</CODE> ---
it is just <CODE>L</CODE> with the null string added if it was not there already.
<H3>Regular expressions and regular languages</H3>
<P>
Regular expressions are language denoting expressions built
by means of the language theoretic binary operations
of alternation (=union)
and concatenation and the unary operation of Kleene closure
from unit languages.
The following is an informal definition of the abstract
syntax, it is not a definition of the concrete syntax
since it says nothing about parenthesising larger expressions
or about the relative precedence of the two binary operators.
<XMP>
A regular expression over an alphabet A is either
  the expression 0,
    and it denotes the unit language whose only element is "", or
  the expression 'a' for some element a of A,
    and it denotes the unit language whose only element is "a", or
  the expression L | M,
      where L and M are regular expressions over A,
    and it denotes the alternation of
      the languages denoted by L and M, or
  the expression L _ M,
      where L and M are regular expressions over A,
    and it denotes the concatenation of
      the languages denoted by L and M, or
  the expression L*,
      where L is a regular expression over A,
    and it denotes the Kleene closure of the language denoted by L.
</XMP>
<P>
>From elementary mathematics you will recall the definition
of rational numbers,
those which "may be written in the form" m/n,
where both m and n are integers.
It came as a great surprise to the Greek mathematicians
that there are irrational numbers,
such as the square root of 2,
or the ratio of the circumference to the diameter of a circle.
Just as rational numbers are defined to be those denoted by fractions,
so <EM>regular language</EM>s are defined
to be those denoted by regular expressions.
It is not a great surprise to learn that there are languages that are
not regular.
A very simple example is the language of well-formed strings
of parentheses: <CODE>{"()", "()()", "(())", "(())()", ...}</CODE>.
<P>
Context free grammars, such as the (extended) <EM>BNF</EM> notation
we have been using,
are a more powerful language description mechanism,
adequate for the language of well-formed parentheses and many others.
We shall look at context free languages in Chapter 11.
But even these are not powerful enough for all languages,
and other kinds of descriptions have been investigated,
such as context sensitive grammars, attribute grammars,
and van Wijngarden's two level grammars.
In all of these an attempt is made to describe infinite languages ---
sets containing an infinite number of finitely long strings.
Although the languages are infinite,
the descriptions are finitely long and certainly shorter
than most of the strings in the language they describe.
It so turns out that there are languages for which there is no finite
description mechanism at all;
the most important of these is the language of arithmetic truths ---
a result proved by G\"{o}del more than half a century ago.
You should consult a book on formal language theory
for some details.
<H3>Exercises and reading</H3>
<P>
<EM>Formalisation</EM>:
1) Give recursive definitions of all the operations on languages.
2) Attempt an axiomatisation of all the laws
satisfied by the algebra of operations on languages.
<P>
<EM>MU-expression</EM>:
The expressive power of regular expressions can be increased
dramatically by <CODE>MU</CODE>-expressions,
which are a little similar to <CODE>LET</CODE>-expressions.
First, suppose we introduced <CODE>LETREC</CODE> as a recursive variant of <CODE>LET</CODE>,
with the difference that in <CODE>LETREC i = e IN f</CODE>
the identifier <CODE>i</CODE> is visible and usable inside <CODE>e</CODE>,
and that inside <CODE>e</CODE> it means just what it has been defined to be.
To stop the recursion, some kind of choice is needed
inside <CODE>e</CODE>.
Then define <CODE>MU i = e</CODE> to be short for <CODE>LETREC i = e IN i</CODE>.
The power of <CODE>LETREC</CODE> and <CODE>MU</CODE> depends very much on
what kind of expression <CODE>e</CODE> can be.
If <CODE>e</CODE> is a regular expression, say <CODE>b | aic</CODE>
then <CODE>MU i = b | aic</CODE>
denotes the language <CODE>{"b", "abc", "aabcc", "aaabccc", ...}</CODE>.
(The name <CODE>MU</CODE> is in analogy with <EM>lambda</EM>,
the function abstraction operator in functional languages
such as the lambda-calculus.
One important difference is that a lambda abstraction
needs actual parameters whereas <CODE>MU</CODE> does not;
another difference is that lambda makes abstractions
whereas <CODE>MU</CODE> does not.)
Include <CODE>MU</CODE>-expressions in your study of operations
on languages.
<P>
<EM>Binary relations</EM>:
Study the calculus of binary relations.
Do you see any similarities with the calculus of languages?
Which binary relation corresponds to 0?
Which operation on binary relations corresponds to
concatenation of languages?
Which operation on languages corresponds to the (unary)
converse operation on binary relations?
<P>
<EM>Reading</EM>:
For regular expressions and regular languages in general,
see the reading given in Chapter 11.
<H2>A regular expression expander</H2>
<P>
In this section we shall write a program which reads regular expressions
and expands them to strings which are in the language
denoted by the expression.
<H3>User manual</H3>
<P>
The program reads regular expressions over the alphabet of lower case letters,
and then writes all the strings in the language denoted by the expression.
To avoid the program running forever on infinite languages,
or to avoid the program running for too long on large languages,
an upper limit can be set for the maximum length
of the strings to be generated.
<P>
The program is intended for interactive use,
and it provides a few prompts where appropriate.
The grammar for an interactive session is:
<XMP>
session      ::=   ['H' | input [ number ]] '.'
</XMP>
The program repeatedly gives the top level prompt:
<XMP>
input (for help type H) =
</XMP>
At this point the user may request help by responding with the
character <CODE>H</CODE>.
The program then prints the following help message
which is the BNF grammar for normal input:
<XMP>
input        ::=   expression '.'
expression   ::=   term ['|' term]
term         ::=   factor [factor]
factor       ::=   (atom | '(' expression ')') ['*' | '+' | '?']
atom         ::=   'a' | 'b' | .. 'z' | '0' | '\' any character
</XMP>
The help message continues with a few examples.
If the user did not request the help message,
the program expects an expression terminated by a period <CODE>.</CODE>..
<P>
An expression consists of one or more terms separated by <CODE>|</CODE>,
and it denotes the union of the languages denoted by these terms.
A term consists of one or more factors,
and it denotes the concatenation of the languages denoted by these factors.
Note that there is no explicit concatenation symbol.
A factor is either an atom or an expression enclosed in parentheses,
and it may be followed by any number of postfix operators
<CODE>*</CODE>, <CODE>+</CODE> or <CODE>?</CODE>.
An atom is either a lower case letter,
denoting the language consisting of just that letter,
or it is the digit <CODE>0</CODE>, denoting the language consisting of just the
null string, or it is the escape character <CODE>\</CODE> followed
by any character and it denotes the language
consisting of just that character.
A factor which is just an atom or a parenthesised expression
denotes the language denoted by the atom or the expression.
An operand followed by <CODE>*</CODE> denotes the Kleene closure
of the language denoted by the operand.
An operand followed by <CODE>+</CODE> denotes the positive closure
of the language denoted by the operand.
An operand followed by <CODE>?</CODE> denotes the union of the
language containing just the null string
with the language denoted by the operand.
<P>
If an illegal character, say <CODE>X</CODE> occurs,
an error message is given which will be one of:
<XMP>
Error: seen "X" when beginning of factor expected
Error: seen "X" when ")" expected
Error: seen "X" when "." expected
Error: seen "X" when regular expression too long
</XMP>
The last message will only be given for regular expressions
containing more that 50 printing characters, not counting parentheses
but counting implicit concatenations.
After an error has been given,
the rest of the input line is discarded
and the program returns to the top level prompt.
<P>
When an expression terminated by <CODE>.</CODE> has been read successfully,
the program repeatedly prompts:
<XMP>
current maximum [0..50] =
</XMP>
At this point the program expects the user to type an integer,
and if the integer typed is greater than 50,
it is taken to be 50.
If the integer is positive,
the program will now expand the regular expression,
and print on separate lines
all strings over the alphabet <CODE>{a .. z}</CODE>
which are in the language denoted by the regular expression
and which do not exceed the given integer in length.
The null string does not print,
but to avoid accidental infinite loops as may be caused
by regular expressions containing <CODE>0*</CODE> explicitly or implicitly,
the null string is taken to contribute to the length
as much as any other atom.
When all strings have been printed,
the program returns to the prompt for another integer.
If the integer is not positive,
the program returns to the top level prompt.
<P>
The following is a brief interaction:
<XMP>
$ RUN 23REGEXP.EXE
input (for help type H) =
a*  |  (bcd | efghij) + .
current maximum [0..50] =
10

a
aa
aaa
aaaa
aaaaa
aaaaaa
aaaaaaa
aaaaaaaa
aaaaaaaaa
bcd
efghij
bcdbcd
bcdefghij
bcdbcdbcd
efghijbcd
current maximum [0..50] =
0
input (for help type H) =
.
</XMP>
Note that the length was set to 10,
but that no strings are longer than 9.
This because the null-string implicit in the Kleene star
operation was taken to contribute 1 to the length,
as explained earlier.
<H3>Designing the implementation</H3>
<P>
The program has to read regular expressions, generate internal code
and expand the internal code.
The structure of the main program and of the principal procedures
follows the structure of the grammar given
in the manual, and there should be no difficulties.
For the parser and translator to internal code
we use the design steps of previous chapters.
The steps for satisfying visibility requirements
and writing a recursive descent parser are routine by now.
But it is worth mentioning that there is no need to have
a separate parsing procedure for the non-terminal atom;
in the BNF grammar the notion of atoms was introduced because
it makes the description simpler,
whereas in the parser the atomic cases are just as readily
handled by procedure factor.
For the internal code we take a tree representation
similar to the one in Chapter 7 for the TYPROC language,
and we use essentially the same method of generating code.
The single number which is the address of the principal node
of the internal tree has to be passed as a parameter to the interpreter
which expands the regular expression to a list of strings.
The remainder of this section deals with just this expansion process.
<P>
An ordinary recursive tree traversal will not do,
since at best it would produce the regular expression
in prefix or infix or postfix format.
A very different kind of traversal is needed.
The traversal to be described here will be useful
in several later chapters which deal with AND<CODE>/</CODE>OR trees
of various kinds.
For this reason the algorithm should be well understood.
<P>
Initially we concentrate on concatenation, alternation
and atoms; the three closure operators are treated later.
As a starting point we take the associativity of
concatenation and the (right) distributivity of concatenation
over alternation,
as expressed by the two laws:
<XMP>
        (A B) C      ==    A (B C)
        (A | B) C    ==    A C | B C
</XMP>
The two laws can of course be used in either direction,
but we shall use them left to right in the expansion process,
as indicated by the following sketch of an algorithm.
Note that the first two clauses reduce the complexity
of the left part of the expression, and that there is always
a right part, <CODE>C</CODE>.
Eventually the left part will be an atom.
<XMP>
To expand  (A B) C :
    expand  A (B C).
To expand  (A | B) C :
    expand  A C | B C.
To expand  'a' C :
    append 'a' to the output string;
    expand C.
</XMP>
Note the presence of <CODE>C</CODE> in all three clauses of the sketch;
since a regular expression will not always be a concatenation,
a dummy <CODE>C</CODE> will have to be added in the initial call,
and recognised as a dummy by the expansion procedure.
In fact, when the dummy <CODE>C</CODE> has been reached,
this will be a signal that an output string
has been completed and is ready for printing.
Obviously expanding a concatenation <CODE>X Y</CODE> must mean
expanding <CODE>X</CODE> and then expanding <CODE>Y</CODE>,
and it is natural to take expanding an alternation
<CODE>X | Y</CODE> to mean
expanding <CODE>X</CODE> and then expanding <CODE>Y</CODE> ---
although it could be done the other way around.
But the two occurrences of <EM>and then</EM> in the previous sentence
do not mean the same at all,
the first means <EM>followed by</EM>,
and the second means <EM>and then do</EM> ---
the sequencing of actions.
We may formalise this by giving expand two parameters,
what to do first and what to do next.
<XMP>
To expand (A B) and then C :
    expand A and then (B C).
To expand (A | B) and then C :
    expand A and then C;
    expand B and then C.
To expand an atom 'a' and then C :
    append 'a' to the output string;
    expand C and then nothing;
    [remove 'a' from the output string]
</XMP>
<P>
Using the technique of a continuation parameter
introduced in Chapter 8,
it is an easy matter to turn the above pseudo-code
into a Pascal procedure.
It has two parameters,
what to expand first and what to expand next.
The first parameter is given as a regular expression,
or more precisely as an integer pointer to a tree representation
of the regular expression.
The second parameter is given as a continuation procedure
which, when called, expands whatever else has to be expanded.
The following is a high level description:
<XMP>
PROCEDURE show;
BEGIN write the string that has been generated END;

PROCEDURE expand(t : tree; PROCEDURE cp);
    PROCEDURE expandright;
    BEGIN expand(right of t; cp) END;
BEGIN (* expand *)
CASE operator of t OF
    cat : expand(left of t; expandright);
    alt : expand(left of t, cp); expand(right of t, cp);
    atm : append the atom to the string;
          cp;
          delete the atom from the string
    END (* CASE *)
END; (* expand *)

BEGIN (* main *)
...
   read a regular expression t
   make the global string empty
   expand(t,show)
...
END. (* main *)
</XMP>
The description given should be adequate as a guide for
writing the expanding procedure.
The three closure operators have to be implemented in a similar way.
If you are writing the implementation yourself,
then the three lines that you need might well be the hardest
you have ever written.
In addition you will also need one further local procedure
to be used as a continuation in two of those lines.
<P>
To stop expansion beyond the current maximum length,
two further additions are required:
In the main body of the program the call to <CODE>expand</CODE>
has to be wrapped inside a loop which writes a prompt for the maximum,
reads the maximum, and only then calls <CODE>expand</CODE>.
In the body of <CODE>expand</CODE>
the <CODE>CASE</CODE> statement has to be guarded by a test
that the length of the string generated so far
does already exceed the maximum.
<P>
For efficiency during the expansion process we can make one more
modification.
Up to this point we have always considered
straight-forward translation from the productions of the grammar
to the parsing and translating procedures
<CODE>expression</CODE>, <CODE>term</CODE> and <CODE>factor</CODE>.
The tree code generated this way is not the best,
since it is left linear; it would be better if it were right linear.
To obtain right linear trees for both alternation and concatenation,
it is best if the parsing and tree generating procedures
for expressions and terms are based on the following productions:
<XMP>
expression   ::=   term {'|' expression}
term         ::=   factor {term}
</XMP>
The language of regular expressions is not changed
by substituting these two productions for their originals.
<H3>The program</H3>
<P>
The following is the standard Pascal source program
for the regular expression expander.
<XMP>
PROGRAM regexp(input,output);
(* REGular Expression eXPander *)

LABEL 1, 99;

CONST
    mcode = 50;
    maxstring = 50;
TYPE
    message = PACKED ARRAY [1..30] OF char;
    operator = (nul,sym,cat,alt,rep,pos,opt);
VAR
    ch : char;
    code : ARRAY [1..mcode] OF
                RECORD op : operator; left,right : integer END;
    cx,i : integer;
    finished : boolean;

    s : ARRAY [1..maxstring] OF char;
    p,m : integer;

(* - - - - -  R E A D E R - - - - - *)

PROCEDURE getch;
BEGIN
REPEAT
    IF eof THEN GOTO 99;
    read(ch)
    UNTIL ch > ' '
END  (* getch *);

PROCEDURE error(mes: message);
BEGIN
writeln;
writeln('Error : seen "',ch,'" when ',mes);
readln;
GOTO 1
END;

PROCEDURE gen(o : operator; l,r : integer);
BEGIN
cx := cx + 1;
IF cx > mcode THEN
    error('regular expression is too long');
WITH code[cx] DO
    BEGIN op := o; left := l; right := r END
END; (* gen *)

PROCEDURE expression;
VAR left : integer;

    PROCEDURE term;
    VAR left : integer;

        PROCEDURE factor;
        BEGIN (* factor *)
        CASE ch OF
            '0' :
                BEGIN
                gen(nul,0,0);
                getch
                END;
            'a','b','c','d','e','f','g','h','i',
            'j','k','l','m','n','o','p','q','r',
            's','t','u','v','w','x','y','z' :
                BEGIN
                gen(sym,ord(ch),0);
                getch;
                END;
            '\' :
                BEGIN
                gen(sym,ord(input^),0);
                read(ch); getch
                END;
            '(' :
                BEGIN
                getch;
                expression;
                IF ch = ')' THEN getch ELSE
                    error('")" expected                  ')
                END;
            END; (* CASE *)
        WHILE ch IN ['*','+','?'] DO
            BEGIN
            CASE ch OF
                '*' : gen(rep,0,cx);
                '+' : gen(pos,0,cx);
                '?' : gen(opt,0,cx)
                END;
            getch
            END (* WHILE *)
        END; (* factor *)

    BEGIN (* term *)
    factor;
    IF ch IN ['0','a'..'z','(','\' ] THEN
        BEGIN
        left := cx;
        term;
        gen(cat,left,cx)
        END
    END (* term *);

BEGIN (* expression *)
term;
IF ch = '|' THEN
    BEGIN
    getch;
    left := cx;
    expression;
    gen(alt,left,cx)
    END
END (* expression *);

(* - - - - -  E X P A N D E R  - - - - - *)

PROCEDURE show;
VAR i : integer;
BEGIN (* show *)
FOR i := 1 TO p DO write(s[i]);
writeln
END; (* show *)

PROCEDURE expand(t : integer; PROCEDURE cp);

    PROCEDURE putch(c : integer);
    BEGIN p := p+1; s[p] := chr(c); cp; p := p-1 END;

    PROCEDURE ditto;
    BEGIN expand(t,cp) END;

    PROCEDURE expand_right;
    BEGIN expand(code[t].right,cp) END;

BEGIN (* expand *)
IF p < m THEN
    WITH code[t] DO
        CASE op OF
            nul : putch(0);
            sym : putch(left);
            cat : expand(left,expand_right);
            alt : BEGIN expand(left,cp); expand(right,cp) END;
            rep : BEGIN putch(0); expand(right,ditto) END;
            pos : BEGIN expand(right,cp); expand(right,ditto) END;
            opt : BEGIN putch(0); expand(right,cp) END;
            END (* CASE *)
END; (* expand *)

(* - - - - -  M A I N  - - - - - *)

BEGIN (* main *)
finished := false;
1:
REPEAT
    writeln('input (for help type H) =  ');
    getch;
    IF ch = 'H' THEN
    BEGIN
        writeln;
        writeln('input        ::=   expression ''.''');
        writeln('expression   ::=   term [''|'' term]');
        writeln('term         ::=   factor [factor]');
        writeln('factor       ::=   ',
                '(atom | ''('' expression '')'') ',
                '[''*'' | ''+'' | ''?'']');
        writeln('atom         ::=   ',
                '''a'' | ''b'' | .. ''z'' | ''0'' | ',
                ' ''\'' any character');
        writeln;
        writeln('examples:');
        writeln('    a | bc | def .');
        writeln('    ( a* (bc)+  |  (defg)?  |  hh0hh )*  .');
        writeln;
        END
    ELSE IF ch &lt> '.' THEN
        BEGIN
        cx := 0;
        expression;
        IF ch &lt> '.' THEN
            error('"." expected                  ');
        REPEAT
            writeln('current maximum [0..',maxstring:0,'] = ');
            read(m);
            IF m > maxstring THEN m := maxstring;
            IF m > 0 THEN BEGIN p := 0; expand(cx,show) END
            UNTIL m < 1
        END
    ELSE finished := true
    UNTIL finished;
99:
END.
</XMP>
<H3>Exercises and reading</H3>
<P>
<EM>Parser</EM>:
The program as given is a regular expression generator.
Modify the program to turn it into a regular expression parser:
the program should 1) read a regular expression, and
2) repeatedly read a string and determine
whether the string is in the language defined by the expression.
<P>
<EM>Futility heuristic</EM>:
As implemented, the program will often try to generate
a string but then fail because the maximum length is exceeded.
It would be possible to avoid this by a different form of internal
code, in which every node has an additional integer field which
is the minimum length required to complete the string.
These fields can be computed at compile time
in a simple manner.
At expansion time the field is examined to determine whether
the string to be generated will not exceed the current maximum length.
The technique is equally applicable to generating
as it is to parsing.
This is a heuristic used by the Snobol processor,
see for example Griswold (1972, p 126).
<P>
<EM>Reading</EM>:
For a quite different way of implementing regular expression parsing,
see Kernighan and Plauger (1981, Ch. 5).
But note that their pattern matcher uses unanchored searches,
and it does not have alternation at all.
<P>
<EM>Background reading</EM>:
For a description of the technique
of using continuations as parameters to implement backtracking,
see Mellish and Hardy (1984, p 150).
Now that you know how procedures as parameters can be used for
something useful such as backtracking,
you might now wonder
how procedures as parameters are implemented ---
see MacLennan (1983, pp 247 -250).
<P>
<EM>MU-expression</EM>:
Add the power of <CODE>MU</CODE>-expressions to the expanding program.
To make it easy for yourself,
let <CODE>MU</CODE> always define single character symbols,
say upper case letters.
There are two possibilities
for calling a <CODE>MU</CODE>-defined symbol:
Either they are simply used,
but if they are to be taken literally then they are escaped with <CODE>\</CODE>.
Or they are escaped with, say, <CODE>$</CODE> for use,
and left unescaped when they are to be taken literally.
You might want to review
the macro expansion program in Chapter 4,
both for a possible syntax and for the implementation.
<H3>Addendum 2003</H3>
<P>
Pascal is one of only a few languages which allows
local procedures to be passed as parameters in recursive calls.
It is of some interest to see whether there are other ways to
achieve the same effect.
The next program below is again a Pascal program, but it
uses an explicit stack of continuations instead of local procedures.
<P>
<PRE>
PROGRAM regexp_no_contin(input,output);
(* Using explicit links to implement continuation *)

LABEL 1, 99;

CONST
    mcode = 50;
    maxstring = 50;
TYPE
    message = PACKED ARRAY [1..30] OF char;
    operator = (nul,sym,cat,alt,rep,pos,opt);
VAR
    ch : char;
    code : ARRAY [1..mcode] OF
                RECORD op : operator; left,right : integer END;
    cx,i : integer;
    finished : boolean;

    s : ARRAY [1..maxstring] OF char;
    p,m : integer;

    links : ARRAY [1..maxstring] OF
		RECORD t, cp : integer END;
    lastlink : integer;

(* - - - - -  R E A D E R - - - - - *)

PROCEDURE getch;
BEGIN
REPEAT
    IF eof THEN GOTO 99;
    read(ch)
    UNTIL ch > ' '
END  (* getch *);

PROCEDURE error(mes: message);
BEGIN
writeln;
writeln('Error : seen "',ch,'" when ',mes);
readln;
GOTO 1
END;

PROCEDURE gen(o : operator; l,r : integer);
BEGIN
cx := cx + 1;
IF cx > mcode THEN
    error('regular expression is too long');
WITH code[cx] DO
    BEGIN op := o; left := l; right := r END
END; (* gen *)

PROCEDURE expression;
VAR left : integer;

    PROCEDURE term;
    VAR left : integer;

        PROCEDURE factor;
        BEGIN (* factor *)
        CASE ch OF
            '0' :
                BEGIN
                gen(nul,0,0);
                getch
                END;
            'a','b','c','d','e','f','g','h','i',
            'j','k','l','m','n','o','p','q','r',
            's','t','u','v','w','x','y','z' :
                BEGIN
                gen(sym,ord(ch),0);
                getch;
                END;
            '\' :
                BEGIN
                gen(sym,ord(input^),0);
                read(ch); getch
                END;
            '(' :
                BEGIN
                getch;
                expression;
                IF ch = ')' THEN getch ELSE
                    error('")" expected                  ')
                END;
            END; (* CASE *)
        WHILE ch IN ['*','+','?'] DO
            BEGIN
            CASE ch OF
                '*' : gen(rep,0,cx);
                '+' : gen(pos,0,cx);
                '?' : gen(opt,0,cx)
                END;
            getch
            END (* WHILE *)
        END; (* factor *)

    BEGIN (* term *)
    factor;
    IF ch IN ['0','a'..'z','(','\' ] THEN
        BEGIN
        left := cx;
        term;
        gen(cat,left,cx)
        END
    END (* term *);

BEGIN (* expression *)
term;
IF ch = '|' THEN
    BEGIN
    getch;
    left := cx;
    expression;
    gen(alt,left,cx)
    END
END (* expression *);

(* - - - - -  E X P A N D E R  - - - - - *)

PROCEDURE expand(t : integer; cp : integer);
VAR savelastlink : integer;

    PROCEDURE putch(c : integer);
    BEGIN
    p := p+1; s[p] := chr(c);
    IF cp > 0 THEN expand(links[cp].t, links[cp].cp) ELSE
	BEGIN (* show *)
	For i := 1 TO p DO write(s[i]);
	writeln
	END;
    p := p-1
    END;

    FUNCTION newcp(t : integer) : integer;
    BEGIN
    lastlink := lastlink + 1;
    links[lastlink].t := t;
    links[lastlink].cp := cp;
    newcp := lastlink
    END;

BEGIN (* expand *)
savelastlink := lastlink;
IF p < m THEN
    WITH code[t] DO
        CASE op OF
            nul : putch(0);
            sym : putch(left);
            cat : expand(left,newcp(right));
            alt : BEGIN expand(left,cp); expand(right,cp) END;
            rep : BEGIN putch(0); expand(right,newcp(t)) END;
            pos : BEGIN expand(right,cp); expand(right,newcp(t)) END;
            opt : BEGIN putch(0); expand(right,cp) END;
            END; (* CASE *)
lastlink := savelastlink
END; (* expand *)

(* - - - - -  M A I N  - - - - - *)

BEGIN (* main *)
finished := false;
1:
REPEAT
    writeln('input (for help type H) =  ');
    getch;
    IF ch = 'H' THEN
    BEGIN
        writeln;
        writeln('input        ::=   expression ''.''');
        writeln('expression   ::=   term [''|'' term]');
        writeln('term         ::=   factor [factor]');
        writeln('factor       ::=   ',
                '(atom | ''('' expression '')'') ',
                '[''*'' | ''+'' | ''?'']');
        writeln('atom         ::=   ',
                '''a'' | ''b'' | .. ''z'' | ''0'' | ',
                ' ''\'' any character');
        writeln;
        writeln('examples:');
        writeln('    a | bc | def .');
        writeln('    ( a* (bc)+  |  (defg)?  |  hh0hh )*  .');
        writeln;
        END
    ELSE IF ch <> '.' THEN
        BEGIN
        cx := 0;
        expression;
        IF ch <> '.' THEN
            error('"." expected                  ');
        REPEAT
            writeln('current maximum [0..',maxstring:0,'] = ');
            read(m);
            IF m > maxstring THEN m := maxstring;
            IF m > 0 THEN
		BEGIN lastlink := 0; p := 0; expand(cx,0) END
            UNTIL m < 1
        END
    ELSE finished := true
    UNTIL finished;
99:
END.
</PRE>
<P>
The next program is essentially a translation of the previous program
into the C language (which officially
does not allow local functions inside other
functions). 
<P>
<PRE>
/* regular expression expander */
/* Using explicit links to implement continuation */

#include <stdio.h>
#include <setjmp.h>
					/* Reading an expression : */
#define maxcode 200
jmp_buf begin;
int echo = 0;
char ch;
struct {char op; int left;} code[maxcode];
int cx;
void getch();
void error();
void generate(char c, int l);
void expression();
void term();
void factor();

void getch()
{
do { ch = getchar(); if (echo) putchar(ch); }
    while (ch <= ' ');
}
void error(char * mes)
{
    printf("error: seen '%c' when %s\n",ch,mes);
    do ch = getchar(); while (ch != '\n');
    longjmp(begin,0);
}
void generate(char c, int l)
{
    cx++;
    code[cx].op = c; code[cx].left = l;
}
void expression()
{
    int left;
    term();
    if (ch == '|')
      { left = cx; getch();
	expression();
	generate('|',left); }
}
void term()
{
    int left;
    factor();
    if (ch >= 'a' && ch <= 'z'  ||  ch == '0'  ||  ch == '(')
      { left = cx;
	term();
	generate('_',left); }
}
void factor()
{
    if (ch >= 'a' && ch <= 'z')
      { generate('a',ch); getch(); }
    else if (ch == '0')
      { generate('0',0); getch(); }
    else if (ch == '(')
      { getch(); expression();
	if (ch == ')') getch();
	    else error("')' expected"); }
    else error("'a'..'z','0' or '(' expected");
    while (ch == '*' || ch == '+' || ch == '?')
      { generate(ch,0); getch(); }
}
					/* Generating the strings */
#define maxstring 50
struct {int t; int cp;} links[maxcode];
int lastlink;
char s[maxstring];
int p,m;
int newcp(int t, int cp);
void putch(char c, int cp);
void expand(int t, int cp);

int newcp( int t, int cp)
{
    lastlink++;
    links[lastlink].t = t;
    links[lastlink].cp = cp;
    return lastlink;
}
void putch(char c, int cp)
{
    int i;
    s[++p] = c;
    if (cp >= 0) expand(links[cp].t, links[cp].cp);
    else
      { for (i = 0; i <= p; i++) printf("%c",s[i]);
	printf("\n"); }
    p--;
}
void expand(int t, int cp)
{
    if (p < m)
      { char op = code[t].op;
	int left = code[t].left;
	int right = t - 1;
	int savelastlink = lastlink;
	switch (op)
	  { case 'a' :
		putch(left,cp);
		break;
	    case '0' :
		putch(0,cp);
		break;
	    case '_' :
		expand(left,newcp(right,cp));
		break;
	    case '|' :
		expand(left,cp);
		expand(right,cp);
		break;
	    case '*' :
		putch(0,cp);
		expand(right,newcp(t,cp));
		break;
	    case '+' :
		expand(right,cp);
		expand(right,newcp(t,cp));
		break;
	    case '?' :
		putch(0,cp);
		expand(right,cp);
		break; }
	lastlink = savelastlink; }
}
void main()
{
    int finished = 0;
    setjmp(begin);
    do
      { printf("?- "); getch();
	if (ch == '!') { echo = 1; getch(); }
	if (ch != '.')
	  { cx = -1; expression();
	    if (ch != '.')  error("'.' expected");
	    do
	      { printf("current maximum [0..%d]\n",maxstring);
		scanf("%d",&m);
		if (m > maxstring) m = maxstring;
		if (m > 0)
		 { p = -1; lastlink = -1; expand(cx,-1); } }
	    while (m > 0); }
	else finished = 1; }
    while (!finished);
}
</PRE>
<P>
Another way of solving the problem is shown by the following
version, also in the C language.
<P>
<PRE>
/* regular expression expander */
/* using stack addresses to implement continuation */

#include <stdio.h>
#include <setjmp.h>
					/* Reading an expression : */
#define maxcode 200
jmp_buf begin;
int echo = 0;
char ch;
struct {char op; int left;} code[maxcode];
int cx;
void getch();
void error();
void generate(char c, int l);
void expression();
void term();
void factor();

void getch()
{
do { ch = getchar(); if (echo) putchar(ch); }
    while (ch <= ' ');
}
void error(char * mes)
{
    printf("error: seen '%c' when %s\n",ch,mes);
    do ch = getchar(); while (ch != '\n');
    longjmp(begin,0);
}
void generate(char c, int l)
{
    cx++;
    code[cx].op = c; code[cx].left = l;
}
void expression()
{
    int left;
    term();
    if (ch == '|')
      { left = cx; getch();
	expression();
	generate('|',left); }
}
void term()
{
    int left;
    factor();
    if (ch >= 'a' && ch <= 'z'  ||  ch == '0'  ||  ch == '(')
      { left = cx;
	term();
	generate('_',left); }
}
void factor()
{
    if (ch >= 'a' && ch <= 'z')
      { generate(ch,0); getch(); }
    else if (ch == '0')
      { generate('0',0); getch(); }
    else if (ch == '(')
      { getch(); expression();
	if (ch == ')') getch();
	    else error("')' expected"); }
    else error("'a'..'z','0' or '(' expected");
    while (ch == '*' || ch == '+' || ch == '?')
      { generate(ch,0); getch(); }
}
					/* Generating the strings */
#define MAXSTRING 50
char s[MAXSTRING];
int p,m;
void putch(char c, int cp);
void expand(int t, int cp);

void putch(char c, int cp)
{
    int i;
    s[++p] = c;
    if (cp > 0) expand(*(int *)(cp + 8), *(int *)cp);
    else
      { for (i = 0; i <= p; i++) printf("%c",s[i]);
	printf("\n"); }
    p--;
}
int dummy;
void expand(int t, int cp)
{
    int newt,newcp;
    #define OP code[t].op
    #define LEFT code[t].left
    #define RIGHT (t-1)
    #define NEXT(T)  (newt = T, newcp = cp, (int)&newcp)
    dummy = (int)&newt - (int)&newcp; /* delete this at your peril ! */
    if (p < m)
	switch (OP)
	  { case '0' :
		putch(0,cp);
		break;
	    case '_' :
		expand(LEFT,NEXT(RIGHT));
		break;
	    case '|' :
		expand(LEFT,cp);
		expand(RIGHT,cp);
		break;
	    case '*' :
		putch(0,cp);
		expand(RIGHT,NEXT(t));
		break;
	    case '+' :
		expand(RIGHT,cp);
		expand(RIGHT,NEXT(t));
		break;
	    case '?' :
		putch(0,cp);
		expand(RIGHT,cp);
		break;
	    default :
		putch(OP,cp);
		break; }
}
void main()
{
    int finished = 0;
    setjmp(begin);
    do
      { printf("?- "); getch();
	if (ch == '!') { echo = 1; getch(); }
	if (ch != '.')
	  { cx = -1; expression();
	    if (ch != '.')  error("'.' expected");
	    do
	      { printf("current maximum [0..%d]\n",MAXSTRING);
		scanf("%d",&m);
		if (m > MAXSTRING) m = MAXSTRING;
		if (m > 0)
		 { p = -1; expand(cx,0); } }
	    while (m > 0); }
	else finished = 1; }
    while (!finished);
}
</PRE>

</body>
</HTML>
