<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 20 : A Petri net verifier</title>
<!-- 2013-05-31 Fri 19:12 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="author" content="michal"/>
<link rel="stylesheet" type="text/css" href="/sympas/etc/style.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Chapter 20 : A Petri net verifier</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Introduction</a></li>
<li><a href="#sec-2">2. Nets and Netver</a>
<ul>
<li><a href="#sec-2-1">2.1. Static descriptions of nets</a></li>
<li><a href="#sec-2-2">2.2. Dynamic behaviour</a></li>
<li><a href="#sec-2-3">2.3. Control of behaviour</a></li>
<li><a href="#sec-2-4">2.4. Productions and actions</a></li>
<li><a href="#sec-2-5">2.5. Modes of behaviour</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Syntax</a>
<ul>
<li><a href="#sec-3-1">3.1. Lexical matters</a></li>
<li><a href="#sec-3-2">3.2. Context free syntax</a></li>
<li><a href="#sec-3-3">3.3. Context sensitive restrictions</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Semantics</a>
<ul>
<li><a href="#sec-4-1">4.1. Control primitives</a></li>
<li><a href="#sec-4-2">4.2. Mode selection</a></li>
<li><a href="#sec-4-3">4.3. Primitives from regular algebra</a></li>
<li><a href="#sec-4-4">4.4. Primitives from Boolean algebra</a></li>
<li><a href="#sec-4-5">4.5. Discrete event primitives</a></li>
<li><a href="#sec-4-6">4.6. State primitives</a></li>
<li><a href="#sec-4-7">4.7. Place primitives</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Examples</a></li>
<li><a href="#sec-6">6. Implementation</a></li>
<li><a href="#sec-7">7. <i>Compilation</i>:</a></li>
<li><a href="#sec-8">8. <i>Interpretation</i>:</a></li>
<li><a href="#sec-9">9. The program</a></li>
<li><a href="#sec-10">10. Discussion</a>
<ul>
<li><a href="#sec-10-1">10.1. Embellishments</a></li>
<li><a href="#sec-10-2">10.2. <i>Error recovery</i>:</a></li>
<li><a href="#sec-10-3">10.3. <i>String output</i>:</a></li>
<li><a href="#sec-10-4">10.4. More advanced backtracking</a></li>
<li><a href="#sec-10-5">10.5. <i>Regular and Boolean Algebra</i>:</a></li>
<li><a href="#sec-10-6">10.6. <i>Other Primitives</i>:</a></li>
<li><a href="#sec-10-7">10.7. <i>Optimisations</i>:</a></li>
<li><a href="#sec-10-8">10.8. A more powerful object language</a>
<ul>
<li><a href="#sec-10-8-1">10.8.1. <i>Folding of places</i>:</a></li>
<li><a href="#sec-10-8-2">10.8.2. <i>Predicate Transition Nets</i>:</a></li>
<li><a href="#sec-10-8-3">10.8.3. <i>Queueing places</i>:</a></li>
<li><a href="#sec-10-8-4">10.8.4. <i>Timed Petri Nets</i> (see e.g. Carlier et al 1984):</a></li>
<li><a href="#sec-10-8-5">10.8.5. <i>Parallelism in Paths</i>:</a></li>
<li><a href="#sec-10-8-6">10.8.6. <i>Ports</i>:</a></li>
<li><a href="#sec-10-8-7">10.8.7. <i>Reading</i>:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Netver is a small verifier for Petri nets.  It takes as input a description of a Petri net together with one or more path expressions; it produces as output all possible sequences of firings of transitions, or sets of markings of places.  The path expressions give full control over the output that is produced.
</p>

<p>
Petri nets are difficult to analyse manually; but it is easy enough to write a simulator which produces as output possible firing sequences, or all possible markings that can lead to other markings.  The danger is that the designers then have to wade through enormous output to find what they want.  The verification tool to be described here attempts to avoid this by giving designers only the output they need.  The tool uses two techniques:
</p>

<ol class="org-ol">
<li>instead of working with markings of places it works with sets of markings, and
</li>
<li>detailed control over the firing of transitions is given by a collection of primitives for programmed backtracking.
</li>
</ol>

<p>
Jointly, though less so separately, the two techniques make it possible to introduce powerful primitives for the analysis of nets.
</p>

<p>
The remainder of the chapter is organised as follows:
</p>

<ul class="org-ul">
<li>The next section introduces Petri nets in an elementary way, including a general description of how Netver operates.
</li>
<li>The next two sections give the syntax and the semantics of Netver, the format is (at least at this stage) kept very compact.
</li>
<li>The following section consists of many small examples.
</li>
<li>The implementation is described in the following section.
</li>
<li>A final section attempts to draw some conclusions and discusses future work.
</li>
</ul>

<p>
For an understanding of Petri nets very little is assumed here, but see Peterson (1981) or Reisig (1982) for detail.  For an understanding of the verifier, it would be an advantage to have some familiarity with a backtracking language such as Snobol (Griswold et al, 1971), Icon (Griswold and Hanson, 1979), or Prolog (Clocksin and Mellish, 1981) or with the generators of Clu (Liskov et al, 1981) or Alphard (Shaw 1981).
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Nets and Netver</h2>
<div class="outline-text-2" id="text-2">
<p>
<i>Petri net</i>\s are a species of inputless nondeterministic automata.  The number of states may be finite or infinite, though the ones to be considered here are always finite.  A Petri net consists of a number of passive data components called <i>place</i>\s, together with a number of active processing components called <i>transition</i>\s.
</p>

<p>
The places constitute a factorisation of the set of states; they are variables whose values change over time as events occur.  The transitions are disjoint classes of events; the occurrence of an event in the class is often called a <i>firing</i> of the transition.  The firing of transitions is subject to certain laws which do not change over time.  In many expositions the places, transitions and laws are displayed graphically; such a method will not be used here.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Static descriptions of nets</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Nets have places with an associated positive integer called the capacity of the place.  A place with capacity n is an integer variable whose values range from 0 to n.  In Netver a specification of four places, say <code>a</code>, = b=, = c=, = d=, might look like this:
</p>

<pre class="example">
PLACE
    a, b, c : 1                 (* three places of capacity one *)
    d : 5;                      (* one place of capacity five   *)
</pre>

<p>
The state of a net at any one time is given by an instantaneous description or <i>marking</i> which says what values the place variables have, or how many <i>tokens</i> they contain.  For the place capacities given, the total number of possible markings is 2 * 2 * 2 * 6 = 48.  For example, each of the following six lines describes a possible marking of the net:
</p>

<pre class="example">
a = 0   b = 1   c = 0   d = 2
a = 0   b = 1   c = 0   d = 3
a = 0   b = 1   c = 0   d = 4
a = 0   b = 1   c = 1   d = 2
a = 0   b = 1   c = 1   d = 3
a = 0   b = 1   c = 1   d = 4
</pre>

<p>
For many purposes it is desirable to allow disjunctions of instantaneous descriptions.  In Netver certain disjunctions are allowed, for example
</p>

<pre class="example">
a = [0]   b = [1]   c = [01]   d = [234]
</pre>

<p>
This would express the disjunction of the six sentences given above.  Such a compact form, to be called a <i>hypermarking</i>, represents, not a state, but a set of states of the net, and Netver operates on such state sets.  At any one time a place is specified by a non-empty set of possible markings.  An empty set would be contradictory, and in Netver this never arises.  In the special case where each place contains a unit set, a state set in Netver is exactly the same as a state in an ordinary net.  Note that hypermarkings cannot express all disjunctions of markings, for example "place <code>a</code> is empty or place <code>b</code> is full" cannot be expressed.
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Dynamic behaviour</h3>
<div class="outline-text-3" id="text-2-2">
<p>
The state of a system changes when events occur.  The occurrence of an event depends on some condition, and the occurrence of an event produces some effect.
</p>

<p>
In nets the only events are <i>transition firing</i>\s, and the only conditions are the markings of places, and the only effects are on the markings of places.  Transitions and their firing behaviour are specified by input arcs from places and output arcs to places, and each arc has an associated positive integer not exceeding the capacity of the place from which it comes or to which it goes.
</p>

<p>
The firing of a transition depends on the condition that
</p>

<ol class="org-ol">
<li>at each place from which there is an input arc there are at least as many tokens as specified by the arc, and
</li>
<li>at each place to which there is an output arc there are at least as many vacancies as specified by the arc.
</li>
</ol>

<p>
The firing of a transition has the effect that
</p>
<ol class="org-ol">
<li>at each place from which there is an input arc the number of tokens is decreased by as many tokens as specified by the input arc, and
</li>
<li>at each place to which there is an output arc the number of tokens is increased by as many tokens as specified by the output arc.
</li>
</ol>

<p>
In Netver declarations of, say, three transitions <code>t</code>, <code>u</code>, <code>v</code>
and their associated arcs might look like this:
</p>

<pre class="example">
TRANSITION
    t  INARC a 1; OUTARC b,c 1;
    u  INARC b 1; OUTARC d 3;
    v  INARC c 1; INARC d 2; OUTARC a,b 1;
</pre>

<p>
In the example given, transition <code>v</code> may fire if place <code>c</code> contains one token, place <code>d</code> contains at least two tokens, and places <code>a</code> and <code>b</code> have one vacancy each.  If transition <code>v</code> does fire, then the token is removed from <code>c</code>, two tokens are removed from <code>d</code>, and one token is added to each of <code>a</code> and <code>b</code>.
</p>

<p>
A net is normally given an initial marking of the places and then allowed to run.  Because of the indeterminism, many different sequences of transition firings can result.  In Netver places have hypermarkings, and a special case of a hypermarking is a non-disjunctive marking in which for each place it is specified exactly how many tokens it contains.  Therefore Netver can be used to simulate the running of initialised nets.  An initialisation might take the form:
</p>

<pre class="example">
SET a 1   SET b 0   SET c 1   SET d 2
</pre>

<p>
This assigns to each place a, b, c, d a marking given by the numeral following.  However, it is also possible to give a partial initialisation, such as
</p>

<pre class="example">
SET a 0   SET b 1   SET c 0 1   SET d 2 3 4
</pre>

<p>
This gives the net the disjunctive hypermarking used in the previous section.
</p>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Control of behaviour</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Netver is designed to analyse sequences of firings of nets with hypermarkings.  To avoid the generation of sequences that are of no interest to the designer of the net, mechanisms are provided to allow arbitrarily tight control over the firings.  Sequences of firings are just strings over an alphabet whose vocabulary is the set of transitions, and hence the possible behaviour of a net is essentially a language over the transitions.  Since nets are typically designed to run forever, their language contains infinitely long sequences.  For a mathematical understanding, the work of Engelfriet (1974) on program schemes is applicable here.
</p>

<p>
To analyse finite portions of the language, Netver uses concepts familiar from formal language theory, in particular /path expression/s, which are essentially regular expressions with several extensions.  A backtracking mechanism handles the generation of all and only those firing sequences which
</p>

<ol class="org-ol">
<li>can be produced by the net, <i>and</i>
</li>
<li>the user wants to know about.
</li>
</ol>

<p>
Path expressions are built from atomic operands and a few operators.  The atoms are transitions, and the operations include at least a binary operation of composition, a binary operation of alternation, and a unary operation of indefinite repetition.  Using, say, the four transitions <code>t</code>, <code>u</code>, <code>v</code>, <code>w</code> as atoms, the construction
</p>

<pre class="example">
composition(alternation(t,u), alternation(v,w))
</pre>

<p>
is written
             (t | u) (v | w)
and it means:
</p>

<ul class="org-ul">
<li>first fire either <code>t</code> or <code>u</code>,
</li>
<li>and then fire either <code>u</code> or <code>v</code>.
</li>
</ul>

<p>
By the distribution of composition over alternation, the above expression is equivalent to
</p>

<pre class="example">
t v   |   t w   |   u v   |   u w
</pre>

<p>
This is how the expansion appears to the user; but internally the verifier avoids having to fire <code>t</code> and <code>u</code> twice by treating it as
</p>

<pre class="example">
t (v | w)   |   u (v | w)
</pre>

<p>
Path expressions have been used by Campbell and Habermann (1974) for specifying process synchronisation; their use here for a verifier is quite different.
</p>

<p>
Because of the backtracking, the behaviour of Netver is similar to that of Prolog (see for example Clocksin and Mellish, 1981):
</p>

<ol class="org-ol">
<li>The set of solutions that will be found, considered as an unordered set, depends only on the set of defined or allowed paths, also considered as an unordered set.
</li>

<li>The sequence of solutions that will be found, now considered as an ordered set, depends on the sequence of defined or allowed paths, also considered in their order.
</li>
</ol>

<p>
In particular, the idempotent law, which says that the disjunction <code>p | p</code> is equivalent to just <code>p</code>, and the commutative law, which says that <code>p | q</code> is equivalent to <code>q | p</code>, hold for unordered solution sets but not for ordered solution sets.
</p>

<p>
In addition to the primitives from formal language theory or regular algebra, there are <code>LOGICAL</code> variables &#x2014; in the sense of propositional calculus or Boolean algebra, not in the sense of Prolog.  These can be used to structure execution paths in a clean way.  However, very little is known at this stage about the interplay between the concepts from the two algebras.  Hence the inclusion of logical variables is quite tentative.
</p>

<p>
Apart from the clean primitives from regular and Boolean algebra, Netver has several powerful and useful primitives which render it impure in the same way that Prolog is rendered impure by cut, assert, retract, numbervars etc.  Netver's impure primitives are <code>ABORT</code>, <code>FENCE</code>, <code>NEWSCOPE</code>, <code>MAXLENGTH</code>, <code>MAXPATHS</code> and a few others having to do with saved states; these primitives are described in detail in the manual.
</p>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Productions and actions</h3>
<div class="outline-text-3" id="text-2-4">
<p>
It is useful to be able to write a path expression just once and then refer to it repeatedly by its name.  For this purpose Netver has /production/s similar to those used in grammars.  Identifiers declared in a production are just like the non-terminals of a grammar, and transitions are just like the terminals of a grammar.  A path expression then is built up by means of the regular expression operators from atoms that have been declared in transition or production declarations.  Transition firings count as events and will be recorded for possible printout, whereas non-terminals of productions do not count as events and hence are not recorded.  (It is still an open question whether the recording should perhaps be independently under user control.)
</p>

<p>
Path expressions may also be attached to transitions by <code>ACTION</code> declarations.  A transition thus augmented may fire if its arcs and its path expression allow it.  If it does fire then its explicitly attached places are updated in accordance with its arcs, and any transition in its path is also fired, thus possibly affecting other places indirectly.
</p>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Modes of behaviour</h3>
<div class="outline-text-3" id="text-2-5">
<p>
For a verifier it is useful to be able to distinguish between
</p>
<ol class="org-ol">
<li>a transition being enabled and hence being fired, and
</li>
<li>a transition being enabled but not being fired.
</li>
</ol>
<p>
The first is an event which produces a change, the second is merely a condition for such an event.  In order to be able to distinguish the two, Netver can operate in several modes:
</p>

<ol class="org-ol">
<li>In execution mode, the occurrence of a transition identifier in a path causes an attempt to fire the transition and hence to change the (hyper-)marking of the places to which it is connected; if this succeeds the path is continued, otherwise backtracking occurs.
</li>

<li>In verification mode, the occurrence of a transition identifier in a path merely causes the firing condition of the transition to be tested, by attempting to find a nonempty intersection of the current (hyper-)marking with the marking that would enable the firing; if this succeeds the path is continued, otherwise backtracking occurs.
</li>

<li>There is a third mode, possibility mode, which is like verification mode except that it merely tests whether there is a nonempty intersection; in this mode the hypermarkings are left untouched.
</li>
</ol>

<p>
The distinction between verification mode and possibility mode only makes sense in a system whose states are sets of states of a simulated system.  Further investigation is needed to determine how useful the third mode really is.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Syntax</h2>
<div class="outline-text-2" id="text-3">
<p>
The input language is fairly conventional in its conception; it has user declared identifiers in lower case, reserved words in upper case, and a small number of punctuation characters.  The syntax has some obvious context sensitive restrictions concerning declarations of identifiers.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Lexical matters</h3>
<div class="outline-text-3" id="text-3-1">
<p>
The lexicon is here given in a semi-formal way only.
</p>

<pre class="example">
identifier  ::=
        lower case letter,
        followed by up to 15 further letters or digits or underscores
number  ::=
        one or more digits
reserved word  ::=
        see the terminals of the BNF below,
        in the BNF the terminals are enclosed in double quotes.
comment  ::=
        as in Pascal, any text enclosed in "(*" and "*)".
</pre>

<p>
In addition, the directives from the utilities in Chapter 17 may be used.
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Context free syntax</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Again the syntax below is given in an extended form of BNF: Alternation is represented as <code>|</code>; concatenation is represented (without a symbol) as juxtaposition, and it binds more strongly than alternation; precedences may be overridden by (round) parentheses; repetitions (zero or more times) are enclosed in (square) brackets; options (zero or one times) are enclosed in (curly) braces.
</p>

<pre class="example">
input  ::=
        [block ["PATH" expression {";"}] "."]
block  ::=
        [   "PLACE"
              [ identifier ["," identifier]
                {":"} {number} {";"}  ]
          | "TRANSITION"
              [ identifier ["," identifier]
                [  ("INARC" | "OUTARC")
                     [identifier ["," identifier] {number}]
                  | "ACTION"
                    expression  ] ] {";"}
          | "LOGICAL"
              [ identifier ["," identifier] ] {";"}
          | "PRODUCTION"
              [identifier "::=" expression {";"}]  ]
expression  ::=
        term ["|" term]
term  ::=
        factor [ factor ]
factor  ::=
          identifier
        | ( "NET" | "SKIP" | "FAIL" | "ABORT" | "QUIT" | "SHOW_PATH"
            "DEADLOCK" | "UNREACHABLE" | "SHOW_MARKINGS" | "FENCE" )
        | ( "EXECUTE" | "VERIFY" | "POSSIBLY" |
            "OPT" | "POS" | "REP" | "NOT")  factor
        | ( "LEN" | "TAB" | "MAXLENGTH" | "MAXPATHS" | "POSITION" |
            "SAVE" | "RESTORE" |
            "SAMESTATE" | "SUBSTATE" | "SUPERSTATE"  ) number
        | "TIMES" number factor
        | "EMPTY" identifier
        | ( "ATLEAST" | "ATMOST" ) identifier number
        | "SET" identifier [number]
        | "(" expression ")"
</pre>

<p>
As may be seen from the syntax, the input language has been made as tolerant to minor syntactic variations as possible.  However, there are the following context free restrictions, all derived from the syntax.
</p>

<p>
If a mandatory identifier is missing, the error is always context sensitive, the exact error message is given in the next section.
</p>

<p>
In <code>PLACE</code> declarations, and also in <code>INARC</code> and <code>OUTARC</code> declarations, the number is optional; if it is not given explicitly, <code>1</code> is assumed.
</p>

<p>
In a <code>PRODUCTION</code> declaration the (non-terminal) identifier has to be followed by <code>::=</code>, otherwise the error ="'::=' expected"= is reported.
</p>

<p>
In factors requiring one number, such as those beginning <code>TIMES</code>, <code>LEN</code>, <code>MAXLENGTH</code>, <code>POSITION</code>, and <code>TAB</code>, the lack of a number results in the error <code>number expected</code> to be reported.
</p>

<p>
In a factor beginning with a parenthesis there must be a closing parenthesis, otherwise the error ="')' expected"= is reported.
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Context sensitive restrictions</h3>
<div class="outline-text-3" id="text-3-3">
<p>
There are some context sensitive restrictions having to do with declarations of identifiers.
</p>

<p>
Inside a block, the three kinds of declarations <code>PLACE</code>, <code>TRANSITION</code> and <code>LOGICAL</code> must introduce new identifiers; otherwise the error ="new identifier expected"= is reported.
</p>

<p>
In a transition declaration the <code>INARC</code> and <code>OUTARC</code> declarations must be followed by an identifier that has been previously declared to be a place; otherwise the error ="place identifier expected"= is reported.
</p>

<p>
In a <code>PRODUCTION</code> declaration the identifier must be either new or have been used previously only inside factors, otherwise the error ="nonterminal expected"= is reported.
</p>

<p>
At the end of the block, any identifier <code>xxx</code> first used inside a factor must have been declared in a <code>PRODUCTION</code> declaration, otherwise the error ="xxx is undefined"= is reported.  (Thus use before declaration is permitted.)
</p>

<p>
In a factor consisting of just an identifier, the identifier must be either a previously declared transition or logical or non-terminal identifier, or it must be a new identifier which will henceforth be treated as a non-terminal identifier; if it is a place identifier the error ="place identifier illegal"= is reported.
</p>

<p>
Factors beginning <code>SET</code>, <code>EMPTY</code>, <code>ATLEAST</code> or <code>ATMOST</code> must be followed by an identifier that has been previously declared to be a place; otherwise the error ="place identifier expected"= is reported.
</p>

<p>
The Netver system has a number of inbuilt constraints concerning the sizes of various tables.  This affects the number of identifiers which can be declared, the size of the code for transitions and paths, the number of places and logical variables which the system can handle at run time, and the product of the number of places and the number of savesets.  Since no final decisions have been made about the sizes of these tables, it would be premature to document them in this preliminary version.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Semantics</h2>
<div class="outline-text-2" id="text-4">
<p>
In the following,
</p>
<ul class="org-ul">
<li><code>pe</code>, <code>pe1</code> and <code>pe2</code> are any path expressions,
</li>
<li><code>n</code> is any natural number,
</li>
<li><code>Pid</code> is any place identifier,
</li>
<li><code>Tid</code> is any transition identifier,
</li>
<li><code>Nid</code> is any non-terminal identifier,
</li>
<li><code>Lid</code> is any logical identifier.
</li>
</ul>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Control primitives</h3>
<div class="outline-text-3" id="text-4-1">
<p>
The following are the primitives for control; they are independent of the backtracking mechanism.
</p>

<ol class="org-ol">
<li><code>ABORT</code> Stops execution of this path; prepares to read another path (if any) or net (if any).
</li>
<li><code>QUIT</code> Stops execution altogether; exits to command level.
</li>
<li><code>Nid</code> If a non-terminal <code>Nid</code> has been declared by a production of the form <code>Nid ::\equal pe</code>, then a call of <code>Nid</code> is equivalent to <code>pe</code>. Recursion is permitted, though left recursion is possible only as the last disjunct of a disjunction.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Mode selection</h3>
<div class="outline-text-3" id="text-4-2">
<p>
The three modes are selected by unary operators:
</p>

<ul class="org-ul">
<li><code>EXECUTE  pe</code> Attempts <code>pe</code> in execution mode. This is the default mode.
</li>
<li><code>VERIFY  pe</code> Attempts <code>pe</code> in verification mode, with the goal set to <code>true</code>.
</li>
<li><code>POSSIBLY  pe</code> Attempts <code>pe</code> in possibility mode, with the goal set to <code>true</code>.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Primitives from regular algebra</h3>
<div class="outline-text-3" id="text-4-3">
<p>
The first few concepts are entirely general; they belong to any language with programmed backtracking, and they do not involve anything specific to nets.  The concepts are independent of the current mode.
</p>

<p>
&lt;OL&gt;
&lt;LI&gt; =SKIP          = &lt;BR&gt;
Does nothing. Always succeeds.
&lt;LI&gt; =FAIL          = &lt;BR&gt;
Does nothing. Never succeeds.
&lt;LI&gt; =pe1  pe2          = &lt;BR&gt;
The composition of two path expressions causes the first
to be attempted, and if that succeeds, causes the second
to be attempted.
Succeeds if both succeed in that order.
&lt;LI&gt; =pe1  |  pe2          = &lt;BR&gt;
The alternation of two path expressions causes the first
to be attempted, and on backtracking causes the second
to be attempted.
&lt;LI&gt; <code>TIMES  n  pe          = &lt;BR&gt;
The n-th power of =pe</code>.
Equivalent to
<code>pe pe &#x2026; pe</code> (n times).
&lt;LI&gt; <code>REP  pe          = &lt;BR&gt;
The alternation of all powers of =pe</code>.
Equivalent to
<code>SKIP | pe | pe pe | pe pe pe | &#x2026;</code>
&lt;LI&gt; <code>POS  pe          = &lt;BR&gt;
The alternation of all positive powers of =pe</code>.
Equivalent to <code>pe | pe pe | pe pe pe | pe pe pe pe | &#x2026;</code>.
&lt;LI&gt; <code>OPT  pe          = &lt;BR&gt;
The alternation of the first two powers of =pe</code>.
Equivalent to <code>SKIP | pe</code>.
&lt;/OL&gt;
</p>

<p>
The next few primitives specifically rely on the ordering of alternands.  Hence for path expressions containing these primitives the commutativity and idempotency of alternation do not hold.
</p>

<p>
&lt;OL&gt;
&lt;LI&gt; <code>PATHNUM  n          = &lt;BR&gt;
Succeeds if the current path is the =n</code>-th,
otherwise fails.
Every path that is completed increments a counter,
paths that fail before completion are not counted.
&lt;LI&gt; <code>MAXPATHS  n          = &lt;BR&gt;
Sets the maximum number of paths to be attempted to =n</code>.
When this maximum is reached,
everything fails
and backtracking occurs up to the current point.
Always succeeds, undone on backtracking.
&lt;LI&gt; =SHOWTOTAL          = &lt;BR&gt;
Sets a global switch; if this switch has been set,
then at the end of the execution the total
number of successful paths will be printed.
&lt;/OL&gt;
</p>

<p>
The remaining primitives in this section deal specifically with backtracking execution of paths.
</p>

<p>
&lt;OL&gt;
&lt;LI&gt; =FENCE          = &lt;BR&gt;
When occurring in a disjunct of a disjunction,
its execution causes a flag to be set which
prevents any later disjunct from being attempted.
Always succeeds; the setting of the flag is not undone on backtracking.
&lt;LI&gt; <code>NEWSCOPE  pe          = &lt;BR&gt;
Declares a local scope for =FENCE</code>.
Succeeds if <code>pe</code> succeeds.
It works by creating a new flag for <code>FENCE</code>;
upon backtracking the old flag is restored.
&lt;/OL&gt;
</p>

<p>
Note that these primitives were from regular algebra only &#x2014; there were no events, no firings, no places, nothing to do with nets.
</p>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> Primitives from Boolean algebra</h3>
<div class="outline-text-3" id="text-4-4">
<p>
The following concepts are dependent on the current mode.  In execution mode they are independent of the current goal; in the other modes they are only dependent on the goal.
</p>

<p>
&lt;OL&gt;
&lt;LI&gt; =TRUE          = &lt;BR&gt;
In execution mode, always succeeds.
In the other modes, succeeds if the goal is <code>true</code>.
&lt;LI&gt; =FALSE          = &lt;BR&gt;
In execution mode, always fails.
In the other modes, succeeds if the goal is <code>false</code>.
&lt;LI&gt; <code>Lid          = &lt;BR&gt;
In execution mode, attempts to make the logical variable =Lid</code>
true.
In the other modes, attempts to give <code>Lid</code>
the value of the current goal.
&lt;LI&gt; <code>pe1  AND  pe2          = &lt;BR&gt;
In execution mode, equivalent to the composition =pe1  pe2</code>.
In the other modes, attempts to make the
conjunction of the two expressions true or false,
depending on the current goal.
&lt;LI&gt; <code>pe1  OR  pe2          = &lt;BR&gt;
In execution mode, equivalent to the alternation =pe1 | pe2</code>.
In the other modes, attempts to make the
disjunction of the two expressions true or false,
depending on the current goal.
&lt;LI&gt; <code>NOT  pe          = &lt;BR&gt;
In execution mode, attempts to execute =pe</code>;
if that fails, it succeeds, and vice versa
(similar to Prolog's <code>not</code>).
In the other modes, attempts <code>pe</code> with the negation of the current goal
(a real logical <code>not</code>).
&lt;LI&gt; <code>pe1  IMP  pe2          = &lt;BR&gt;
Equivalent to =NOT pe1  OR  pe2</code>.
&lt;LI&gt; <code>pe1  IFF  pe2          = &lt;BR&gt;
Equivalent to =(pe1 IMP pe2) AND (pe2 IMP pe1)</code>.
&lt;/OL&gt;
</p>

<p>
There are no primitives specific to Boolean algebra which rely on the ordering of disjuncts, other than those already described in the previous section.
</p>

<p>
There appears to be very little in the literature on the relationship between Boolean algebra and regular algebra.
</p>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> Discrete event primitives</h3>
<div class="outline-text-3" id="text-4-5">
<p>
The next primitives are applicable to any system in which there are discrete events (as opposed to continuous gradual changes).  For nets, an event is the firing of a transition.  The concepts do not presuppose an accessible state.
</p>

<p>
&lt;OL&gt;
&lt;LI&gt; <code>Tid          = &lt;BR&gt;
In execution mode, attempts to fire transition =Tid</code>.
The attempt will succeed if
</p>
<ol class="org-ol">
<li>at each input place there are enough tokens to be destroyed, and
</li>
<li>at each output place there are enough vacancies for tokens to be created,
</li>
</ol>
<p>
and
</p>
<ol class="org-ol">
<li>if there are action paths, the paths succeed.
</li>
</ol>
<p>
The destruction and creation of tokens follows the order of
the declaration of the arcs.
The effects of the firing will be undone on backtracking.
In verification mode, attempts to create a non-empty
intersection of the current hypermarkings of the places
with those markings that would enable the transition to fire;
but it does not fire the transition. Undone on backtracking.
In possibility mode, tests whether there is a non-empty
intersection of the current hypermarkings of the places
with those markings that would enable the transition to fire.
&lt;LI&gt; =NET          = &lt;BR&gt;
Equivalent to the disjunction of all the transitions.
Thus if a net has transitions <code>a</code> <code>b</code> <code>c</code>,
which have been declared in that order,
then <code>NET</code> means the same as <code>a | b | c</code>.
&lt;LI&gt; =LEN  n          = &lt;BR&gt;
Equivalent to
<code>TIMES n NET</code>.
&lt;LI&gt; =DEADLOCK          = &lt;BR&gt;
Attempts to find a marking which does not allow any transitions
to fire.
Equivalent to <code>VERIFY NOT NET</code>.
Thus if a net has transitions <code>a</code> <code>b</code> <code>c</code>,
which have been declared in that order,
then  <code>DEADLOCK</code> means the same as <code>VERIFY NOT (a OR b OR c)</code>.
May produce zero or one or several solutions.
&lt;LI&gt; =UNREACHABLE          = &lt;BR&gt;
Attempts to find a marking which cannot be the
effect of any transition firings (opposite of <code>DEADLOCK</code>).
May produce zero or one or several solutions.
&lt;/OL&gt;
</p>

<p>
The next few primitives specifically rely on the fact that a path has a beginning, and hence that every event has an ordinal position.  (Note that this need not be true of actual systems, which might have been running forever.)
</p>

<p>
&lt;OL&gt;
&lt;LI&gt; <code>POSITION  n          = &lt;BR&gt;
Succeeds if exactly =n</code> transitions have been fired,
otherwise fails.
&lt;LI&gt; =TAB  n          = &lt;BR&gt;
Attempts to fire as many transitions as are needed to make
the path contain exactly <code>n</code> transitions.
&lt;LI&gt; <code>MAXLENGTH  n          = &lt;BR&gt;
Sets the maximum pathlength to =n</code>.
If the limit has been reached, any attempt to fire a transition
will fail.
Always succeeds,
undone on backtracking.
Normally used only at the beginning of a path expression.
&lt;/OL&gt;
</p>

<p>
The last primitive of this section deal with output of the path for inspection by the system designer.  Note that the designer has adequate control over what will be printed, and does not have to see paths that are deemed irrelevant.
</p>

<p>
&lt;OL&gt;
&lt;LI&gt; =SHOW<sub>PATH</sub>          = &lt;BR&gt;
Causes the path to be printed.
As many transition identifiers as can be fitted onto a line
of 60 characters will be printed;
as many such lines as necessary are printed to complete the path.
The printout is preceded by <code>path n:</code>, where n is the
ordinal number of the path.
Always succeeds.
&lt;/OL&gt;
</p>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> State primitives</h3>
<div class="outline-text-3" id="text-4-6">
<p>
The next few primitives are applicable to any system in which there is a global state which is accessible to inspection and modification.  It is possible to save the current state, to restore the state to what it was when saved, and to compare the current state with what it was when saved.  In this prototype verifier, saved states are referenced by a small number (n = 1,2..).  (In a more mature version it might be preferred to use identifiers.)  The total number of different states that can be saved depends on the number of places in the net, and on a system dependent constant.  As yet there is no check for n out of bounds.
</p>

<p>
&lt;OL&gt;
&lt;LI&gt; <code>SAVE  n          = &lt;BR&gt;
Saves the current state of the net in a save-state numbered =n</code>.
Always succeeds, is not undone on backtracking.
&lt;LI&gt; <code>RESTORE  n          = &lt;BR&gt;
Restores the current state to what it was when saved in save-state =n</code>.
Always succeeds, is not undone on backtracking.
&lt;LI&gt; <code>SAMESTATE  n          = &lt;BR&gt;
Compares the current state with the one saved in save-state =n</code>.
Succeeds if the two are identical.
&lt;/OL&gt;
</p>

<p>
In systems in which the state is a set of states of a simulated system, a few simple set theoretic concepts are applicable:
</p>

<p>
&lt;OL&gt;
&lt;LI&gt; =NEWSTATE          = &lt;BR&gt;
Makes the current state set universal.
Always succeeds, the effects are not undone on backtracking.
&lt;LI&gt; <code>SUBSTATE n          = &lt;BR&gt;
Succeeds if the current state set is a subset of save-set =n</code>.
&lt;LI&gt; <code>SUPERSTATE n          = &lt;BR&gt;
Succeeds if the current state set is a superset of save-set =n</code>.
&lt;/OL&gt;
</p>
</div>
</div>
<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> Place primitives</h3>
<div class="outline-text-3" id="text-4-7">
<p>
In a net the state is essentially a record of all the places; only the last few concepts make explicit use of this.
</p>

<p>
&lt;OL&gt;
&lt;LI&gt; <code>SET  Pid  n1  n2  ..          = &lt;BR&gt;
Attempts to intersect the current hypermarking of place =Pid</code>
with the disjunction of markings given by the numbers.
Normally used only at the beginning of a path expression.
&lt;LI&gt; <code>ATLEAST Pid n          = &lt;BR&gt;
Succeeds if place =Pid</code> contains at least <code>n</code> tokens.
&lt;LI&gt; <code>ATMOST Pid n          = &lt;BR&gt;
Succeeds if place =Pid</code> contains at most <code>n</code> tokens.
&lt;LI&gt; <code>EMPTY Pid          = &lt;BR&gt;
Succeeds if place =Pid</code> is empty; equivalent to <code>ATMOST Pid 0</code>.
&lt;LI&gt; =SHOW<sub>MARKINGS</sub>          = &lt;BR&gt;
Causes the markings of the places to be printed,
always succeeds.
For each place whose current hypermarking is non-trivial,
one line is printed containing the identifier which names the place,
followed by one or more numerals denoting its current (hyper)marking.
If the current (hyper)marking contains no information
about the place, no line is printed.
For the purposes of this command,
<code>LOGICAL</code> variables are treated just like places,
except that their values are written as Booleans.
&lt;/OL&gt;

</p>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Examples</h2>
<div class="outline-text-2" id="text-5">
<p>
The following examples have been chosen to be brief.  They consist of echoed input to Netver and output from Netver.  Lines with a line number are echoed input, the line number is supplied by Netver; lines without a line number are output from Netver.  All examples are from a short principal input file and two longer subsidiary files that were included.
</p>

<pre class="example">
   1    %LISTING 1
   2    (*  BEGIN OF DEMONSTRATION FILE FOR NETVER *)
   3
   4    %SET A = 1 (* PRELIMINARIES *)
   5    %SET B = 1 (* SEVERAL NETS *)
   6
   7    %IF A %INCLUDE 45PRELIM.NV
   1    (* BEGIN OF PRELIMINARY DEMONSTRATIONS *)
   2
   3    (* PATH EXPRESSIONS *)
   4
   5    PATH
   6        (SKIP | SKIP)
   7        (FAIL | SKIP | SKIP SKIP FAIL)
   8        (SKIP | FAIL | SKIP)
   9        SHOW_PATH   (* expecting four (empty) paths *);
        path 1:
        path 2:
        path 3:
        path 4:
  10    PATH
  11        VERIFY(
  12          (TRUE OR FALSE) AND
  13          NOT(FALSE OR FALSE) AND
  14          (TRUE OR TRUE))
  15        SHOW_PATH   (* expecting two (empty) paths *);
        path 1:
        path 2:
  16    PATH
  17        (SKIP SKIP FAIL | SKIP FENCE FAIL | SKIP)
  18        SHOW_PATH   (* expecting no paths at all *).
  19
  20    (* DECLARATIONS *)
  21
  22    PRODUCTION
  23        (* Note: uses before declarations are permitted *)
  24        one  ::=  (f | s | f) (f | s);
  25        sixteen  ::=  four four;
  26        four  ::=  (s | s | s | s);
  27        s  ::=  SKIP;
  28        f  ::=  FAIL;
  29        show  ::= SHOW_PATH;
  30    PATH
  31        (one | one) show (* expecting two (empty) paths *);
        path 1:
        path 2:
  32    PATH
  33        SHOW_TOTAL  sixteen sixteen (* expecting 256 *).
        total number of paths: 256
  34
  35    (* LOGICAL variables *)
  36
  37    LOGICAL p,q,r,s;
  38    PATH                            (* faulty dilemma *)
  39        SHOW_TOTAL
  40        VERIFY NOT                  (*   try to falsify *)
  41            ( ( (p OR  q) AND       (*       premise 1 *)
  42                (p IMP r) AND       (*       premise 2 *)
  43                (q IMP s) )         (*       premise 3 *)
  44            IMP (r AND s) )         (*       conclusion *)
  45        SHOW_MARKINGS               (* expecting two solutions *);
        mark 1:
                p TRUE
                q FALSE
                r TRUE
                s FALSE
        mark 2:
                p FALSE
                q TRUE
                r FALSE
                s TRUE
        total number of paths: 2
  46    PATH                            (* correct dilemma *)
  47        SHOW_TOTAL
  48        VERIFY NOT                  (*   try to falsify *)
  49            ( ( (p OR  q) AND       (*       premise 1 *)
  50                (p IMP r) AND       (*       premise 2 *)
  51                (q IMP s) )         (*       premise 3 *)
  52            IMP (r OR s) )          (*       conclusion *)
  53        SHOW_MARKINGS               (* expecting no solutions *)
  54                                    (* since this is valid *);
        total number of paths: 0
  55    PATH
  56        SHOW_TOTAL          (* just show the number *)
  57        (SKIP | SKIP)
  58        (SKIP | SKIP)
  59        (SKIP | SKIP)       (* total of 8 expected *);
        total number of paths: 8
  60    PATH                    (* same pattern, but using LOGICALs *)
  61        SHOW_TOTAL          (* to block some of the 8 paths *)
  62        (SKIP  VERIFY p      |  SKIP  VERIFY NOT q)
  63        (SKIP  VERIFY NOT p  |  SKIP  VERIFY r)
  64        (SKIP  VERIFY NOT r  |  SKIP  VERIFY (r AND p)).
        total number of paths: 3
  65
  66    (* TRANSITIONS *)
  67
  68    TRANSITION
  69      alpha, beta, gamma;
  70    PATH
  71      alpha  NET  SHOW_PATH    (* expecting 3 paths *).
        path 1:
        alpha alpha
        path 2:
        alpha beta
        path 3:
        alpha gamma
  72
  73    (* LONG PATH WITH SHORT NAMES *)
  74
  75    TRANSITION
  76        g0, c, d, e, f, g;
  77    PRODUCTION
  78        theme1 ::= e e f g g f e d c c d e;
  79        theme2 ::= e d d;
  80        theme3 ::= d c c;
  81        theme4 ::= d d e c d e f e c d e f e d c d g0;
  82        beethoven ::=
  83          theme1 theme2 theme1 theme3 theme4 theme1 theme3;
  84        plagiarist ::=
  85          theme3 theme2 theme1 theme4 theme1;
  86    PATH
  87        (beethoven | plagiarist)  SHOW_PATH.
        path 1:
        e e f g g f e d c c d e e d d e e f g g f e d c c d e d c c
        d d e c d e f e c d e f e d c d g0 e e f g g f e d c c d e d
        c c
        path 2:
        d c c e d d e e f g g f e d c c d e d d e c d e f e c d e f
        e d c d g0 e e f g g f e d c c d e
  88
  89    (* LIMITING OUTPUT *)
  90
  91    TRANSITION
  92        alpha, beta, gamma, delta;
  93    PATH
  94        SHOW_TOTAL                  (* total number of paths *)
  95        LEN 3                       (* fire any 3 transitions *)
  96        NEWSCOPE
  97          ( PATHNUM 42  SHOW_PATH  FENCE    (* show 42nd path *)
  98            | SKIP )                        (* but not others *).
        path 42:
        gamma gamma beta
        total number of paths: 64
  99
 100    (* PLACES to ensure every transition fires at most once *)
 101
 102    PLACE
 103        a, b, g, d, e, z;
 104    TRANSITION
 105        alpha INARC a;      beta INARC b;           gamma INARC g;
 106        delta INARC d;      epsilon INARC e;        zeta INARC z;
 107    PATH
 108        SHOW_TOTAL  LEN 6
 109        NEWSCOPE
 110         (PATHNUM 42  SHOW_PATH  SHOW_MARKINGS  FENCE  |  SKIP).
        path 42:
        alpha gamma epsilon zeta delta beta
        mark 42:
                a 0
                b 0
                g 0
                d 0
                e 0
                z 0
        total number of paths: 720
 111
 112    (* ONE PRODUCER - TWO CONSUMERS *)
 113
 114    PLACE
 115        buffer, producing, consuming1, consuming2;
 116    TRANSITION
 117        produce     OUTARC producing;
 118        deposit     INARC producing OUTARC buffer;
 119        remove1     INARC buffer OUTARC consuming1;
 120        consume1    INARC consuming1;
 121        remove2     INARC buffer OUTARC consuming2;
 122        consume2    INARC consuming2;
 123    PRODUCTION
 124        initialise ::=
 125            SET buffer 0  SET producing 0
 126            SET consuming1 0  SET consuming2 0;
 127    PATH
 128        SHOW_TOTAL DEADLOCK SHOW_MARKINGS
 129        (* no deadlock expected *);
        total number of paths: 0
 130    PATH
 131        SHOW_TOTAL UNREACHABLE SHOW_MARKINGS
 132        (* no unreachable marking expected *);
        total number of paths: 0
 133    PATH (* find cycles from the given initialisation *)
 134        initialise  MAXLENGTH 7
 135        SAVE 1  POS NET  SAMESTATE 1  SHOW_PATH.
        path 1:
        produce deposit remove1 consume1
        path 2:
        produce deposit remove2 consume2
 136
 137    (* END OF PRELIMINARY DEMONSTRATIONS *)
   8
   9    %IF B %INCLUDE 45NETNET.NV
   1    (* BEGIN NET DEMONSTRATIONS *)
   2
   3    (* BARBER SHOP -
   4            adapted from a graphical presentation in
   5       Filman, R.E. and Friedman, D.P., 1984,
   6            Coordinated Computing, McGraw-Hill, pp 107-109. *)
   7    PLACE
   8        waiting, exiting 12;        (* size of waiting room *)
   9        idle 7;                     (* size of barbers' tea room *)
  10        cutting 5;                  (* number of chairs *)
  11    TRANSITION
  12        new_customer        OUTARC waiting;
  13        start_cutting       INARC waiting, idle; OUTARC cutting;
  14        finish_cutting      INARC cutting; OUTARC idle, exiting;
  15        leave_shop          INARC exiting;
  16    PATH
  17        DEADLOCK SHOW_MARKINGS
  18        (* too few  or too many barbers : *);
        mark 1:
                waiting 12
                exiting 0
                idle 0
                cutting 0
        mark 2:
                waiting 12
                exiting 0
                idle 7
                cutting 5
  19    PATH    (* find just one cycle *)
  20        SET waiting 0  SET idle 7  SET cutting 0  SET exiting 0
  21        MAXLENGTH 8
  22        SAVE 1  POS NET  SAMESTATE 1  SHOW_PATH  ABORT.
        path 1:
        new_customer new_customer start_cutting start_cutting
        finish_cutting finish_cutting leave_shop leave_shop
  23
  24    (* MUTUAL EXCLUSION -
  25            adapted from a graphical presentation in
  26       Filman, R.E. and Friedman, D.P., 1984,
  27            Coordinated Computing, McGraw-Hill, pp 110-111. *)
  28    PLACE
  29      concur1,concur2,concur3, none_critical,
  30      critical1,critical2,critical3;
  31    TRANSITION
  32      enter1 INARC concur1,none_critical; OUTARC critical1;
  33      leave1 INARC critical1; OUTARC concur1,none_critical;
  34      enter2 INARC concur2,none_critical; OUTARC critical2;
  35      leave2 INARC critical2; OUTARC concur2,none_critical;
  36      enter3 INARC concur3,none_critical; OUTARC critical3;
  37      leave3 INARC critical3; OUTARC concur3,none_critical;
  38    PATH
  39      SHOW_TOTAL  DEADLOCK
  40      (* too many to look at, just show two: *)
  41      OPT ( (PATHNUM 42 | PATHNUM 73) SHOW_MARKINGS FAIL )
  42      (* the FAIL stops two paths being counted twice in total *);
        mark 42:
                concur1 0
                concur3 0
                none_critical 1
                critical2 1
                critical3 0
        mark 73:
                concur1 1
                concur2 1
                concur3 1
                none_critical 0
                critical3 1
        total number of paths: 120
  43
  44    PATH
  45      SET concur1 1  SET concur2 1  SET concur3 1
  46      SET none_critical 1
  47      SET critical1 0  SET critical2 0  SET critical3 0
  48      MAXLENGTH 10  MAXPATHS 3  TIMES 6 NET  SHOW_PATH.
        path 1:
        enter1 leave1 enter1 leave1 enter1 leave1
        path 2:
        enter1 leave1 enter1 leave1 enter2 leave2
        path 3:
        enter1 leave1 enter1 leave1 enter3 leave3
  49
  50    (* READERS(3) AND WRITERS(1) -
  51            adapted from a graphical presentation in
  52       Filman, R.E. and Friedman, D.P., 1984,
  53            Coordinated Computing, McGraw-Hill, pp 113-114. *)
  54
  55    (* first, the net itself: *)
  56
  57    PLACE
  58        write, not_write : 1;
  59        free_read : 3;
  60        read1, not_read1 : 1;
  61        read2, not_read2 : 1;
  62        read3, not_read3 : 1;
  63    TRANSITION
  64        start_write
  65          INARC not_write INARC free_read 3; OUTARC write;
  66        stop_write
  67          INARC write; OUTARC not_write OUTARC free_read 3;
  68        start_read1
  69          INARC not_read1,free_read; OUTARC read1;
  70        start_read2
  71          INARC not_read2,free_read; OUTARC read2;
  72        start_read3
  73          INARC not_read3,free_read; OUTARC read3;
  74        stop_read1
  75          INARC read1; OUTARC not_read1,free_read;
  76        stop_read2
  77          INARC read2; OUTARC not_read2,free_read;
  78        stop_read3
  79          INARC read3; OUTARC not_read3,free_read;
  80
  81    (* second, some tools for analysing the net: *)
  82
  83    LOGICAL
  84        do_read1, do_read2, do_read3;
  85    PRODUCTION
  86        show  ::=
  87            SHOW_PATH  SHOW_MARKINGS;
  88        start_any_read  ::=
  89            start_read1 | start_read2 | start_read3;
  90        stop_any_read  ::=
  91            stop_read1 | stop_read2 | stop_read3;
  92        initialise ::=
  93            SET not_read1 1  SET not_read2 1  SET not_read3 1
  94            SET read1 0  SET read2 0  SET read3 0
  95            SET not_write 1  SET write 0;
  96        v1  ::=  VERIFY do_read1;    f1  ::=  VERIFY NOT do_read1;
  97        v2  ::=  VERIFY do_read2;    f2  ::=  VERIFY NOT do_read2;
  98        v3  ::=  VERIFY do_read3;    f3  ::=  VERIFY NOT do_read3;
  99    PATH
 100        SHOW_TOTAL  initialise  LEN 4;
        total number of paths: 94
 101    PATH
 102        SHOW_TOTAL  initialise  LEN 4  OPT(PATHNUM 42 show ABORT);
        path 42:
        start_read2 start_read1 start_read3 stop_read3
        mark 42:
                write 0
                not_write 1
                free_read 1
                read1 1
                not_read1 0
                read2 1
                not_read2 0
                read3 0
                not_read3 1
        total number of paths: 41
 103    PATH
 104        initialise   MAXPATHS 6   LEN 4   SHOW_PATH;
        path 1:
        start_write stop_write start_write stop_write
        path 2:
        start_write stop_write start_read1 start_read2
        path 3:
        start_write stop_write start_read1 start_read3
        path 4:
        start_write stop_write start_read1 stop_read1
        path 5:
        start_write stop_write start_read2 start_read1
        path 6:
        start_write stop_write start_read2 start_read3
 105    PATH
 106        (* NOTE: no initialisation *)
 107        SHOW_TOTAL DEADLOCK (* far too many to print out *);
        total number of paths: 504
 108    PATH
 109        SHOW_TOTAL start_write start_any_read show
 110        (* none, we hope ! *);
        total number of paths: 0
 111    PATH
 112        SHOW_TOTAL start_any_read start_write show
 113        (* none, we hope ! *);
        total number of paths: 0
 114    PATH
 115        initialise
 116        ( start_read1 v1 f2 f3 |
 117          start_read2 f1 v2 f3 |
 118          start_read3 f1 f2 v3 )
 119        NET  start_write   (v1 | v2 | v3 NET)  show.
        path 1:
        start_read1 stop_read1 start_write
        mark 1:
                write 1
                not_write 0
                free_read 0
                read1 0
                not_read1 1
                read2 0
                not_read2 1
                read3 0
                not_read3 1
                do_read1 TRUE
                do_read2 FALSE
                do_read3 FALSE
        path 2:
        start_read2 stop_read2 start_write
        mark 2:
                write 1
                not_write 0
                free_read 0
                read1 0
                not_read1 1
                read2 0
                not_read2 1
                read3 0
                not_read3 1
                do_read1 FALSE
                do_read2 TRUE
                do_read3 FALSE
        path 3:
        start_read3 stop_read3 start_write stop_write
        mark 3:
                write 0
                not_write 1
                free_read 3
                read1 0
                not_read1 1
                read2 0
                not_read2 1
                read3 0
                not_read3 1
                do_read1 FALSE
                do_read2 FALSE
                do_read3 TRUE
 120
 121    (* END NET DEMONSTRATIONS *)
  10
  11    (*  END OF DEMONSTRATION FILE FOR NETVER *)
  12    QUIT
4920 milliseconds CPU
</pre>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Implementation</h2>
<div class="outline-text-2" id="text-6">
<p>
Like most other programs in this book, the system consists of a small compiler which translates the source code to an internal form, and an interpreter for executing the internal form.  Only a cursory description will be given.
</p>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> <i>Compilation</i>:</h2>
<div class="outline-text-2" id="text-7">
<p>
The compiler uses recursive descent in an entirely conventional manner.  It consists of a scanner, a parser and a codegenerator.
</p>

<p>
The scanner, taken from the utilities in Chapter 17, handles numbers and reserved words in an obvious manner.  Identifiers are handled separately, in particular by a procedure which looks them up in the symbol table.  Then it reports to the parser whether the identifier has been declared already or whether it is new.
</p>

<p>
The parser is modelled on the grammar; it consists of several parsing procedures, one for each non-terminal.  The bodies of the parsing procedure contain calls to the scanner and to a code generator.
</p>

<p>
The very simple code generator produces binary trees of nodes containing an operator field and a few other fields.  The latter fields are variously integer pointers to other nodes, or they are data integers or sets of markings.  In particular, the tree for a transition consists of <code>AND</code>-nodes joining the nodes for the arcs; and the tree for the entire NET consists of <code>OR</code>-nodes joining the nodes of all transitions.
</p>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> <i>Interpretation</i>:</h2>
<div class="outline-text-2" id="text-8">
<p>
The internal form of the code is then passed to an interpreter.  The interpreter consists of a recursive procedure which takes a node as a parameter; a case statement then dispatches on the operator field of the node.  To implement backtracking, the recursive procedure has another parameter which is a (parameterless) procedure.  This other procedure acts as a continuation which will be called just in case the interpretation of the current node succeeds &#x2014; otherwise it is ignored.
</p>

<p>
In general, to produce some atomic effect and to undo the effect on backtracking, the interpreter uses code of the following form:
</p>

<pre class="example">
CASE  operator(node)  OF
        ...
        some-effect :
                IF producing the effect is possible THEN
                        produce the effect;
                        call the continuation;
                        undo the effect
        ...
</pre>

<p>
A typical example is the node for an arc from or to a place.  The hypermarking of a place is represented by a set of small integers, the presence or absence of an integer represents a marking.  The node for, say, an input arc contains one field which is a reference to the place from which the arc comes, and another field which is a number specifying how many tokens are to be removed.  (For efficiency, there is another field representing the possible markings of the place after the firing of the transition.)  For such a node the interpreter uses the following code:
</p>

<pre class="example">
input-arc:
        IF the required number of tokens can be removed THEN
                save the current hypermarking of the place
                construct the new hypermarking
                call the continuation
                restore the saved hypermarking of the place
</pre>

<p>
The interpreter code for non-atomic nodes typically call the interpreter recursively, passing as continuation parameters local procedures.  Typically the local procedure will either call or pass as a parameter the original continuation.  So most of these local procedures are never called directly, but only as continuations.  When they are called in this indirect manner, they perform some work in the environment of their definition including a call to the original continuation.
</p>

<p>
The initial call of the interpreter uses as one actual parameter the tree for the path expression that was last read.  The other actual parameter is a global procedure which almost does nothing at all &#x2014; it merely increments the counter for the number of successful paths.

</p>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> The program</h2>
<div class="outline-text-2" id="text-9">
<p>
The following is the source:
</p>

<div class="org-src-container">

<pre class="src src-pascal"><span style="color: #00ffff;">PROGRAM</span> <span style="color: #ffffff; font-weight: bold;">netver</span>(input,output);

LABEL 10,90,99;

<span style="color: #ff00ff;">CONST</span>
    errormark = <span style="color: #00ff00;">'%NV'</span>;
    list_filename = <span style="color: #00ff00;">'45netver.lst'</span>;
    reslength = 16; emptyres = <span style="color: #00ff00;">'                '</span>;
    maxrestab = 70;
    identlength = 16; emptyident = <span style="color: #00ff00;">'                '</span>;
    maxstdidenttab = 1; <span style="color: #66f;">(* </span><span style="color: #66f;">dummy *)</span>

<span style="color: #ff00ff;">TYPE</span>
    symbol =
        (place_id,transition_id,nonterminal_id,logical_id,
         new_id,identifier,
        <span style="color: #66f;">(* </span><span style="color: #66f;">no more idents after here *)</span>
         true_op,false_op,
         net_op,skip_op,fail_op,abort_op,quit_op,
         deadlock_op,unreachable_op,fence_op,set_op,showtotpathnum_op,
         empty_op,atleast_op,atmost_op,newstate_op,
         show_path_op,show_markings_op,arc_op,trans_op,nonterm_op,
         logical_op,
         execute_op,verify_op,possibly_op,
         opt_op,pos_op,rep_op,timmes_op,not_op,newscope_op,
         len_op,maxlength_op,maxpaths_op,position_op,tab_op,
         pathnum_op,
         save_op,restore_op,samestate_op,substate_op,superstate_op,
         leftparenthesis,
        <span style="color: #66f;">(* </span><span style="color: #66f;">no more  facbegsys after here *)</span>
         and_op, <span style="color: #66f;">(* </span><span style="color: #66f;">must be here, see TERM *)</span>
         cat_op,or_op,imp_op,iff_op,alt_op,
         rightparenthesis_,
         comma_,period_,colon_,bnfarrow_,semicol_,queery_,
         end_,inarc_,outarc_,action_,
         path_,place_,production_,transition_,logical_,
        <span style="color: #66f;">(* </span><span style="color: #66f;">compulsory for scanutilities: *)</span>
         charconst,stringconst,numberconst,hyphen);
    standardident = (dummy);

%INCLUDE <span style="color: #00ff00;">'41SCANUT.PAS'</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">initialise</span>;
<span style="color: #ff00ff;">VAR</span> i : <span style="color: #ff00ff;">integer</span>;
<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">initialise *)</span>
iniscanner;
specials_repeat := [<span style="color: #00ff00;">':'</span>,<span style="color: #00ff00;">'='</span>];
erw(<span style="color: #00ff00;">')               '</span>,rightparenthesis_);
erw(<span style="color: #00ff00;">',               '</span>,comma_);
erw(<span style="color: #00ff00;">'.               '</span>,period_);
erw(<span style="color: #00ff00;">':               '</span>,colon_);
erw(<span style="color: #00ff00;">'::=             '</span>,bnfarrow_);
erw(<span style="color: #00ff00;">';               '</span>,semicol_);
erw(<span style="color: #00ff00;">'?               '</span>,queery_);
erw(<span style="color: #00ff00;">'ABORT           '</span>,abort_op);
erw(<span style="color: #00ff00;">'ACTION          '</span>,action_);
erw(<span style="color: #00ff00;">'ALT             '</span>,alt_op);
erw(<span style="color: #00ff00;">'AND             '</span>,and_op);
erw(<span style="color: #00ff00;">'ATLEAST         '</span>,atleast_op);
erw(<span style="color: #00ff00;">'ATMOST          '</span>,atmost_op);
erw(<span style="color: #00ff00;">'DEADLOCK        '</span>,deadlock_op);
erw(<span style="color: #00ff00;">'EMPTY           '</span>,empty_op);
erw(<span style="color: #00ff00;">'END             '</span>,end_);
erw(<span style="color: #00ff00;">'EXECUTE         '</span>,execute_op);
erw(<span style="color: #00ff00;">'FAIL            '</span>,fail_op);
erw(<span style="color: #00ff00;">'FALSE           '</span>,false_op);
erw(<span style="color: #00ff00;">'FENCE           '</span>,fence_op);
erw(<span style="color: #00ff00;">'IFF             '</span>,iff_op);
erw(<span style="color: #00ff00;">'IMP             '</span>,imp_op);
erw(<span style="color: #00ff00;">'INARC           '</span>,inarc_);
erw(<span style="color: #00ff00;">'LEN             '</span>,len_op);
erw(<span style="color: #00ff00;">'LOGICAL         '</span>,logical_);
erw(<span style="color: #00ff00;">'MAXLENGTH       '</span>,maxlength_op);
erw(<span style="color: #00ff00;">'MAXPATHS        '</span>,maxpaths_op);
erw(<span style="color: #00ff00;">'NET             '</span>,net_op);
erw(<span style="color: #00ff00;">'NEWSCOPE        '</span>,newscope_op);
erw(<span style="color: #00ff00;">'NEWSTATE        '</span>,newstate_op);
erw(<span style="color: #00ff00;">'NOT             '</span>,not_op);
erw(<span style="color: #00ff00;">'OPT             '</span>,opt_op);
erw(<span style="color: #00ff00;">'OR              '</span>,or_op);
erw(<span style="color: #00ff00;">'OUTARC          '</span>,outarc_);
erw(<span style="color: #00ff00;">'PATH            '</span>,path_);
erw(<span style="color: #00ff00;">'PATHNUM         '</span>,pathnum_op);
erw(<span style="color: #00ff00;">'PLACE           '</span>,place_);
erw(<span style="color: #00ff00;">'POS             '</span>,pos_op);
erw(<span style="color: #00ff00;">'POSITION        '</span>,position_op);
erw(<span style="color: #00ff00;">'POSSIBLY        '</span>,possibly_op);
erw(<span style="color: #00ff00;">'PRODUCTION      '</span>,production_);
erw(<span style="color: #00ff00;">'QUIT            '</span>,quit_op);
erw(<span style="color: #00ff00;">'REP             '</span>,rep_op);
erw(<span style="color: #00ff00;">'RESTORE         '</span>,restore_op);
erw(<span style="color: #00ff00;">'SAMESTATE       '</span>,samestate_op);
erw(<span style="color: #00ff00;">'SAVE            '</span>,save_op);
erw(<span style="color: #00ff00;">'SET             '</span>,set_op);
erw(<span style="color: #00ff00;">'SHOW_MARKINGS   '</span>,show_markings_op);
erw(<span style="color: #00ff00;">'SHOW_PATH       '</span>,show_path_op);
erw(<span style="color: #00ff00;">'SHOW_TOTAL      '</span>,showtotpathnum_op);
erw(<span style="color: #00ff00;">'SKIP            '</span>,skip_op);
erw(<span style="color: #00ff00;">'SUBSTATE        '</span>,substate_op);
erw(<span style="color: #00ff00;">'SUPERSTATE      '</span>,superstate_op);
erw(<span style="color: #00ff00;">'TAB             '</span>,tab_op);
erw(<span style="color: #00ff00;">'TIMES           '</span>,timmes_op);
erw(<span style="color: #00ff00;">'TRANSITION      '</span>,transition_);
erw(<span style="color: #00ff00;">'TRUE            '</span>,true_op);
erw(<span style="color: #00ff00;">'UNREACHABLE     '</span>,unreachable_op);
erw(<span style="color: #00ff00;">'VERIFY          '</span>,verify_op);
erw(<span style="color: #00ff00;">'|               '</span>,alt_op);
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">initialise *)</span>

<span style="color: #ff00ff;">CONST</span>
    interactive_usage = false;
    maxplaces = 50;
    maxsaves = 200;
    maxsymtab = 100;
    maxcode = 1000;
    maxpathlength = 100;
    maxcapacity = 31;
<span style="color: #ff00ff;">TYPE</span>
    operator = net_op .. or_op;
    markset = <span style="color: #ff00ff;">SET</span> <span style="color: #00ffff;">OF</span> 0 .. maxcapacity;
<span style="color: #ff00ff;">VAR</span>
    symtab : <span style="color: #ff00ff;">ARRAY</span> [0 .. maxsymtab] <span style="color: #00ffff;">OF</span> <span style="color: #66f;">(* </span><span style="color: #66f;">0 for sentinel *)</span>
        <span style="color: #ff00ff;">RECORD</span>
            alf : identalfa;
            obj : symbol;
            val : <span style="color: #ff00ff;">integer</span>
            <span style="color: #00ffff;">END</span>;
    lastsymtab,location : <span style="color: #ff00ff;">integer</span>;
    new_id_allowed : <span style="color: #ff00ff;">boolean</span>;
    code : <span style="color: #ff00ff;">ARRAY</span> [1 .. maxcode] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">RECORD</span>
                op : operator; left, right : <span style="color: #ff00ff;">integer</span>;
                arc_opset : markset;
                <span style="color: #00ffff;">END</span>;
    codeindex, headnode, last_block_code : <span style="color: #ff00ff;">integer</span>;
    place : <span style="color: #ff00ff;">ARRAY</span> [1 .. maxplaces] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">RECORD</span>
                symtab_ptr, capacity : <span style="color: #ff00ff;">integer</span>;
                pl_poss, pl_cur : markset
                <span style="color: #00ffff;">END</span>;
    lastplace : <span style="color: #ff00ff;">integer</span>;
    saves : <span style="color: #ff00ff;">ARRAY</span> [1..maxsaves] <span style="color: #00ffff;">OF</span> markset;
    path : <span style="color: #ff00ff;">ARRAY</span> [1..maxpathlength] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">integer</span>;
    pathlength,maxlength : <span style="color: #ff00ff;">integer</span>;
    pathnum,maxpaths : <span style="color: #ff00ff;">integer</span>;
    fenced,showtotpathnum : <span style="color: #ff00ff;">boolean</span>;
    mode : symbol; goal : <span style="color: #ff00ff;">boolean</span>;
    i,j : <span style="color: #ff00ff;">integer</span>;

<span style="color: #66f;">(* </span><span style="color: #66f;">- - - - -   U T I L I T I E S   - - - - - *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">lookup</span>;
<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">lookup *)</span>
symtab[0].alf := ident; location := lastsymtab;
<span style="color: #00ffff;">WHILE</span> symtab[location].alf &lt;&gt; ident <span style="color: #00ffff;">DO</span> location := location - 1;
<span style="color: #00ffff;">IF</span> location = 0 <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span>
    lastsymtab := lastsymtab + 1;
    <span style="color: #00ffff;">WITH</span> symtab[lastsymtab] <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">BEGIN</span> alf := ident; obj := new_id; val := 0 <span style="color: #00ffff;">END</span>;
    location := lastsymtab;
    <span style="color: #00ffff;">END</span>;
<span style="color: #00ffff;">WITH</span> symtab[location] <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">BEGIN</span> sym := obj; num := val <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">lookup *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">generate</span>(o : operator; x,y : <span style="color: #ff00ff;">integer</span>);
<span style="color: #00ffff;">BEGIN</span>
codeindex := codeindex + 1;
<span style="color: #00ffff;">WITH</span> code[codeindex] <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">BEGIN</span> op := o; left := x; right := y <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">generate *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">writenode</span>(n : <span style="color: #ff00ff;">integer</span>);
<span style="color: #00ffff;">BEGIN</span>
<span style="color: #00ffff;">WITH</span> code[n] <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">BEGIN</span>
    <span style="color: #00ffff;">IF</span> n = headnode
        <span style="color: #00ffff;">THEN</span> <span style="color: #00ffff;">write</span>(listing,<span style="color: #00ff00;">'***'</span>)
        <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">write</span>(listing,<span style="color: #00ff00;">'   '</span>);
    <span style="color: #00ffff;">write</span>(listing,n:4,<span style="color: #00ff00;">'  '</span>, op:16,<span style="color: #00ff00;">'  '</span>,left:6,right:6);
    <span style="color: #00ffff;">CASE</span> op <span style="color: #00ffff;">OF</span>
        arc_op :
            <span style="color: #00ffff;">BEGIN</span>
            <span style="color: #00ffff;">write</span>(listing,<span style="color: #00ff00;">'   '</span>);
            <span style="color: #00ffff;">FOR</span> j := 0 <span style="color: #00ffff;">TO</span> place[left].capacity <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">IF</span> j <span style="color: #00ffff;">IN</span> arc_opset <span style="color: #00ffff;">THEN</span> <span style="color: #00ffff;">write</span>(listing,j:0,<span style="color: #00ff00;">' '</span>)
            <span style="color: #00ffff;">END</span>;
        logical_op,trans_op,nonterm_op :
            <span style="color: #00ffff;">write</span>(listing,<span style="color: #00ff00;">'  '</span>,symtab[left].alf);
        <span style="color: #00ffff;">END</span>;
    writeln(listing)
    <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">writenode *)</span>

<span style="color: #66f;">(* </span><span style="color: #66f;">- - - - -   I N P U T  - - - - - *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">expression</span>;
<span style="color: #ff00ff;">VAR</span> left : <span style="color: #ff00ff;">integer</span>; oper : operator;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">term</span>;
    <span style="color: #ff00ff;">VAR</span> left : <span style="color: #ff00ff;">integer</span>; oper : operator;

        <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">factor</span>;
        <span style="color: #ff00ff;">VAR</span> oper : operator; n : <span style="color: #ff00ff;">integer</span>;
        <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">factor *)</span>
        <span style="color: #00ffff;">IF</span> sym = identifier <span style="color: #00ffff;">THEN</span> lookup;
        <span style="color: #00ffff;">CASE</span> sym <span style="color: #00ffff;">OF</span>
            new_id,nonterminal_id :
                <span style="color: #00ffff;">BEGIN</span>
                <span style="color: #00ffff;">IF</span> sym = new_id <span style="color: #00ffff;">THEN</span>
                    <span style="color: #00ffff;">BEGIN</span>
                    <span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">NOT</span> new_id_allowed <span style="color: #00ffff;">THEN</span>
                        point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'new identifier not allowed    '</span>);
                    symtab[location].obj := nonterminal_id;
                    <span style="color: #00ffff;">END</span>;
                generate(nonterm_op,location,0 <span style="color: #66f;">(* </span><span style="color: #66f;">fixed in BLOCK *)</span> );
                getsym
                <span style="color: #00ffff;">END</span>;
            transition_id :
                <span style="color: #00ffff;">BEGIN</span>
                generate(trans_op,location,num); getsym
                <span style="color: #00ffff;">END</span>;
            logical_id :
                <span style="color: #00ffff;">BEGIN</span>
                generate(logical_op,location,num); getsym
                <span style="color: #00ffff;">END</span>;
            net_op,skip_op,fail_op,abort_op,quit_op,
            true_op,false_op,
            deadlock_op,unreachable_op,fence_op,showtotpathnum_op,
            newstate_op,
            show_path_op,show_markings_op :
                <span style="color: #00ffff;">BEGIN</span>
                generate(sym,0,0); getsym
                <span style="color: #00ffff;">END</span>;
            execute_op,verify_op,possibly_op,newscope_op,
            not_op,opt_op,pos_op,rep_op :
                <span style="color: #00ffff;">BEGIN</span>
                oper := sym; getsym; factor;
                generate(oper,0,codeindex)
                <span style="color: #00ffff;">END</span>;
            timmes_op :
                <span style="color: #00ffff;">BEGIN</span>
                getsym;
                <span style="color: #00ffff;">IF</span> sym &lt;&gt; numberconst <span style="color: #00ffff;">THEN</span>
                    point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'number expected               '</span>);
                n := num; getsym; factor;
                generate(timmes_op,n,codeindex)
                <span style="color: #00ffff;">END</span>;
            save_op,restore_op,samestate_op,substate_op,superstate_op,
            len_op,maxlength_op,maxpaths_op,position_op,tab_op,
            pathnum_op :
                <span style="color: #00ffff;">BEGIN</span>
                oper := sym; getsym;
                <span style="color: #00ffff;">IF</span> sym &lt;&gt; numberconst <span style="color: #00ffff;">THEN</span>
                    point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'number expected               '</span>);
                generate(oper,num,0); getsym
                <span style="color: #00ffff;">END</span>;
            empty_op :
                <span style="color: #00ffff;">BEGIN</span>
                getsym;
                lookup;
                <span style="color: #00ffff;">IF</span> sym &lt;&gt; place_id <span style="color: #00ffff;">THEN</span>
                    point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'place identifier expected     '</span>);
                generate(empty_op,num,0); getsym
                <span style="color: #00ffff;">END</span>;
            atleast_op,atmost_op :
                <span style="color: #00ffff;">BEGIN</span>
                oper := sym; getsym;
                lookup;
                <span style="color: #00ffff;">IF</span> sym &lt;&gt; place_id <span style="color: #00ffff;">THEN</span>
                    point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'place identifier expected     '</span>);
                n := num; getsym;
                <span style="color: #00ffff;">IF</span> sym &lt;&gt; numberconst <span style="color: #00ffff;">THEN</span>
                    point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'number expected               '</span>);
                generate(oper,n,num); getsym
                <span style="color: #00ffff;">END</span>;
            set_op :
                <span style="color: #00ffff;">BEGIN</span>
                getsym;
                lookup;
                <span style="color: #00ffff;">IF</span> sym &lt;&gt; place_id <span style="color: #00ffff;">THEN</span>
                    point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'place identifier expected     '</span>);
                generate(set_op,num,0);
                code[codeindex].arc_opset := [];
                getsym;
                <span style="color: #00ffff;">WHILE</span> sym = numberconst <span style="color: #00ffff;">DO</span>
                    <span style="color: #00ffff;">BEGIN</span>
                    <span style="color: #00ffff;">WITH</span> code[codeindex] <span style="color: #00ffff;">DO</span>
                        arc_opset := arc_opset + [num];
                    getsym
                    <span style="color: #00ffff;">END</span>
                <span style="color: #00ffff;">END</span>;
            leftparenthesis :
                <span style="color: #00ffff;">BEGIN</span>
                getsym;
                expression;
                check(rightparenthesis_,[],
                    <span style="color: #00ff00;">'")" expected                  '</span>);
                <span style="color: #00ffff;">END</span>;
            OTHERWISE
                point(<span style="color: #00ff00;">'F'</span>,<span style="color: #00ff00;">'internal error in factor      '</span>);
            <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
        <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">factor *)</span>

    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">term *)</span>
    factor;
    <span style="color: #00ffff;">IF</span> sym &lt;= and_op <span style="color: #00ffff;">THEN</span>
        <span style="color: #00ffff;">BEGIN</span>
        left := codeindex;
        <span style="color: #00ffff;">IF</span> sym &lt;= leftparenthesis <span style="color: #00ffff;">THEN</span> oper := cat_op <span style="color: #00ffff;">ELSE</span>
            <span style="color: #00ffff;">BEGIN</span> oper := sym; getsym <span style="color: #00ffff;">END</span>;
        term; generate(oper,left,codeindex)
        <span style="color: #00ffff;">END</span>
    <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">term *)</span>;

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">expression *)</span>
term;
<span style="color: #00ffff;">IF</span> sym <span style="color: #00ffff;">IN</span> [alt_op,or_op,imp_op,iff_op] <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span>
    left := codeindex; oper := sym; getsym;
    expression; generate(oper,left,codeindex)
    <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">expression *)</span>;

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">block</span>;

<span style="color: #ff00ff;">VAR</span>
    loc, cap, toknum, i : <span style="color: #ff00ff;">integer</span>;
    poss : markset;
    net_fix : <span style="color: #ff00ff;">integer</span>;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">arc_list</span>;
    <span style="color: #ff00ff;">VAR</span> left : <span style="color: #ff00ff;">integer</span>;

        <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">onearc</span>;
        <span style="color: #ff00ff;">VAR</span> tr_declarator : symbol; i : <span style="color: #ff00ff;">integer</span>;

            <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">placelist</span>;
            <span style="color: #ff00ff;">VAR</span> left : <span style="color: #ff00ff;">integer</span>;

                <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">oneplace</span>;
                <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">oneplace *)</span>
                lookup;
                <span style="color: #00ffff;">IF</span> sym &lt;&gt; place_id <span style="color: #00ffff;">THEN</span>
                    point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'place identifier expected     '</span>)
                  <span style="color: #00ffff;">ELSE</span>
                    <span style="color: #00ffff;">BEGIN</span> generate(arc_op,num,99999); getsym <span style="color: #00ffff;">END</span>
                <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">oneplace *)</span>

            <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">placelist *)</span>
            oneplace;
            <span style="color: #00ffff;">IF</span> sym = comma_ <span style="color: #00ffff;">THEN</span>
                <span style="color: #00ffff;">BEGIN</span>
                left := codeindex; getsym;
                placelist; generate(and_op,left,codeindex)
                <span style="color: #00ffff;">END</span>
            <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">placelist *)</span>

        <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">onearc *)</span>
        tr_declarator := sym; getsym;
        <span style="color: #00ffff;">IF</span> tr_declarator = action_ <span style="color: #00ffff;">THEN</span> expression <span style="color: #00ffff;">ELSE</span>
            <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">arc *)</span>
            i := codeindex; placelist;
            <span style="color: #00ffff;">IF</span> sym &lt;&gt; numberconst <span style="color: #00ffff;">then</span> toknum := 1 <span style="color: #00ffff;">ELSE</span>
                <span style="color: #00ffff;">BEGIN</span> toknum := num; getsym <span style="color: #00ffff;">END</span>;
            <span style="color: #00ffff;">WHILE</span> i &lt; codeindex <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">update *)</span>
                i := i + 1;
                <span style="color: #00ffff;">WITH</span> code[i] <span style="color: #00ffff;">DO</span>
                    <span style="color: #00ffff;">IF</span> op = arc_op <span style="color: #00ffff;">THEN</span>
                        <span style="color: #00ffff;">BEGIN</span>
                        cap := place[left].capacity;
                        <span style="color: #00ffff;">IF</span> tr_declarator = inarc_ <span style="color: #00ffff;">THEN</span>
                            <span style="color: #00ffff;">BEGIN</span>
                            arc_opset := [toknum .. cap];
                            right := - toknum
                            <span style="color: #00ffff;">END</span>
                          <span style="color: #00ffff;">ELSE</span>
                            <span style="color: #00ffff;">BEGIN</span>
                            arc_opset := [0 .. cap - toknum];
                            right := toknum
                            <span style="color: #00ffff;">END</span>
                        <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">arc_op *)</span>
                <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">update *)</span>
            <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">arc *)</span>
        <span style="color: #00ffff;">IF</span> sym = semicol_ <span style="color: #00ffff;">THEN</span> getsym;
        <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">onearc *)</span>

    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">arc_list *)</span>
    onearc;
    <span style="color: #00ffff;">IF</span> sym <span style="color: #00ffff;">IN</span> [inarc_,outarc_,action_] <span style="color: #00ffff;">THEN</span>
        <span style="color: #00ffff;">BEGIN</span>
        left := codeindex;
        arc_list; generate(and_op,left,codeindex)
        <span style="color: #00ffff;">END</span>
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">arc_list *)</span>

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">block *)</span>
new_id_allowed := true;
<span style="color: #00ffff;">WHILE</span> sym <span style="color: #00ffff;">IN</span> [place_,transition_,production_,logical_] <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">CASE</span> sym <span style="color: #00ffff;">OF</span>
        logical_ :
            <span style="color: #00ffff;">BEGIN</span>
            getsym;
            <span style="color: #00ffff;">WHILE</span> sym = identifier <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">BEGIN</span>
                <span style="color: #00ffff;">REPEAT</span>
                    lookup;
                    <span style="color: #00ffff;">IF</span> sym &lt;&gt; new_id <span style="color: #00ffff;">THEN</span>
                        point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'new identifier expected       '</span>);
                    lastplace := lastplace + 1;
                    <span style="color: #00ffff;">WITH</span> place[lastplace] <span style="color: #00ffff;">DO</span>
                        <span style="color: #00ffff;">BEGIN</span>
                        symtab_ptr := location; capacity := 1;
                        pl_poss := [0,1]; pl_cur := [0,1]
                        <span style="color: #00ffff;">END</span>;
                    <span style="color: #00ffff;">WITH</span> symtab[location] <span style="color: #00ffff;">DO</span>
                        <span style="color: #00ffff;">BEGIN</span> obj := logical_id; val := lastplace <span style="color: #00ffff;">END</span>;
                    getsym;
                    <span style="color: #00ffff;">IF</span> sym = comma_ <span style="color: #00ffff;">THEN</span> getsym
                    <span style="color: #00ffff;">UNTIL</span> <span style="color: #00ffff;">NOT</span> (sym &lt;= identifier);
                <span style="color: #00ffff;">IF</span> sym = semicol_ <span style="color: #00ffff;">THEN</span> getsym
                <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE ident *)</span>
            <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">logical *)</span>
        place_ :
            <span style="color: #00ffff;">BEGIN</span>
            getsym;
            <span style="color: #00ffff;">WHILE</span> sym &lt;= identifier <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">BEGIN</span>
                i := lastplace;
                <span style="color: #00ffff;">REPEAT</span>
                    lookup;
                    <span style="color: #00ffff;">IF</span> sym &lt;&gt; new_id <span style="color: #00ffff;">THEN</span>
                        point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'new identifier expected       '</span>);
                    lastplace := lastplace + 1;
                    place[lastplace].symtab_ptr := location;
                    <span style="color: #00ffff;">WITH</span> symtab[location] <span style="color: #00ffff;">DO</span>
                        <span style="color: #00ffff;">BEGIN</span> obj := place_id; val := lastplace <span style="color: #00ffff;">END</span>;
                    getsym;
                    <span style="color: #00ffff;">IF</span> sym = comma_ <span style="color: #00ffff;">THEN</span> getsym
                    <span style="color: #00ffff;">UNTIL</span> <span style="color: #00ffff;">NOT</span> (sym &lt;= identifier);
                <span style="color: #00ffff;">IF</span> sym = colon_ <span style="color: #00ffff;">THEN</span> getsym;
                <span style="color: #00ffff;">IF</span> sym &lt;&gt; numberconst <span style="color: #00ffff;">THEN</span> cap := 1 <span style="color: #00ffff;">ELSE</span>
                    <span style="color: #00ffff;">BEGIN</span> cap := num; getsym <span style="color: #00ffff;">END</span>;
                poss := [0 .. cap];
                <span style="color: #00ffff;">WHILE</span> i &lt; lastplace <span style="color: #00ffff;">DO</span>
                    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">update *)</span>
                    i := i + 1;
                    <span style="color: #00ffff;">WITH</span> place[i] <span style="color: #00ffff;">DO</span>
                        <span style="color: #00ffff;">BEGIN</span>
                        capacity := cap;
                        pl_poss := poss;
                        pl_cur := poss
                        <span style="color: #00ffff;">END</span>
                    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE *)</span>
                <span style="color: #00ffff;">IF</span> sym = semicol_ <span style="color: #00ffff;">THEN</span> getsym
                <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE ident *)</span>
            <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">place *)</span>
        transition_ :
            <span style="color: #00ffff;">BEGIN</span>
            getsym;
            <span style="color: #00ffff;">WHILE</span> sym = identifier <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">BEGIN</span>
                loc := lastsymtab + 1;
                <span style="color: #00ffff;">REPEAT</span>
                    lookup;
                    <span style="color: #00ffff;">IF</span> sym &lt;&gt; new_id <span style="color: #00ffff;">THEN</span>
                        point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'new identifier expected       '</span>);
                    symtab[location].obj := transition_id;
                    getsym;
                    <span style="color: #00ffff;">IF</span> sym = comma_ <span style="color: #00ffff;">THEN</span> getsym
                    <span style="color: #00ffff;">UNTIL</span> <span style="color: #00ffff;">NOT</span> (sym &lt;= identifier);
                <span style="color: #00ffff;">IF</span> sym = semicol_ <span style="color: #00ffff;">THEN</span> getsym;
                <span style="color: #00ffff;">IF</span> sym <span style="color: #00ffff;">IN</span> [inarc_,outarc_,action_]
                    <span style="color: #00ffff;">THEN</span> arc_list
                    <span style="color: #00ffff;">ELSE</span> generate(skip_op,0,0);
                <span style="color: #00ffff;">WHILE</span> loc &lt;= lastsymtab <span style="color: #00ffff;">DO</span>
                    <span style="color: #00ffff;">BEGIN</span>
                    symtab[loc].val :=codeindex; loc := loc + 1
                    <span style="color: #00ffff;">END</span>
                <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE ident *)</span>
            <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">transition *)</span>
        production_ :
            <span style="color: #00ffff;">BEGIN</span>
            getsym;
            <span style="color: #00ffff;">WHILE</span> sym = identifier <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">BEGIN</span>
                lookup;
                <span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">NOT</span> (sym <span style="color: #00ffff;">IN</span> [new_id, nonterminal_id]) <span style="color: #00ffff;">THEN</span>
                    point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'nonterminal expected          '</span>);
                <span style="color: #00ffff;">IF</span> sym = new_id <span style="color: #00ffff;">THEN</span>
                    symtab[location].obj := nonterminal_id;
                loc := location; getsym;
                check(bnfarrow_,[],<span style="color: #00ff00;">'"::=" expected                '</span>);
                expression; symtab[loc].val := codeindex;
                <span style="color: #00ffff;">IF</span> sym = semicol_ <span style="color: #00ffff;">THEN</span> getsym
                <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE idents *)</span>
            <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">production *)</span>
        <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
<span style="color: #00ffff;">IF</span> writelisting &gt; 1 <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span> writeln(listing); writeln(listing,<span style="color: #00ff00;">'symbol table: '</span>) <span style="color: #00ffff;">END</span>;
net_fix := 0;
<span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> lastsymtab <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">WITH</span> symtab[i] <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">BEGIN</span>
        <span style="color: #00ffff;">CASE</span> obj <span style="color: #00ffff;">OF</span>
            transition_id :
                <span style="color: #00ffff;">BEGIN</span>
                generate(trans_op,i,val);
                generate(or_op,codeindex,0);
                <span style="color: #00ffff;">IF</span> headnode = 0
                    <span style="color: #00ffff;">THEN</span> headnode := codeindex
                    <span style="color: #00ffff;">ELSE</span> code[net_fix].right := codeindex;
                net_fix := codeindex;
                <span style="color: #00ffff;">END</span>;
            nonterminal_id :
                <span style="color: #00ffff;">IF</span> val = 0 <span style="color: #00ffff;">THEN</span>
                    <span style="color: #00ffff;">BEGIN</span>
                    point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'undefined non-terminal        '</span>);
                    putch(<span style="color: #00ff00;">'"'</span>); writeident(alf); putch(<span style="color: #00ff00;">'"'</span>);
                    writeline; <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">99</span>
                    <span style="color: #00ffff;">END</span>;
            <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
        <span style="color: #00ffff;">IF</span> writelisting &gt; 1 <span style="color: #00ffff;">THEN</span>
            writeln(i:3,<span style="color: #00ff00;">' '</span>,alf:identlength,<span style="color: #00ff00;">' '</span>,obj,<span style="color: #00ff00;">' '</span>,val)
        <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">WITH,FOR *)</span>
<span style="color: #00ffff;">IF</span> headnode &lt;&gt; 0 <span style="color: #00ffff;">THEN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">delete the last "OR" for transitions *)</span>
    <span style="color: #00ffff;">BEGIN</span>
    codeindex := codeindex - 1;
    code[codeindex - 1].right := code[codeindex + 1].left;
    <span style="color: #00ffff;">END</span>;
last_block_code := codeindex;
<span style="color: #00ffff;">IF</span> writelisting &gt; 2 <span style="color: #00ffff;">THEN</span>
    writeln(listing,<span style="color: #00ff00;">'code for this block'</span>);
<span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> codeindex <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">WITH</span> code[i] <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">IF</span> op = nonterm_op <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            right := symtab[left].val; <span style="color: #66f;">(* </span><span style="color: #66f;">fixup *)</span>
            <span style="color: #00ffff;">IF</span> writelisting &gt; 2 <span style="color: #00ffff;">THEN</span> writenode(i)
            <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">block *)</span>

<span style="color: #66f;">(* </span><span style="color: #66f;">- - - - -  A N A L Y S I S  - - - - - *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">skip</span>;
<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">skip *)</span>
<span style="color: #00ffff;">IF</span> pathnum = maxpaths <span style="color: #00ffff;">THEN</span>
    maxlength := -1; <span style="color: #66f;">(* </span><span style="color: #66f;">this will block further tries *)</span>
pathnum := pathnum + 1
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">skip *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">show_markings</span>;
<span style="color: #ff00ff;">VAR</span> i,j : <span style="color: #ff00ff;">integer</span>;
<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">show_markings *)</span>
writeident(<span style="color: #00ff00;">'mark            '</span>); putch(<span style="color: #00ff00;">' '</span>);
writeinteger(pathnum); putch(<span style="color: #00ff00;">':'</span>); writeline;
<span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> lastplace <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">WITH</span> place[i] <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">IF</span> pl_cur &lt;&gt; pl_poss <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            putch(chr(9));
            writeident(symtab[symtab_ptr].alf); putch(<span style="color: #00ff00;">' '</span>);
            <span style="color: #00ffff;">FOR</span> j := 0 <span style="color: #00ffff;">TO</span> capacity <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">IF</span> j <span style="color: #00ffff;">IN</span> pl_cur <span style="color: #00ffff;">THEN</span>
                    <span style="color: #00ffff;">BEGIN</span>
                    <span style="color: #00ffff;">IF</span> symtab[symtab_ptr].obj &lt;&gt; logical_id
                        <span style="color: #00ffff;">THEN</span> writeinteger(j)
                    <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> j = 0 <span style="color: #00ffff;">THEN</span> writeident(<span style="color: #00ff00;">'FALSE           '</span>)
                    <span style="color: #00ffff;">ELSE</span> writeident(<span style="color: #00ff00;">'TRUE            '</span>);
                    putch(<span style="color: #00ff00;">' '</span>)
                    <span style="color: #00ffff;">END</span>;
            writeline
            <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">show_markings *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">show_path</span>;
<span style="color: #ff00ff;">VAR</span> i : <span style="color: #ff00ff;">integer</span>;
<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">show_path *)</span>
writeident(<span style="color: #00ff00;">'path            '</span>); putch(<span style="color: #00ff00;">' '</span>);
writeinteger(pathnum); putch(<span style="color: #00ff00;">':'</span>); writeline;
<span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> pathlength <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">BEGIN</span> writeident(symtab[path[i]].alf); putch(<span style="color: #00ff00;">' '</span>) <span style="color: #00ffff;">END</span>;
<span style="color: #00ffff;">IF</span> pathlength &gt; 1 <span style="color: #00ffff;">THEN</span> writeline
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">show_path *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">show_tot_num_paths</span>(<span style="color: #ff00ff;">VAR</span> f : text);
<span style="color: #00ffff;">BEGIN</span>
writeln(f,<span style="color: #00ff00;">'     '</span> <span style="color: #66f;">(* </span><span style="color: #66f;">normal tab *)</span>,
    <span style="color: #00ff00;">'total number of paths: '</span>,pathnum-1:0)
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">show_tot_num_paths *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">unreach</span>(n : <span style="color: #ff00ff;">integer</span>; PROCEDURE cp); <span style="color: #00ffff;">forward</span>;
<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">parse</span>(t : <span style="color: #ff00ff;">integer</span>; PROCEDURE cp);

<span style="color: #ff00ff;">VAR</span> saveset : markset; i : <span style="color: #ff00ff;">integer</span>;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">setinteger</span>(<span style="color: #ff00ff;">VAR</span> v : <span style="color: #ff00ff;">integer</span>; val : <span style="color: #ff00ff;">integer</span>);
    <span style="color: #ff00ff;">VAR</span> old : <span style="color: #ff00ff;">integer</span>;
    <span style="color: #00ffff;">BEGIN</span> old := v; v := val; cp; v := old <span style="color: #00ffff;">END</span>;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">setmode</span>(newmode : symbol;
                      newgoal : <span style="color: #ff00ff;">boolean</span>; p : <span style="color: #ff00ff;">integer</span>);
    <span style="color: #ff00ff;">VAR</span> savemode : symbol; savegoal : <span style="color: #ff00ff;">boolean</span>;

        <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">restoremode</span>;
        <span style="color: #00ffff;">BEGIN</span>
        mode := savemode; goal := savegoal;
        cp;
        mode := newmode; goal := newgoal
        <span style="color: #00ffff;">END</span>;

    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">setmode *)</span>
    savemode := mode; savegoal := goal;
    mode := newmode; goal := newgoal;
    parse(p,restoremode);
    mode := savemode; goal := savegoal
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">setmode *)</span>

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">parsenot</span>(t : <span style="color: #ff00ff;">integer</span>; PROCEDURE cp);
    <span style="color: #ff00ff;">VAR</span> oldgoal : <span style="color: #ff00ff;">boolean</span>; i : <span style="color: #ff00ff;">integer</span>;

        <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">restoregoal</span>;
        <span style="color: #ff00ff;">VAR</span> g : <span style="color: #ff00ff;">boolean</span>;
        <span style="color: #00ffff;">BEGIN</span> g := goal; goal := <span style="color: #00ffff;">NOT</span> goal; cp; goal := g <span style="color: #00ffff;">END</span>;

    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">parsenot *)</span>
    <span style="color: #00ffff;">IF</span> mode = execute_op <span style="color: #00ffff;">THEN</span>
        <span style="color: #00ffff;">BEGIN</span>
        i := pathnum;
        parse(t,skip);
        <span style="color: #00ffff;">IF</span> pathnum = i <span style="color: #66f;">(* </span><span style="color: #66f;">no successes *)</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span> pathnum := pathnum + 1; cp <span style="color: #00ffff;">END</span>
        <span style="color: #00ffff;">END</span>
      <span style="color: #00ffff;">ELSE</span>
        <span style="color: #00ffff;">BEGIN</span>
        oldgoal := goal; goal := <span style="color: #00ffff;">NOT</span> goal;
        parse(t,restoregoal);
        goal := oldgoal
        <span style="color: #00ffff;">END</span>;
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">parsenot *)</span>

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">restorefence</span>;
    <span style="color: #ff00ff;">VAR</span> f : <span style="color: #ff00ff;">boolean</span>;
    <span style="color: #00ffff;">BEGIN</span> f := fenced; fenced := i = 1; cp; fenced := f <span style="color: #00ffff;">END</span>;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">parseright</span>;
    <span style="color: #00ffff;">BEGIN</span> parse(code[t].right,cp) <span style="color: #00ffff;">END</span>;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">parsenotright</span>;
    <span style="color: #00ffff;">BEGIN</span> parsenot(code[t].right,cp) <span style="color: #00ffff;">END</span>;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">sameagain</span>;
    <span style="color: #00ffff;">BEGIN</span> parse(t,cp) <span style="color: #00ffff;">END</span>;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">times</span>(count,argument : <span style="color: #ff00ff;">integer</span>);
    <span style="color: #ff00ff;">VAR</span> i : <span style="color: #ff00ff;">integer</span>;

        <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">tiimes</span>;
        <span style="color: #00ffff;">BEGIN</span>
        i := i - 1;
        <span style="color: #00ffff;">IF</span> i &lt; 1 <span style="color: #00ffff;">THEN</span> cp <span style="color: #00ffff;">ELSE</span> parse(t,tiimes);
        i := i + 1
        <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">tiimes *)</span>

    <span style="color: #00ffff;">BEGIN</span>
    i := count; t := argument;
    parse(t,tiimes)
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">times *)</span>

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">save</span>(this_save : <span style="color: #ff00ff;">integer</span>);
    <span style="color: #ff00ff;">VAR</span> i,displacement : <span style="color: #ff00ff;">integer</span>;
    <span style="color: #00ffff;">BEGIN</span>
    displacement := lastplace * this_save;
    <span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> lastplace <span style="color: #00ffff;">DO</span>
        saves[i + displacement] := place[i].pl_cur
    <span style="color: #00ffff;">END</span>;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">restore</span>(this_restore : <span style="color: #ff00ff;">integer</span>);
    <span style="color: #ff00ff;">VAR</span> i,displacement : <span style="color: #ff00ff;">integer</span>;
    <span style="color: #00ffff;">BEGIN</span>
    displacement := lastplace * this_restore;
    <span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> lastplace <span style="color: #00ffff;">DO</span>
        place[i].pl_cur := saves[i + displacement]
    <span style="color: #00ffff;">END</span>;

    <span style="color: #00ffff;">FUNCTION</span> <span style="color: #ffffff; font-weight: bold;">samestate</span>(this_samestate : <span style="color: #ff00ff;">integer</span>) : <span style="color: #ff00ff;">boolean</span>;
    <span style="color: #ff00ff;">VAR</span> i,displacement : <span style="color: #ff00ff;">integer</span>;
    <span style="color: #00ffff;">BEGIN</span>
    displacement := lastplace * this_samestate;
    i := lastplace;
    <span style="color: #00ffff;">REPEAT</span>
        <span style="color: #00ffff;">IF</span> place[i].pl_cur = saves[i + displacement]
            <span style="color: #00ffff;">THEN</span> i := i - 1 <span style="color: #00ffff;">ELSE</span> i := -1
        <span style="color: #00ffff;">UNTIL</span> i &lt; 1;
    samestate := i = 0
    <span style="color: #00ffff;">END</span>;

    <span style="color: #00ffff;">FUNCTION</span> <span style="color: #ffffff; font-weight: bold;">substate</span>(this_substate : <span style="color: #ff00ff;">integer</span>) : <span style="color: #ff00ff;">boolean</span>;
    <span style="color: #ff00ff;">VAR</span> i,displacement : <span style="color: #ff00ff;">integer</span>;
    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">substate *)</span>
    displacement := lastplace * this_substate;
    i := lastplace;
    <span style="color: #00ffff;">REPEAT</span>
        <span style="color: #00ffff;">IF</span> place[i].pl_cur &lt;= saves[i + displacement]
            <span style="color: #00ffff;">THEN</span> i := i - 1 <span style="color: #00ffff;">ELSE</span> i := -1
        <span style="color: #00ffff;">UNTIL</span> i &lt; 1;
    substate := i = 0
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">substate *)</span>

    <span style="color: #00ffff;">FUNCTION</span> <span style="color: #ffffff; font-weight: bold;">superstate</span>(this_superstate : <span style="color: #ff00ff;">integer</span>) : <span style="color: #ff00ff;">boolean</span>;
    <span style="color: #ff00ff;">VAR</span> i,displacement : <span style="color: #ff00ff;">integer</span>;
    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">superstate *)</span>
    displacement := lastplace * this_superstate;
    i := lastplace;
    <span style="color: #00ffff;">REPEAT</span>
        <span style="color: #00ffff;">IF</span> place[i].pl_cur &gt;= saves[i + displacement]
            <span style="color: #00ffff;">THEN</span> i := i - 1 <span style="color: #00ffff;">ELSE</span> i := -1
        <span style="color: #00ffff;">UNTIL</span> i &lt; 1;
    superstate := i = 0
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">superstate *)</span>

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">parse *)</span>
<span style="color: #00ffff;">IF</span> writelisting &gt; 3 <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span>
    <span style="color: #00ffff;">write</span>(listing,pathnum:0,<span style="color: #00ff00;">' '</span>,mode:1,<span style="color: #00ff00;">' '</span>,goal:1,<span style="color: #00ff00;">' '</span>);
    writenode(t)
    <span style="color: #00ffff;">END</span>;
<span style="color: #00ffff;">IF</span> pathlength &lt;= maxlength <span style="color: #00ffff;">THEN</span>
  <span style="color: #00ffff;">WITH</span> code[t] <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">CASE</span> op <span style="color: #00ffff;">OF</span>

<span style="color: #66f;">(* </span><span style="color: #66f;">control *)</span>

        abort_op :
            maxlength := -1; <span style="color: #66f;">(* </span><span style="color: #66f;">instead of GOTO 1 *)</span>
        quit_op :
            <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">99</span>;
        nonterm_op :
            parse(right,cp);

<span style="color: #66f;">(* </span><span style="color: #66f;">mode *)</span>

        execute_op,verify_op,possibly_op :
            setmode(op,true,right);

<span style="color: #66f;">(* </span><span style="color: #66f;">regular *)</span>

        skip_op :
            cp;
        fail_op :
            ; <span style="color: #66f;">(* </span><span style="color: #66f;">do nothing *)</span>
        cat_op :
            parse(left,parseright);
        alt_op :
            <span style="color: #00ffff;">BEGIN</span>
            parse(left,cp);
            <span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">NOT</span> fenced <span style="color: #00ffff;">THEN</span> parse(right,cp);
            <span style="color: #00ffff;">END</span>;
        opt_op :
            <span style="color: #00ffff;">BEGIN</span> cp; parse(right,cp) <span style="color: #00ffff;">END</span>;
        pos_op :
            <span style="color: #00ffff;">BEGIN</span> parse(right,cp); parse(right,sameagain) <span style="color: #00ffff;">END</span>;
        rep_op :
            <span style="color: #00ffff;">BEGIN</span> cp; parse(right,sameagain) <span style="color: #00ffff;">END</span>;
        timmes_op :
            times(left,right);
        showtotpathnum_op :
            <span style="color: #00ffff;">BEGIN</span> showtotpathnum := true; cp <span style="color: #00ffff;">END</span>;
        fence_op :
            <span style="color: #00ffff;">BEGIN</span> fenced := true; cp <span style="color: #00ffff;">END</span>;
        newscope_op :
            <span style="color: #00ffff;">BEGIN</span>
            i := ord(fenced); fenced := false;
            parse(right,restorefence)
            <span style="color: #00ffff;">END</span>;
        maxpaths_op :
            setinteger(maxpaths,left);
        pathnum_op :
            <span style="color: #00ffff;">IF</span> pathnum = left <span style="color: #00ffff;">THEN</span> cp;

<span style="color: #66f;">(* </span><span style="color: #66f;">boolean *)</span>

        false_op,true_op :
            <span style="color: #00ffff;">IF</span> (op = true_op) = goal <span style="color: #00ffff;">THEN</span> cp;
        logical_op :
            <span style="color: #00ffff;">WITH</span> place[right] <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">IF</span> ord(goal) <span style="color: #00ffff;">IN</span> pl_cur <span style="color: #00ffff;">THEN</span>
                    <span style="color: #00ffff;">BEGIN</span>
                    saveset := pl_cur;
                    pl_cur := [ord(goal)]; cp;
                    pl_cur := saveset
                    <span style="color: #00ffff;">END</span>;
        and_op,or_op :
            <span style="color: #00ffff;">IF</span> (op = and_op) = goal
                <span style="color: #00ffff;">THEN</span> parse(left,parseright)
                <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">BEGIN</span> parse(left,cp); parse(right,cp) <span style="color: #00ffff;">END</span>;
        not_op :
                parsenot(right,cp);
        imp_op :
            <span style="color: #00ffff;">IF</span> goal <span style="color: #00ffff;">THEN</span>
                <span style="color: #00ffff;">BEGIN</span>
                parsenot(left,cp);
                parse(right,cp)
                <span style="color: #00ffff;">END</span>
              <span style="color: #00ffff;">ELSE</span>
                parsenot(left,parseright);
        iff_op :
            <span style="color: #00ffff;">IF</span> goal <span style="color: #00ffff;">THEN</span>
                <span style="color: #00ffff;">BEGIN</span>
                parse(left,parseright);
                parsenot(left,parsenotright)
                <span style="color: #00ffff;">END</span>
              <span style="color: #00ffff;">ELSE</span>
                <span style="color: #00ffff;">BEGIN</span>
                parse(left,parsenotright);
                parsenot(left,parseright)
                <span style="color: #00ffff;">END</span>;
<span style="color: #66f;">(* </span><span style="color: #66f;">events *)</span>

        trans_op :
            <span style="color: #00ffff;">BEGIN</span>
            <span style="color: #00ffff;">IF</span> pathlength = maxpathlength <span style="color: #00ffff;">THEN</span>
                <span style="color: #00ffff;">BEGIN</span> writeln(<span style="color: #00ff00;">'path is too long'</span>); <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">99</span> <span style="color: #00ffff;">END</span>;
            pathlength := pathlength + 1;
            path[pathlength] := left; <span style="color: #66f;">(* </span><span style="color: #66f;">to symtab *)</span>
            parse(right,cp);
            pathlength := pathlength - 1
            <span style="color: #00ffff;">END</span>;
        net_op :
            parse(headnode,cp);
        len_op :
            times(left,headnode);
        tab_op :
            times(left-pathlength,headnode);
        position_op :
            <span style="color: #00ffff;">IF</span> pathlength = left <span style="color: #00ffff;">THEN</span> cp;
        maxlength_op :
            setinteger(maxlength,left);
        show_path_op :
            <span style="color: #00ffff;">BEGIN</span> show_path; cp <span style="color: #00ffff;">END</span>;

<span style="color: #66f;">(* </span><span style="color: #66f;">state *)</span>

        save_op :
            <span style="color: #00ffff;">BEGIN</span> save(left); cp <span style="color: #00ffff;">END</span>;
        restore_op :
            <span style="color: #00ffff;">BEGIN</span> restore(left); cp <span style="color: #00ffff;">END</span>;
        samestate_op :
            <span style="color: #00ffff;">IF</span> samestate(left) <span style="color: #00ffff;">THEN</span> cp;
        newstate_op :
            <span style="color: #00ffff;">BEGIN</span>
            <span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> lastplace <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">WITH</span> place[i] <span style="color: #00ffff;">DO</span> pl_cur := pl_poss;
            cp
            <span style="color: #00ffff;">END</span>;
        substate_op :
            <span style="color: #00ffff;">IF</span> substate(left) <span style="color: #00ffff;">THEN</span> cp;
        superstate_op :
            <span style="color: #00ffff;">IF</span> superstate(left) <span style="color: #00ffff;">THEN</span> cp;

<span style="color: #66f;">(* </span><span style="color: #66f;">place *)</span>

        set_op :
            <span style="color: #00ffff;">WITH</span> place[left] <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">IF</span> pl_cur * arc_opset &lt;&gt; [] <span style="color: #00ffff;">THEN</span>
                    <span style="color: #00ffff;">BEGIN</span>
                    saveset := pl_cur;
                    pl_cur := arc_opset;
                    cp;
                    pl_cur := saveset
                    <span style="color: #00ffff;">END</span>;
<span style="color: #66f;">(* </span><span style="color: #66f;">! ! ! ! ! ! ! ! ! THIS NEEDS LOOKING AT ! ! ! ! ! ! ! ! ! ! *)</span>
        empty_op :
            <span style="color: #00ffff;">WITH</span> place[left] <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">IF</span> (0 <span style="color: #00ffff;">IN</span> pl_cur) = goal <span style="color: #00ffff;">THEN</span>
                    <span style="color: #00ffff;">BEGIN</span>
                    saveset := pl_cur;
                    <span style="color: #00ffff;">CASE</span> mode <span style="color: #00ffff;">OF</span>
                        execute_op,verify_op :
                            <span style="color: #00ffff;">IF</span> goal
                                <span style="color: #00ffff;">THEN</span> pl_cur := [0]
                                <span style="color: #00ffff;">ELSE</span> pl_cur := pl_poss - [0];
                        possibly_op :
                        OTHERWISE
                            point(<span style="color: #00ff00;">'F'</span>,
                                <span style="color: #00ff00;">'internal - emptyop            '</span>)
                        <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
                    cp;
                    pl_cur := saveset
                    <span style="color: #00ffff;">END</span>;
        show_markings_op :
            <span style="color: #00ffff;">BEGIN</span> show_markings; cp <span style="color: #00ffff;">END</span>;
        arc_op :
            <span style="color: #00ffff;">WITH</span> place[left] <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">BEGIN</span>
                saveset := pl_cur;
                <span style="color: #00ffff;">CASE</span> mode <span style="color: #00ffff;">OF</span>
                    execute_op :
                        <span style="color: #00ffff;">IF</span> pl_cur * arc_opset &lt;&gt; [] <span style="color: #00ffff;">THEN</span>
                            <span style="color: #00ffff;">BEGIN</span>
                            pl_cur := [];
                            <span style="color: #00ffff;">IF</span> right &lt; 0 <span style="color: #00ffff;">THEN</span>
                                <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">inarc *)</span>
                                <span style="color: #00ffff;">FOR</span> i := - right <span style="color: #00ffff;">TO</span> capacity <span style="color: #00ffff;">DO</span>
                                    <span style="color: #00ffff;">IF</span> i <span style="color: #00ffff;">IN</span> saveset <span style="color: #00ffff;">THEN</span>
                                        pl_cur := pl_cur + [i + right]
                                <span style="color: #00ffff;">END</span>
                              <span style="color: #00ffff;">ELSE</span>
                                <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">outarc_ *)</span>
                                <span style="color: #00ffff;">FOR</span> i := 0 <span style="color: #00ffff;">TO</span> capacity - right <span style="color: #00ffff;">DO</span>
                                    <span style="color: #00ffff;">IF</span> i <span style="color: #00ffff;">IN</span> saveset <span style="color: #00ffff;">THEN</span>
                                        pl_cur := pl_cur + [i + right]
                                <span style="color: #00ffff;">END</span>;
                            cp
                            <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">execute *)</span>
                    verify_op :
                        <span style="color: #00ffff;">BEGIN</span>
                        <span style="color: #00ffff;">IF</span> goal
                            <span style="color: #00ffff;">THEN</span> pl_cur := pl_cur * arc_opset
                            <span style="color: #00ffff;">ELSE</span> pl_cur := pl_cur - arc_opset;
                        <span style="color: #00ffff;">IF</span> pl_cur &lt;&gt; [] <span style="color: #00ffff;">THEN</span> cp
                        <span style="color: #00ffff;">END</span>;
                    possibly_op :
                        <span style="color: #00ffff;">IF</span> goal <span style="color: #00ffff;">AND</span> (pl_cur * arc_opset = []) <span style="color: #00ffff;">OR</span>
                        <span style="color: #00ffff;">NOT</span> goal <span style="color: #00ffff;">AND</span> (pl_cur-arc_opset = []) <span style="color: #00ffff;">THEN</span> cp;
                    OTHERWISE
                        point(<span style="color: #00ff00;">'F'</span>,
                            <span style="color: #00ff00;">'internal: arc_op              '</span>);
                    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
                pl_cur := saveset
                <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">WITH *)</span>
        deadlock_op :
            setmode(verify_op,false,headnode);
        unreachable_op :
            unreach(headnode,cp);
        OTHERWISE
            <span style="color: #00ffff;">BEGIN</span>
            writeln(<span style="color: #00ff00;">'internal error "parse", op = '</span>,op);
            <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">99</span>
            <span style="color: #00ffff;">END</span>
        <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">parse *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">unreach</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">(n : integer; PROCEDURE cp) was forward *)</span>
<span style="color: #ff00ff;">VAR</span> saveset : markset;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">unreachright</span>;
      <span style="color: #00ffff;">BEGIN</span> unreach(code[n].right, cp) <span style="color: #00ffff;">END</span>;

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">unreach *)</span>
<span style="color: #00ffff;">WITH</span> code[n] <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">CASE</span> op <span style="color: #00ffff;">OF</span>
        arc_op :
            <span style="color: #00ffff;">WITH</span> place[left] <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">IF</span> pl_cur - (pl_poss - arc_opset) &lt;&gt; [] <span style="color: #00ffff;">THEN</span>
                    <span style="color: #00ffff;">BEGIN</span>
                    saveset := pl_cur;
                    pl_cur := pl_cur - (pl_poss - arc_opset);
                    cp;
                    pl_cur := saveset
                    <span style="color: #00ffff;">END</span>;
        trans_op :
            unreach(right,cp);
        and_op :
            <span style="color: #00ffff;">BEGIN</span> unreach(left, cp); unreach(right, cp) <span style="color: #00ffff;">END</span>;
        or_op :
            unreach(left,unreachright);
        OTHERWISE
            parse(n,cp)
        <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">unreach *)</span>

<span style="color: #66f;">(* </span><span style="color: #66f;">- - - - -  M A I N  - - - - - *)</span>

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">main, NETVER *)</span>
10:
initialise;
<span style="color: #00ffff;">REPEAT</span>
    codeindex := 0; lastsymtab := 0; lastplace := 0;
    headnode := 0; <span style="color: #66f;">(* </span><span style="color: #66f;">will be inspected in block and below *)</span>
    <span style="color: #00ffff;">IF</span> interactive_usage <span style="color: #00ffff;">THEN</span> <span style="color: #00ffff;">write</span>(<span style="color: #00ff00;">'?-  '</span>);
    getsym;
    <span style="color: #00ffff;">IF</span> sym = quit_op <span style="color: #00ffff;">THEN</span> <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">90</span>;
     block;
    <span style="color: #00ffff;">IF</span> writelisting &gt; 10 <span style="color: #00ffff;">THEN</span>
        <span style="color: #00ffff;">BEGIN</span>
        writeln(listing);
        writeln(listing,<span style="color: #00ff00;">'total code for block:'</span>);
        <span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> codeindex <span style="color: #00ffff;">DO</span> writenode(i);
        <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">IF trace &gt; 0 *)</span>
    <span style="color: #00ffff;">WHILE</span> sym = path_ <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">BEGIN</span>
        codeindex := last_block_code; getsym;
        new_id_allowed := false; expression;
        <span style="color: #00ffff;">IF</span> trace &gt; 0 <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span> writeln; writeln(<span style="color: #00ff00;">'code to be executed:'</span>) <span style="color: #00ffff;">END</span>;
        <span style="color: #00ffff;">FOR</span> i := last_block_code + 1 <span style="color: #00ffff;">TO</span> codeindex <span style="color: #00ffff;">DO</span>
            <span style="color: #00ffff;">WITH</span> code[i] <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">BEGIN</span>
                <span style="color: #00ffff;">IF</span> op = nonterm_op <span style="color: #00ffff;">THEN</span>
                    right := symtab[left].val; <span style="color: #66f;">(* </span><span style="color: #66f;">fixup *)</span>
                <span style="color: #00ffff;">IF</span> trace &gt; 0 <span style="color: #00ffff;">THEN</span> writenode(i)
                <span style="color: #00ffff;">END</span>;
        maxlength := maxint; pathnum := 1; pathlength := 0;
        maxpaths := maxint;
        fenced := false; mode := execute_op; goal := true;
        showtotpathnum := false;
        <span style="color: #00ffff;">IF</span> trace &gt; 0 <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span> writeln; writeln(<span style="color: #00ff00;">'executing ...'</span>) <span style="color: #00ffff;">END</span>;
        parse(codeindex,skip);
        <span style="color: #00ffff;">IF</span> showtotpathnum <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            show_tot_num_paths(output);
            <span style="color: #00ffff;">IF</span> writelisting &gt; 0 <span style="color: #00ffff;">THEn</span> show_tot_num_paths(listing)
            <span style="color: #00ffff;">END</span>;
        <span style="color: #00ffff;">IF</span> sym = semicol_ <span style="color: #00ffff;">THEN</span> getsym
        <span style="color: #00ffff;">END</span>;
    <span style="color: #00ffff;">UNTIL</span> false;
90: ;
99: finalise;
<span style="color: #00ffff;">END</span>. <span style="color: #66f;">(* </span><span style="color: #66f;">main, NETVER *)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> Discussion</h2>
<div class="outline-text-2" id="text-10">
<p>
Obviously the system is in need of numerous improvements.  The following sections discuss most of them, organised into
</p>

<ol class="org-ol">
<li>mere embellishments to the user interface,
</li>
<li>improvements of the backtracking mechanism, and
</li>
<li>greater power of the Petri net language.
</li>
</ol>
</div>

<div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> Embellishments</h3>
<div class="outline-text-3" id="text-10-1">
<p>
The system was written very much as a prototype, and no attempt was made to endow it with the kinds of niceties one expects from a final system.  A more mature version should make its use more convenient, and here are some desirable features:
</p>
</div>
</div>
<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> <i>Error recovery</i>:</h3>
<div class="outline-text-3" id="text-10-2">
<p>
At least initially, specifications of nets to be verified are not likely to be large.  Nevertheless, it would be helpful if the parser could continue after the first error and perform further checking.  The techniques of simple error recovery are well understood (see for example the Datbas program in Chapter 19), and their incorporation should not present any problems.
</p>
</div>
</div>
<div id="outline-container-sec-10-3" class="outline-3">
<h3 id="sec-10-3"><span class="section-number-3">10.3</span> <i>String output</i>:</h3>
<div class="outline-text-3" id="text-10-3">
<p>
Currently the only output produced by the verifier is either a path or a marking.  It would make the reading of such output much easier if users could also intersperse such output with meaningful remarks and explanations &#x2014; expressed as character strings.  Two options exist here: that the output is produced at the time of interpretation, or that it is saved away in the path, to be produced only upon completion of the path.  Probably both methods are useful.
</p>
</div>
</div>
<div id="outline-container-sec-10-4" class="outline-3">
<h3 id="sec-10-4"><span class="section-number-3">10.4</span> More advanced backtracking</h3>
<div class="outline-text-3" id="text-10-4">
<p>
The comments in this section pertain to the backtracking methods of the verifier, they would apply equally well to one which does not operate on nets.
</p>
</div>
</div>
<div id="outline-container-sec-10-5" class="outline-3">
<h3 id="sec-10-5"><span class="section-number-3">10.5</span> <i>Regular and Boolean Algebra</i>:</h3>
<div class="outline-text-3" id="text-10-5">
<p>
The verifier allows one to mix concepts from two rather distinct algebras, and the several modes of the verifier are geared to the two algebras.  However, the examples as yet do not fully exploit the possibilities arising from the interaction of the two algebras.  So some theoretical research is needed to examine the interplay between the two algebras, and some practical research is needed to determine the usefulness of having the two together in a verifier of this kind.
</p>
</div>
</div>
<div id="outline-container-sec-10-6" class="outline-3">
<h3 id="sec-10-6"><span class="section-number-3">10.6</span> <i>Other Primitives</i>:</h3>
<div class="outline-text-3" id="text-10-6">
<p>
The verifier offers a collection of general primitives for programmed backtracking which are quite independent of the concepts of the nets being verified.  It would be useful to survey the literature to determine whether there are any other generally applicable primitives, and whether there are any generally applicable methods of combining them apart from the ones offered here.  Klint (1985, pp 31 - 36) describes an elegant, clean and powerful construct called <code>try ..</code> for the control of backtracking and environment modification in string processing languages.  It would appear that the construct is equally useful in any backtracking language.
</p>
</div>
</div>
<div id="outline-container-sec-10-7" class="outline-3">
<h3 id="sec-10-7"><span class="section-number-3">10.7</span> <i>Optimisations</i>:</h3>
<div class="outline-text-3" id="text-10-7">
<p>
The verifier as described does not use any optimisations.  But there are several well-known techniques applicable to backtracking; some depend on the system being modelled, others do not.
</p>

<ol class="org-ol">
<li>Specifically for regular algebras, there is an optimisation, called the length check in Waite (1973, p 264) and called the futility heuristic in the implementation of Snobol (Griswold 1972, p 126): if the completion of the current path requires more atoms (characters in a parsing situation, transition firing in a modeling situation) than are available (in the string to be parsed, in the path to be attempted), then it is futile to continue.
</li>

<li>Specifically for Boolean algebras, there is a heuristic familiar to logicians using the <i>semantic tableaux</i> method: if a choice is to be made between branching now or later, branch later - for example when attempting to verify <code>(p OR q) AND (r AND s)</code>, treat it like <code>(r AND s) AND (p OR q)</code> by expanding <code>r AND s</code> first.
</li>

<li>The two methods above are specific to their subject matter, but there is another which is independent, the intelligent backtracking technique: if failure occurs due to a choice made early in the process, do not backtrack blindly to other choices made later but backtrack immediately to the point which caused the failure.  Van Hentenryck (1989, pp 60 - 69) and Lauriere (1990, pp 211 - 218 and pp 389 - 449) describe some very sophisticated techniques which are even more intelligent: they minimise backtracking by not making choices that can be known in advance to lead to failure.  All these optimisations can produce almost arbitrary speedup for suitably chosen inputs; but clearly they involve some overhead, and whether the overhead is worth it depends on statistical properties of the actual mix of inputs which is impossible to assertain in a vacuum.  An attempt to incorporate intelligent backtracking for just reachability analysis in Netver is reported in Wong (1991).
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-10-8" class="outline-3">
<h3 id="sec-10-8"><span class="section-number-3">10.8</span> A more powerful object language</h3>
<div class="outline-text-3" id="text-10-8">
<p>
The verifier described here operates on Petri nets of almost the simplest kind (the simplest kind would be one in which all place capacities are one).  A great deal of current research has been concerned with what generally are called higher level nets.  This section discusses some of the ways in which the verifier could be extended for such higher level nets.
</p>
</div>

<div id="outline-container-sec-10-8-1" class="outline-4">
<h4 id="sec-10-8-1"><span class="section-number-4">10.8.1</span> <i>Folding of places</i>:</h4>
<div class="outline-text-4" id="text-10-8-1">
<p>
For the nets of this verifier, the places are really integer variables, but are thought of as containing tokens &#x2014; all of the same kind, and as many as indicated by the value of the variable.  In another species of nets the places are thought of as containing several kinds of tokens, and for each kind it has to be indicated how many there are.  Such places are best thought of as being combinations of simpler places each containing only one kind of token, and hence they may be represented by records of several integers, one for each kind.  No difficulty should be experienced with adapting the verifier to deal with such places.
</p>
</div>
</div>
<div id="outline-container-sec-10-8-2" class="outline-4">
<h4 id="sec-10-8-2"><span class="section-number-4">10.8.2</span> <i>Predicate Transition Nets</i>:</h4>
<div class="outline-text-4" id="text-10-8-2">
<p>
In the simplest case the maximum capacity for each kind of token is one.  So for each kind it is either false or true that the place contains a token of that kind, and hence such places are in fact set variables.  Again it should be easy to adapt the verifier for such places.
</p>
</div>
</div>
<div id="outline-container-sec-10-8-3" class="outline-4">
<h4 id="sec-10-8-3"><span class="section-number-4">10.8.3</span> <i>Queueing places</i>:</h4>
<div class="outline-text-4" id="text-10-8-3">
<p>
In all the nets considered so far, tokens upon arrival at a place do not retain any temporal ordering of their arrival.  In nets with queueing places the tokens retain this ordering, and typically the first one to arrive will be the the first one to leave.  Such places are really queues &#x2014; either bounded or unbounded, which may be implemented as (perhaps circular) arrays or as linked lists.  A special case is the queue of size one, a buffer or mailbox, suitable for asynchronous communication.  The incorporation of bounded queueing places in the form of circular arrays should not present any difficulty for a future version of the verifier.
</p>
</div>
</div>
<div id="outline-container-sec-10-8-4" class="outline-4">
<h4 id="sec-10-8-4"><span class="section-number-4">10.8.4</span> <i>Timed Petri Nets</i> (see e.g. Carlier et al 1984):</h4>
<div class="outline-text-4" id="text-10-8-4">
<p>
If timing information of the arrival of tokens is not merely ordinal but subject to a metric, perhaps even system wide, then it becomes possible to force tokens to "age" for a specified time before they can be removed from a place.  By endowing a transition (or a set of transitions) with a timing place to which there is (are) both output and input arcs, it becomes possible to restrict the frequency of firing of the transition (or the transitions in the set).  At this stage it is not known how well the verifier in its present form could handle any such timing information.
</p>
</div>
</div>
<div id="outline-container-sec-10-8-5" class="outline-4">
<h4 id="sec-10-8-5"><span class="section-number-4">10.8.5</span> <i>Parallelism in Paths</i>:</h4>
<div class="outline-text-4" id="text-10-8-5">
<p>
The path expressions of Netver do not include the parallel composition operator and its two special forms for interleaving and synchronisation (see Bolognesi and Brinksma 1987, or ISO 1987).  Their eventual inclusion is being contemplated, but will probably require substantial revision of the code.
</p>
</div>
</div>
<div id="outline-container-sec-10-8-6" class="outline-4">
<h4 id="sec-10-8-6"><span class="section-number-4">10.8.6</span> <i>Ports</i>:</h4>
<div class="outline-text-4" id="text-10-8-6">
<p>
A process can use a buffer to deposit information and then proceed at its own pace, and another process can eventually inspect what is in the buffer.  There is no requirement that the depositing and the inspecting occur at the same instant.  This is not true of PORTs, which are used for synchronous communication: if one of the two processes comes to the point of wanting to deposit or inspect, and the other one is not ready, then the first process has to wait.  Again it is not known whether the verifier could be adapted to handle ports.
</p>

<p>
A Pessimistic Note:
</p>

<p>
Part of the success of the current verifier depends on the fact that it uses hypermarkings instead of markings.  This works well for places having small capacities, up to, say, 31.  Then any actual marking is an integer 0 .. 31, and a hypermarking is a <code>SET OF 0..31</code>, still representable by 32 bits and easily processed.  For places containing tokens of a few kinds, there are two possibilities: either
</p>
<ol class="org-ol">
<li>treat such places as a collection of the more elementary places, or
</li>
<li>retain the principle of squeezing a hypermarking into 32 bits, by allowing up to 15 tokens of two kinds, up to 7 tokens of four kinds, up to 3 tokens of eight kinds, and only one token of sixteen kinds.
</li>
</ol>

<p>
But for places containing tokens of more than just a few kinds this method will not be possible.  Already for the type character there are too many kinds &#x2014; 128 or 256 &#x2014; and even for a maximum place capacity of only one, a hypermarking would need that many bits, seven or eight 32 bit words.  So already for character places the method of hypermarkings becomes only marginally feasible.  On the other hand, it would appear that the character type, and even more so the integer and string types are mainly needed inside buffers, queues and ports.  Typically the firing of transitions will depend not on fine detail of what is inside, but on what can be represented by a much smaller collection of kinds.  For example, if the firing of one transition depends on an integer being less that 100, and the firing of another transition depends on its being less than 10000, then as far as the verifier need be concerned there are just three kinds.
</p>
</div>
</div>
<div id="outline-container-sec-10-8-7" class="outline-4">
<h4 id="sec-10-8-7"><span class="section-number-4">10.8.7</span> <i>Reading</i>:</h4>
<div class="outline-text-4" id="text-10-8-7">
<p>
A large number of sophisticated systems somewhat similar to Netver are described in the collection edited by Sifakis (1990).
</p>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
