<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 17 : Some utilities</title>
<!-- 2013-05-31 Fri 19:10 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="author" content="michal"/>
<link rel="stylesheet" type="text/css" href="/etc/sympas/style.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Chapter 17 : Some utilities</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. </a></li>
<li><a href="#sec-2">2. Desirable utilities</a>
<ul>
<li><a href="#sec-2-1">2.1. <i>A scanner</i>:</a></li>
<li><a href="#sec-2-2">2.2. <i>Directives</i>:</a></li>
<li><a href="#sec-2-3">2.3. <i>Errors</i>:</a></li>
<li><a href="#sec-2-4">2.4. <i>Other utilities</i>:</a></li>
</ul>
</li>
<li><a href="#sec-3">3. The implementation</a>
<ul>
<li><a href="#sec-3-1">3.1. The scanner</a>
<ul>
<li><a href="#sec-3-1-1">3.1.1. <i>Single characters</i>:</a></li>
<li><a href="#sec-3-1-2">3.1.2. <i>Character strings</i>:</a></li>
<li><a href="#sec-3-1-3">3.1.3. <i>Parentheses and comments</i>:</a></li>
<li><a href="#sec-3-1-4">3.1.4. <i>Signed numbers and hyphens</i>:</a></li>
<li><a href="#sec-3-1-5">3.1.5. <i>Numbers in alternative radix</i>:</a></li>
<li><a href="#sec-3-1-6">3.1.6. <i>Identifiers</i>:</a></li>
<li><a href="#sec-3-1-7">3.1.7. <i>Directives</i>:</a></li>
<li><a href="#sec-3-1-8">3.1.8. <i>Other cases</i>:</a></li>
<li><a href="#sec-3-1-9">3.1.9. <i>Procedure getch</i>:</a></li>
<li><a href="#sec-3-1-10">3.1.10. <i>Function value</i>:</a></li>
<li><a href="#sec-3-1-11">3.1.11. <i>Procedure directive</i>:</a></li>
</ul>
</li>
<li><a href="#sec-3-2">3.2. Error reporting</a></li>
<li><a href="#sec-3-3">3.3. Other Utilities</a></li>
<li><a href="#sec-3-4">3.4. <i>Initialisation</i>:</a></li>
<li><a href="#sec-3-5">3.5. <i>Parsing</i>:</a></li>
<li><a href="#sec-3-6">3.6. <i>Output</i>:</a></li>
</ul>
</li>
<li><a href="#sec-4">4. The program</a></li>
<li><a href="#sec-5">5. Remarks and a major project</a></li>
<li><a href="#sec-6">6. <i>A Major Project</i>:</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> <a id="intro" name="intro"></a></h2>
<div class="outline-text-2" id="text-1">
<p>
In previous chapters we have seen a variety of utility procedures for initialising symbol tables, for reading numbers, identifiers and special characters, for reporting errors and for other purposes.  To keep the programs short, only minimal utilities were provided.  In no two programs were the utilities sufficiently large <i>and</i> sufficiently complex to warrant collecting them in a common library of utilities.  The payoff becomes different when the utilities are large and useful in several different programs.  In fact, one may taylor the programs to use as many portions of the utilities as possible, and to accept that some portions will not be used.  This is the approach we shall use in the remainder of this book.  In this chapter we design and implement some general utilities, in the remaining chapters we use them.
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Desirable utilities</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> <i>A scanner</i>:</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The core of the utilities is a scanner, a procedure which reads characters from the input file, assembles short groups of them into symbols such as numbers in decimal or other notation, quoted single characters, quoted strings of characters, identifiers, reserved words and sequences of special characters such as punctuation and other symbols.  Reserved words and sequences of special symbols should be looked up in a table; identifiers should not be looked up because the required details are likely to vary in different applications.  The scanner must also handle comments.
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> <i>Directives</i>:</h3>
<div class="outline-text-3" id="text-2-2">
<p>
For many purposes it is useful to let the scanner handle directives.  These are special purpose instructions to the scanner to affect its behaviour.  They are not passed on to the parser, indeed as far as the parser is concerned they are invisible just like comments.  One important directive is the <code>INCLUDE</code> directive which tells the scanner to suspend reading from the input file and to start reading from another.  When the end of that file is reached, reading resumes from the previous file.  It should be possible to nest such inclusions.  Also useful is a <code>LISTING</code> directive which can set an internal variable so that any input is copied to a listing file and any output goes not only to the output file but is also copied to the listing file.  In special cases one might want the listing file to contain debugging information, so it is desirable to have levels of listing.  As in any programming language, a conditional <code>IF</code> directive can be useful.  The kind chosen here is the simplest, it applies only to lines in the input file.  When the <code>IF</code> part evaluates to true, the remainder of the input line is processed, otherwise it is skipped.  A collection of variables <code>A .. Z</code> can have integer values assigned to them with the <code>SET</code> directive.  For numbers in alternative notation, the radix can be set to any value between 2 and 36 inclusive.
</p>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> <i>Errors</i>:</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Any error messages should in the first place go to the output file, which may be the user terminal or a disk file.  But, if a listing is being produced, error messages should also go to the listing file.  It is best if error messages actually point to where in the input line the error occurred.  So, for errors reported to the output file, the input line should be repeated and a pointer placed under the position of the error.  In the listing file the line should not be repeated if it is the first error in that line.  However, for second and later errors in the same line it is more informative if the line is repeated in the output file and the listing file.  In the listing file all lines that are copied from the input should be given line numbers, and all error reports should give the offending line together with its line number.
</p>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> <i>Other utilities</i>:</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Any program that uses the scanner will have to enter reserved words into a table; it is useful to include a procedure which enters one reserved word per call (and checks for overflow).  A similar procedure is useful for user declared identifiers.  Programs that make use of the utilities should not have to bother about the listing file.  Any output should be handled by the utilities, writing to the output file and, if necessary, to the listing file.
</p>

<p>
To make the utilities flexible, some declarations have to occur before the file of utilities can be read in.  These declarations are specific to the particular use to which the utilities are being put.  Hence these declarations have to occur in the program which uses the utilities, before the utilities file is being included.  The details should be apparent in the programs in the next three chapters.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> The implementation</h2>
<div class="outline-text-2" id="text-3">
<p>
Many of the names or identifiers are similar to those in PLZERO of Wirth (1976) and Wirth's PASCALS decribed in Berry(1982).
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> The scanner</h3>
<div class="outline-text-3" id="text-3-1">
<p>
By far the largest procedure is the scanner, procedure <code>getsym</code>.  It reads characters from the current input file and assembles them into symbols.  The reading is actually done by a local procedure <code>getch</code> which is described below.  Procedure <code>getsym</code> begins by skipping any non-printing characters and then uses a <code>CASE</code> statement to dispatch on the current character in the global variable <code>ch</code>.  Some of the cases are familiar from previous programs.  Each of the cases assigns a value to the global variable <code>sym</code> which is of the enumeration type symbol.  Some of the cases also assign an integer value to the global variable num.  These two variables constitute the principal output of the scanner.
</p>
</div>

<div id="outline-container-sec-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> <i>Single characters</i>:</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
If <code>ch</code> is a single quote character, then this signals a character constant.  Following the quote is normally an ordinary character, and then the global variable <code>num</code> is set to the ordinal value of that character.  However, if the character following is the backslash <code>\</code>, then the ordinal value returned in variable <code>num</code> is given by a numeric scan-time expression.  In most cases this will be a literal number, for example ='\65= is equivalent to ='A=.  However, following the backslash can be an expression computed at scan-time by a local function <code>value</code> described below.
</p>
</div>
</div>
<div id="outline-container-sec-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> <i>Character strings</i>:</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
If <code>ch</code> is a double quote character, then what is being read is a string constant.  While the next character is not the terminating double quote character, further characters are read and stored in a large array of characters which is made to hold all strings that are read.  The start position of the current string is recorded in a further integer array of starting positions, and the next value in this array gives the starting position of the next string that will be read.  The index in this integer array is assigned to the global variable num.  Hence the length and content of the currently read string can be determined by using the value of <code>num</code> and <code>num+1</code> as indices into the integer array.  The values recorded there can then be used to retrieve the string from the large character array.  This part of the scanner is not being used in the three programs in this book which use the utilities, but it has been used elsewhere.
</p>
</div>
</div>
<div id="outline-container-sec-3-1-3" class="outline-4">
<h4 id="sec-3-1-3"><span class="section-number-4">3.1.3</span> <i>Parentheses and comments</i>:</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
These are handled as in previous programs: <code>(*</code> signals a comment and causes skipping up to the closing <code>*)</code> and a <code>GOTO</code> the beginning of the scanner.  A left parenthesis character without a following asterisk is just a parenthesis symbol.
</p>
</div>
</div>
<div id="outline-container-sec-3-1-4" class="outline-4">
<h4 id="sec-3-1-4"><span class="section-number-4">3.1.4</span> <i>Signed numbers and hyphens</i>:</h4>
<div class="outline-text-4" id="text-3-1-4">
<p>
If <code>ch</code> is a decimal digit character or a hyphen <code>-</code>, then the symbol is either just the hyphen symbol in case it is not followed by digits, or it is a negative number in case it is followed by digits, or it is a positive number in case there is no preceding <code>-</code>.  So, if there is no leading <code>-</code>, then the number being read is not to be negated, and a Boolean flag is set to that effect.  Otherwise the flag is set to eventually negate the number being read, if indeed there is one.  If there are no digits immediately after the <code>-</code>, then the symbol is just a hyphen, and a <code>GOTO</code> the end of the scanner is effected.  Otherwise a string of decimal digits is read as normal, and the number is possibly negated.
</p>
</div>
</div>
<div id="outline-container-sec-3-1-5" class="outline-4">
<h4 id="sec-3-1-5"><span class="section-number-4">3.1.5</span> <i>Numbers in alternative radix</i>:</h4>
<div class="outline-text-4" id="text-3-1-5">
<p>
For some purposes it is useful to be able to read numbers in other than decimal notation but in a different radix.  Such numerals are signalled by a leading <code>&amp;</code>.  The default alternative radix is 2, but it can be set by a directive <code>%RADIX N</code>, where N is a scan-time expression whose value is between 2 and 36 inclusive.  Digits beyond <code>9</code> are taken to be <code>A</code> .. <code>Z</code>; so hexadecimal uses <code>A</code> .. <code>F</code>.  Reading successive digits is very similar to reading decimal notation, instead of multiplying values by 10 they have to be multiplied by the alternative radix.  A minor complication arises because in ASCII the character sequence <code>0</code> ..=9= is not immediately followed by <code>A</code> .. <code>Z</code>, there is a gap which has to be taken care of.  If a digit exceeds the maximum allowed for the current radix, then an error has to be signalled.
</p>
</div>
</div>
<div id="outline-container-sec-3-1-6" class="outline-4">
<h4 id="sec-3-1-6"><span class="section-number-4">3.1.6</span> <i>Identifiers</i>:</h4>
<div class="outline-text-4" id="text-3-1-6">
<p>
If <code>ch</code> is a lowercase letter, the symbol being read is an identifier.  The letter and any further lowercase letters, digits and underscores are collected into a short variable of type ident which are strings whose length is determined by a <code>CONST</code> defined in the program which includes the utilities.  No lookup is performed.
</p>
</div>
</div>
<div id="outline-container-sec-3-1-7" class="outline-4">
<h4 id="sec-3-1-7"><span class="section-number-4">3.1.7</span> <i>Directives</i>:</h4>
<div class="outline-text-4" id="text-3-1-7">
<p>
If <code>ch</code> is a <code>%</code>, then procedure <code>directive</code> is called, see below.
</p>
</div>
</div>
<div id="outline-container-sec-3-1-8" class="outline-4">
<h4 id="sec-3-1-8"><span class="section-number-4">3.1.8</span> <i>Other cases</i>:</h4>
<div class="outline-text-4" id="text-3-1-8">
<p>
If <code>ch</code> is anything else, a catch-all case is entered.  If <code>ch</code> is an uppercase letter, then it and any further letters, digits and underscores are collected into a string.  If <code>ch</code> is any other special character, then it together with any further special characters that are likely to occur as further characters in combinations such as <code>:=</code>, <code>&lt;=</code> or <code>..</code> are collected into a string.  The string starting with an uppercase letter or a special character is then used to search a table of reserved words.  If it is found there, then the variable <code>sym</code> is set to what is recorded in the table, otherwise it is treated just like an identifier starting with a lowercase letter.  The various directives have been implemented as a cascade of <code>IF-THEN-ELSE-IF..</code> statements in Pascal.  It would have been possible and more efficient to use a binary search through a table of directives.  However, directives do not occur often, hence their efficiency is a minor issue.  The method used here is just a little simpler to implement.
</p>

<p>
This completes the cases of the body of the scanner.  There are three routines local to the scanner: a procedure for obtaining the next character, a function for computing values of scan-time expressions, and a procedure for executing directives.
</p>
</div>
</div>
<div id="outline-container-sec-3-1-9" class="outline-4">
<h4 id="sec-3-1-9"><span class="section-number-4">3.1.9</span> <i>Procedure getch</i>:</h4>
<div class="outline-text-4" id="text-3-1-9">
<p>
The scanner <code>getsym</code> does not read the input file directly but obtains the next character from a procedure which deposits a new character in a global variable <code>ch</code>.  Because error messages to the output file should point to the position in the current input line, it is necessary to retain all of the current input line in a global string buffer.  Two global integer variables are made to point into this buffer, one records the total length, the other the current position.  Procedure <code>getch</code> starts by examining whether the buffer is empty.  This will be true if the current position is equal to the total length.  If it is, a new line will have to be read into the buffer.  But first an adjustment might have to be made to the current line number in case the immediately preceding directive was an <code>INCLUDE</code> directive, or in case the preceding line was the last line in an included file.  In the first case the line number is set to zero.  In the second case it has to be set back to what it was in the file containing the <code>INCLUDE</code> directive which originally caused the inclusion.  Because inclusions can be nested, a small global stack is used for names of included files, the last line number in the file, and, most importantly, the file variable itself.  Only after this adjustment can the line number be incremented, and buffer length and position be set to zero.  The line buffer is then filled from the current input file, but the details vary depending on whether this is the initial input file or an included file.  If the stack of included files is empty, the reading occurs from the initial input file.  If the end of file has been reached, an error is signalled.  Otherwise characters are read into the line buffer until the end of line is encountered.  On the other hand, if the stack of included files is not empty, then reading occurs from the current included file.  No error is reported if the end of that file is reached.  But if after the line has been read the end of file is reached, then the included file is closed and the adjustment flag is set to pop the stack of included files when the next line is read.  This concludes the steps that have to be taken when <code>getch</code> finds the line buffer empty.  At any rate, the line buffer will not be empty now.  The current position is incremented, and <code>ch</code> is assigned the character value from the buffer at the current position.
</p>
</div>
</div>
<div id="outline-container-sec-3-1-10" class="outline-4">
<h4 id="sec-3-1-10"><span class="section-number-4">3.1.10</span> <i>Function value</i>:</h4>
<div class="outline-text-4" id="text-3-1-10">
<p>
This function computes integer values of scan-time expressions written in prefix notation.  It is called by the scanner when handling the backslash <code>\</code> in character constants and string constants, and by the procedure which handles directives.  The function calls <code>getch</code> until <code>ch</code> is a printing character.  If it is a character that can start a number or a single character, then it calls <code>getsym</code> recursively and returns whatever <code>getsym</code> deposits in the global variable num.  If the character is an uppercase letter, then it returns the value retrieved from an array of integer values that would have been assigned there by a previous <code>SET</code> directive.  Parentheses can be used for readability, but are not necessary for prefix notation.  The special characters <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> have their obvious meaning as binary arithmetic operators, they result in two recursive calls to the function and then a computation of the value.  The characters <code>=</code>, <code>&gt;</code> and <code>&lt;</code> are interpreted as relational operators returning 1 or 0 for true and false.  Finally, <code>?</code> causes a number to be read from the input file.  Any other character produces an error.
</p>
</div>
</div>
<div id="outline-container-sec-3-1-11" class="outline-4">
<h4 id="sec-3-1-11"><span class="section-number-4">3.1.11</span> <i>Procedure directive</i>:</h4>
<div class="outline-text-4" id="text-3-1-11">
<p>
This procedure is called from one case in the scanner when it sees the character <code>%</code>; since the procedure is only called there its body might have been incorporated there.  The procedure reads letters into a string and then examines the string.  For the IF directive the function <code>value</code> is called, if that returns a value less than 1, the remainder of the current input line is to be skipped.  This is done by setting the position variable of the line buffer to the length of the line buffer &#x2014; this will cause procedure <code>getch</code> to read from a new line.  For the <code>SET</code> directive the expected syntax is <code>%SET V = value</code>, where <code>V</code> is an uppercase letter.  Errors occur when <code>V</code> is not an uppercase letter or when <code>=</code> is missing.  Function <code>value</code> is called to assign an integer to the array of scan-time variables at position <code>V</code>.  For the PUT directive the remainder of the input line is copied from the line buffer to the output file &#x2014; this is useful only if the input comes from a disk file.  The other three directives, <code>LISTING</code>, <code>STATISTICS</code> and <code>RADIX</code> simply set global variables to an integer returned by the function <code>value</code>.
</p>

<p>
This completes the scanning procedure <code>getsym</code>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Error reporting</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The procedure for reporting errors takes two value parameters: a single character and a string.  The single character serves to indicate the kind of error, the string is the actual error message.  The procedure has to write the position in the input line where the error occurred, and then, on a separate line, an error mark that is defined as a (short) string constant in the program which uses the utilities, then the character indicating the kind of error, and then the error message.  All this has to be written to the output file, and, if a listing is being written, to the listing file.
</p>

<p>
Several complications arise.  Firstly, the line which contains the error can be in an included file.  In that case it is not informative if the line number given is simply the ordinal number of the line that has been processed.  Instead it is better if the error report states the name of the file and the line number in terms of that file.  Secondly, in the listing file it is not necessary to repeat an input line if the current error is the first error in that line.  So the scanning procedure <code>getsym</code> and the error reporting procedure have to cooperate in a number of ways.  It is necessary to keep track of line numbers and names of included files.  This is done by the small explicit global stack already mentioned in the description of procedure <code>getch</code>.
</p>

<p>
The body of the error reporting procedure increments the global error count in all cases except when the character parameter is an <code>I</code>, indicating a merely informational message.  Programs using the utilities can access the error count for reporting, and they can set it back to zero.  Then the procedure handles any writing to the output file, and any writing to the listing file.  For the output file, if the error occurs in an include file, this is indicated by a remark and the name of the include file.  Then the procedure calls a local procedure <code>point_to_symbol</code> to do the actual error reporting to the output file.  If a listing is being produced, that same local procedure is called again, this time to report to the listing file.
</p>

<p>
The local procedure takes a file variable as formal parameter.  It does all its writing to that file.  A second Boolean value parameter indicates whether the current input line is to be repeated.  If it is, then the current line number, the separator between line numbers and text, and then the line buffer are written as one line to the parameter file.  In any case, for the next line it writes firstly a mark under the previous line number, secondly sufficient spaces to reach the error position in the input line, and thirdly the pointer <code>^</code>.  On the following line it writes the error mark, the character indicating the kind of error, and the actual error message.
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Other Utilities</h3>
<div class="outline-text-3" id="text-3-3">
<p>
All the other utilities are relatively minor.
</p>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> <i>Initialisation</i>:</h3>
<div class="outline-text-3" id="text-3-4">
<p>
There is one procedure to initialise all the global variables used by the utilities; most of them are integers that have to be set to zero.  A program which uses the utilities would normally begin by calling this initialisation procedure.  Such a program might then re-assign some of these variables, for example the default alternative radix or the set of special characters that can occur in second or later positions in reserved words such as <code>&lt;=</code> and <code>::=</code>.  There are two procedures for entering reserved words and standard identifiers into tables.  The sizes of these tables are given by constants in the program that uses the utilities, and the two procedures will check for overflow and produce appropriate error messages.  A program which uses the utilities would call the entering procedures once for each reserved word or identifier that is to be entered.  The scanner will know about the last reserved word that has been entered, and it will perform the lookup correctly even if the table is not filled completely.  No lookup is performed for standard identifiers and no such procedure is provided; this is because the method that is required is likely to vary widely between applications.
</p>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> <i>Parsing</i>:</h3>
<div class="outline-text-3" id="text-3-5">
<p>
To facilitate parsing there are two procedures.  One checks whether the last symbol returned by the scanner is identical with one of its parameters, otherwise an error is reported using a string parameter as the message.  The other tests whether the last symbol is a member of one of its parameters, a set of symbols.  If it is not, then an error is reported and symbols are skipped until the symbol is in the first set or in another set that is a further parameter.
</p>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> <i>Output</i>:</h3>
<div class="outline-text-3" id="text-3-6">
<p>
There are three principal output procedures.  One is for writing signed integers, internally it uses a recursive procedure to convert an integer into a sequence of digit characters.  The other two write strings of the size of reserved words and standard identifiers; since these may have different lengths, separate procedures are used.  All three first check whether the item to be written really fits onto the line, and if it does not fit, then a subsidiary procedure for ending a line is called first.  This procedure will do a writeln to the output file, and, if a listing is being written, to the listing file.  It also sets a variable to keep track of the length of the output line.  The three principal procedures output characters by calling another subsidiary procedure for writing a single character.  This writes the character to the output file.  If a listing is being produced, it also writes the character to the listing file; but if a new line had just been started it first writes to the listing file as many spaces as there are in a line number and the separator between the line number and the following text.  It also increments the counter which keeps track of the length of the output line &#x2014; except that if the character to be written is the newline character, <code>chr(13)</code>, it sets the counter to zero.  One last output utility, used for finalising a run, writes to the output file and potentially to the listing file the CPU time in milliseconds taken by this run.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> The program</h2>
<div class="outline-text-2" id="text-4">
<p>
The following is the standard Pascal source program for the utilities.
</p>

<div class="org-src-container">

<pre class="src src-pascal"><span style="color: #66f;">(* </span><span style="color: #66f;">File: Included file for scan utilities *)</span>
<span style="color: #ff00ff;">VAR</span> listing : text;

<span style="color: #ff00ff;">CONST</span>

maxincludelevel = 5;
maxlinelength = 132;
linenumwidth = 4; linenumspace = <span style="color: #00ff00;">'    '</span>;
linenumsep = <span style="color: #00ff00;">'    '</span>;
underliner = <span style="color: #00ff00;">'****    '</span>;
tab_in_listing = <span style="color: #00ff00;">'    ----    '</span>;
maxoutlinelength = 60;
messagelength = 30;

initial_alternative_radix = 2;

maxchartab = 1000;
maxstringtab = 100;
maxnodtab = 1000;

<span style="color: #ff00ff;">TYPE</span>

identalfa = <span style="color: #ff00ff;">PACKED</span> <span style="color: #ff00ff;">ARRAY</span> [1..identlength] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;
resalfa = <span style="color: #ff00ff;">PACKED</span> <span style="color: #ff00ff;">ARRAY</span> [1..reslength] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;
<span style="color: #00ffff;">message</span> = <span style="color: #ff00ff;">PACKED</span> <span style="color: #ff00ff;">ARRAY</span> [1 .. messagelength] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;
toops = <span style="color: #ff00ff;">RECORD</span> symbols,types,strings,chars : <span style="color: #ff00ff;">integer</span> <span style="color: #00ffff;">END</span>;
symset = <span style="color: #ff00ff;">SET</span> <span style="color: #00ffff;">OF</span> symbol;

<span style="color: #ff00ff;">VAR</span>

inputs : <span style="color: #ff00ff;">ARRAY</span> [1..maxincludelevel] <span style="color: #00ffff;">OF</span>
    <span style="color: #ff00ff;">RECORD</span> fil : text; nam : identalfa; lastlinenumber : <span style="color: #ff00ff;">integer</span> <span style="color: #00ffff;">END</span>;
includelevel,adjustment : <span style="color: #ff00ff;">integer</span>;
writelisting : <span style="color: #ff00ff;">integer</span>;
must_repeat_line : <span style="color: #ff00ff;">boolean</span>;

scantimevariables : <span style="color: #ff00ff;">ARRAY</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">integer</span>;
alternative_radix : <span style="color: #ff00ff;">integer</span>;
linenumber : <span style="color: #ff00ff;">integer</span>;
line : <span style="color: #ff00ff;">ARRAY</span> [1..maxlinelength] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;
cc,ll : <span style="color: #ff00ff;">integer</span>;
ch : <span style="color: #ff00ff;">char</span>;
ident : identalfa;
id : standardident;
res : resalfa;
specials_repeat : <span style="color: #ff00ff;">SET</span> <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;
sym : symbol;
num : <span style="color: #ff00ff;">integer</span>;
reswords : <span style="color: #ff00ff;">ARRAY</span> [1..maxrestab] <span style="color: #00ffff;">OF</span>
    <span style="color: #ff00ff;">RECORD</span> alf : resalfa; symb : symbol <span style="color: #00ffff;">END</span>;
lastresword : <span style="color: #ff00ff;">integer</span>;
stdidents : <span style="color: #ff00ff;">ARRAY</span> [1..maxstdidenttab] <span style="color: #00ffff;">OF</span>
    <span style="color: #ff00ff;">RECORD</span> alf : identalfa; symb : standardident <span style="color: #00ffff;">END</span>;
laststdident : <span style="color: #ff00ff;">integer</span>;
resword_inverse : <span style="color: #ff00ff;">ARRAY</span> [symbol] <span style="color: #00ffff;">OF</span> 0..maxrestab;
trace : <span style="color: #ff00ff;">integer</span>;
stringtab : <span style="color: #ff00ff;">ARRAY</span> [1..maxstringtab] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">integer</span>;
chartab : <span style="color: #ff00ff;">PACKED</span> <span style="color: #ff00ff;">ARRAY</span> [1..maxchartab] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;

toop : toops;

errorcount : <span style="color: #ff00ff;">integer</span>;
outlinelength : <span style="color: #ff00ff;">integer</span>;
statistics : <span style="color: #ff00ff;">integer</span>;
start_clock : <span style="color: #ff00ff;">integer</span>;

<span style="color: #66f;">(* </span><span style="color: #66f;">- - - - -   MODULE ERROR    - - - - - *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">point</span>(diag : <span style="color: #ff00ff;">char</span>; mes : <span style="color: #00ffff;">message</span>);

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">point_to_symbol</span>(repeatline : <span style="color: #ff00ff;">boolean</span>; <span style="color: #ff00ff;">VAR</span> f : text);
    <span style="color: #ff00ff;">VAR</span> i : <span style="color: #ff00ff;">integer</span>; c : <span style="color: #ff00ff;">char</span>;
    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">point_to_symbol *)</span>
    <span style="color: #00ffff;">IF</span> repeatline <span style="color: #00ffff;">THEN</span>
        <span style="color: #00ffff;">BEGIN</span>
        <span style="color: #00ffff;">write</span>(f,linenumber:linenumwidth,linenumsep);
        <span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> ll <span style="color: #00ffff;">DO</span> <span style="color: #00ffff;">write</span>(f,line[i]); writeln(f);
        <span style="color: #00ffff;">END</span>;
    <span style="color: #00ffff;">write</span>(f,underliner);
    <span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> cc - 2 <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">BEGIN</span>
        c := line[i];
        <span style="color: #00ffff;">IF</span> c &lt; <span style="color: #00ff00;">' '</span>  <span style="color: #00ffff;">THEN</span> <span style="color: #00ffff;">write</span>(f,c) <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">write</span>(f,<span style="color: #00ff00;">' '</span>)
        <span style="color: #00ffff;">END</span>;
    writeln(f,<span style="color: #00ff00;">'^ '</span>);
    writeln(f,errormark,<span style="color: #00ff00;">'-'</span>,diag,<span style="color: #00ff00;">'  '</span>,mes);
    <span style="color: #00ffff;">IF</span> diag = <span style="color: #00ff00;">'F'</span> <span style="color: #00ffff;">THEN</span> writeln(f,<span style="color: #00ff00;">'execution aborted'</span>)
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">point_to_symbol *)</span>

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">point *)</span>
<span style="color: #00ffff;">IF</span> diag &lt;&gt; <span style="color: #00ff00;">'I'</span> <span style="color: #00ffff;">THEN</span> errorcount := errorcount + 1;
<span style="color: #00ffff;">IF</span> includelevel &gt; 0 <span style="color: #00ffff;">THEN</span>
    writeln(output,<span style="color: #00ff00;">'INCLUDE file : "'</span>,inputs[includelevel].nam,<span style="color: #00ff00;">'"'</span>);
point_to_symbol(true,output);
<span style="color: #00ffff;">IF</span> writelisting &gt; 0 <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span>
    point_to_symbol(must_repeat_line,listing);
    must_repeat_line := true
    <span style="color: #00ffff;">END</span>;
<span style="color: #00ffff;">IF</span> diag = <span style="color: #00ff00;">'F'</span> <span style="color: #00ffff;">THEN</span> <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">99</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">point *)</span>

<span style="color: #66f;">(* </span><span style="color: #66f;">- - - - -   MODULE SCANNER    - - - - - *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">iniscanner</span>;
<span style="color: #ff00ff;">VAR</span> c : <span style="color: #ff00ff;">char</span>;
<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">iniscanner *)</span>
start_clock := clock;
open(listing,list_filename,NEW);
rewrite(listing);
writelisting := 0;
ch := <span style="color: #00ff00;">' '</span>; linenumber := 0;
cc := 1; ll := 1; <span style="color: #66f;">(* </span><span style="color: #66f;">to enable fatal message during initialisation *)</span>
specials_repeat := []; <span style="color: #66f;">(* </span><span style="color: #66f;">default: no repeats *)</span>
includelevel := 0; adjustment := 0;
alternative_radix := initial_alternative_radix;
lastresword := 0;
laststdident := 0;
outlinelength := 0;
<span style="color: #00ffff;">FOR</span> c := <span style="color: #00ff00;">'A'</span> <span style="color: #00ffff;">TO</span> <span style="color: #00ff00;">'Z'</span> <span style="color: #00ffff;">DO</span> scantimevariables[c] := 0;
errorcount := 0;
must_repeat_line := false;
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">iniscanner *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">erw</span>(a : resalfa; s : symbol);
<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">erw *)</span>
lastresword := lastresword + 1;
<span style="color: #00ffff;">IF</span> lastresword &gt; maxrestab <span style="color: #00ffff;">THEN</span>
    point(<span style="color: #00ff00;">'F'</span>,<span style="color: #00ff00;">'too many reserved words       '</span>);
<span style="color: #00ffff;">WITH</span> reswords[lastresword] <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">BEGIN</span> alf := a; symb := s <span style="color: #00ffff;">END</span>;
resword_inverse[s] := lastresword
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">erw *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">est</span>(a : identalfa; s : standardident);
<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">est *)</span>
laststdident := laststdident + 1;
<span style="color: #00ffff;">IF</span> laststdident &gt; maxstdidenttab <span style="color: #00ffff;">THEN</span>
    point(<span style="color: #00ff00;">'F'</span>,<span style="color: #00ff00;">'too many identifiers          '</span>);
<span style="color: #00ffff;">WITH</span> stdidents[laststdident] <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">BEGIN</span> alf := a; symb := s <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">est *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">newfile</span>(a : identalfa);
<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">newfile *)</span>
<span style="color: #00ffff;">WITH</span> inputs[includelevel + 1] <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">BEGIN</span>
        nam := a;
        lastlinenumber := linenumber;
<span style="color: #66f;">(* </span><span style="color: #66f;">PYRAMID-UNIX:</span>
<span style="color: #66f;">                reset(fil,a)</span>
<span style="color: #66f;">     VAX-VMS:</span>
<span style="color: #66f;">                open(fil,a,OLD);</span>
<span style="color: #66f;">                reset(fil)</span>
<span style="color: #66f;">*)</span>
                open(fil,a,OLD);
                reset(fil)
                <span style="color: #00ffff;">END</span>;
adjustment := 1;
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">newfile *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">endfile</span>;
<span style="color: #00ffff;">BEGIN</span> cc := ll; adjustment := -1 <span style="color: #00ffff;">END</span>;

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">getsym</span>;
LABEL 1,9;
<span style="color: #ff00ff;">VAR</span> i,j,k : <span style="color: #ff00ff;">integer</span>; c0 : <span style="color: #ff00ff;">char</span>; negated : <span style="color: #ff00ff;">boolean</span>;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">perhapslisting</span>;
    <span style="color: #ff00ff;">VAR</span> i : <span style="color: #ff00ff;">integer</span>;
    <span style="color: #00ffff;">BEGIN</span>
    <span style="color: #00ffff;">IF</span> writelisting &gt; 0 <span style="color: #00ffff;">THEN</span>
        <span style="color: #00ffff;">BEGIN</span>
        <span style="color: #00ffff;">write</span>(listing,linenumber:linenumwidth,linenumsep);
        <span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> ll <span style="color: #00ffff;">DO</span> <span style="color: #00ffff;">write</span>(listing,line[i]);
        writeln(listing);
        must_repeat_line := false
        <span style="color: #00ffff;">END</span>
    <span style="color: #00ffff;">END</span>;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">getch</span>;
    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">getch *)</span>
    <span style="color: #00ffff;">IF</span> cc = ll <span style="color: #00ffff;">THEN</span>
        <span style="color: #00ffff;">BEGIN</span>
        <span style="color: #00ffff;">IF</span> adjustment &lt;&gt; 0 <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            <span style="color: #00ffff;">IF</span> adjustment = -1
                <span style="color: #00ffff;">THEN</span> linenumber := inputs[includelevel].lastlinenumber
                <span style="color: #00ffff;">ELSE</span> linenumber := 0;
            includelevel := includelevel + adjustment; adjustment := 0
            <span style="color: #00ffff;">END</span>;
        linenumber := linenumber + 1;
        ll := 0; cc := 0;
        <span style="color: #00ffff;">IF</span> includelevel = 0 <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            <span style="color: #00ffff;">IF</span> eof(input) <span style="color: #00ffff;">THEN</span>
                point(<span style="color: #00ff00;">'F'</span>,<span style="color: #00ff00;">'unexpected end of file        '</span>);
            <span style="color: #00ffff;">WHILE</span> <span style="color: #00ffff;">NOT</span> eoln(input) <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">BEGIN</span>
                ll := ll + 1;
                <span style="color: #00ffff;">read</span>(input,ch);
                line[ll] := ch
                <span style="color: #00ffff;">end</span>;
            perhapslisting;
            ll := ll + 1; <span style="color: #00ffff;">read</span>(input,line[ll])
            <span style="color: #00ffff;">END</span>
        <span style="color: #00ffff;">ELSE</span>
            <span style="color: #00ffff;">WITH</span> inputs[includelevel] <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">BEGIN</span>
                <span style="color: #00ffff;">WHILE</span> <span style="color: #00ffff;">NOT</span> eoln(fil) <span style="color: #00ffff;">DO</span>
                    <span style="color: #00ffff;">BEGIN</span>
                    ll := ll + 1;
                    <span style="color: #00ffff;">read</span>(fil,ch);
                    line[ll] := ch
                    <span style="color: #00ffff;">END</span>;
                perhapslisting;
                ll := ll + 1; <span style="color: #00ffff;">read</span>(fil,line[ll]);
                <span style="color: #00ffff;">IF</span> eof(fil) <span style="color: #00ffff;">THEN</span>
                    <span style="color: #00ffff;">BEGIN</span> close(fil); adjustment := -1 <span style="color: #00ffff;">END</span>;
                <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">WITH *)</span>
        <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">IF *)</span>
    cc := cc + 1; ch := line[cc]
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">getch *)</span>

    <span style="color: #00ffff;">FUNCTION</span> <span style="color: #ffffff; font-weight: bold;">value</span> : <span style="color: #ff00ff;">integer</span>;
    <span style="color: #66f;">(* </span><span style="color: #66f;">this is a  LL(0)  parser *)</span>
    <span style="color: #ff00ff;">VAR</span> k,v : <span style="color: #ff00ff;">integer</span>;
    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">value *)</span>
    <span style="color: #00ffff;">REPEAT</span> getch <span style="color: #00ffff;">UNTIL</span> ch &gt; <span style="color: #00ff00;">' '</span>;
    <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'&amp;'</span>,<span style="color: #00ff00;">'0'</span>..<span style="color: #00ff00;">'9'</span>,<span style="color: #00ff00;">''''</span>] <span style="color: #00ffff;">THEN</span>
        <span style="color: #00ffff;">BEGIN</span> getsym; value := num <span style="color: #00ffff;">END</span>
    <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>] <span style="color: #00ffff;">THEN</span>
        value := scantimevariables[ch]
    <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> ch = <span style="color: #00ff00;">'('</span> <span style="color: #00ffff;">THEN</span>
        <span style="color: #00ffff;">BEGIN</span>
        value := value;
        <span style="color: #00ffff;">WHILE</span> ch &lt;= <span style="color: #00ff00;">' '</span> <span style="color: #00ffff;">DO</span> getch;
        <span style="color: #00ffff;">IF</span> ch = <span style="color: #00ff00;">')'</span> <span style="color: #00ffff;">THEN</span> getch <span style="color: #00ffff;">ELSE</span>
            point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'right parenthesis expected    '</span>);
        <span style="color: #00ffff;">END</span>
    <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">CASE</span> ch <span style="color: #00ffff;">OF</span>
        <span style="color: #00ff00;">'+'</span> : value := value + value;
        <span style="color: #00ff00;">'-'</span> : value := value - value;
        <span style="color: #00ff00;">'*'</span> : value := value * value;
        <span style="color: #00ff00;">'/'</span> : value := value <span style="color: #00ffff;">DIV</span> value;
        <span style="color: #00ff00;">'='</span> : value := ord(value = value);
        <span style="color: #00ff00;">'&gt;'</span> : value := ord(value &gt; value);
        <span style="color: #00ff00;">'&lt;'</span> : value := ord(value &lt; value);
        <span style="color: #00ff00;">'?'</span> : <span style="color: #00ffff;">BEGIN</span> <span style="color: #00ffff;">read</span>(v); value := v <span style="color: #00ffff;">END</span>
        OTHERWISE
            point(<span style="color: #00ff00;">'F'</span>,<span style="color: #00ff00;">'illegal start of scan expr    '</span>)
        <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">value *)</span>

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">directive</span>;
    <span style="color: #ff00ff;">CONST</span>
        emptydir = <span style="color: #00ff00;">'                '</span>; dirlength = 16;
    <span style="color: #ff00ff;">VAR</span>
        c : <span style="color: #ff00ff;">char</span>; i : <span style="color: #ff00ff;">integer</span>;
        dir : <span style="color: #ff00ff;">PACKED</span> <span style="color: #ff00ff;">ARRAY</span> [1 .. dirlength] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;
    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">directive *)</span>
    getch; i := 0; dir := emptydir;
    <span style="color: #00ffff;">REPEAT</span>
        <span style="color: #00ffff;">IF</span> i &lt; dirlength <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span> i := i + 1; dir[i] := ch <span style="color: #00ffff;">END</span>;
        getch
        <span style="color: #00ffff;">UNTIL</span> <span style="color: #00ffff;">NOT</span> (ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>,<span style="color: #00ff00;">'_'</span>]);
    <span style="color: #00ffff;">IF</span> dir = <span style="color: #00ff00;">'IF            '</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span> <span style="color: #00ffff;">IF</span> value &lt; 1 <span style="color: #00ffff;">THEN</span> cc := ll <span style="color: #66f;">(* </span><span style="color: #66f;">readln *)</span> <span style="color: #00ffff;">END</span>
    <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> dir = <span style="color: #00ff00;">'INCLUDE         '</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            <span style="color: #00ffff;">IF</span> includelevel = maxincludelevel <span style="color: #00ffff;">THEN</span>
                point(<span style="color: #00ff00;">'F'</span>,<span style="color: #00ff00;">'too many include files        '</span>);
            <span style="color: #00ffff;">WHILE</span> ch &lt;= <span style="color: #00ff00;">' '</span>  <span style="color: #00ffff;">DO</span> getch;
            k := 0; ident := emptyident;
            <span style="color: #00ffff;">REPEAT</span>
                <span style="color: #00ffff;">IF</span> k &lt; identlength <span style="color: #00ffff;">THEN</span>
                    <span style="color: #00ffff;">BEGIN</span> k := k + 1; ident[k] := ch <span style="color: #00ffff;">END</span>;
                getch;
                <span style="color: #00ffff;">UNTIL</span> ch &lt;= <span style="color: #00ff00;">' '</span>;
            newfile(ident)
            <span style="color: #00ffff;">END</span>
    <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> dir = <span style="color: #00ff00;">'PUT             '</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            <span style="color: #00ffff;">FOR</span> i := cc <span style="color: #00ffff;">TO</span> ll <span style="color: #00ffff;">DO</span> <span style="color: #00ffff;">write</span>(line[i]);
            cc := ll; writeln
            <span style="color: #00ffff;">END</span>
    <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> dir = <span style="color: #00ff00;">'SET             '</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            <span style="color: #00ffff;">WHILE</span> ch &lt;= <span style="color: #00ff00;">' '</span>  <span style="color: #00ffff;">DO</span> getch;
            <span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">NOT</span> (ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>]) <span style="color: #00ffff;">THEN</span>
                point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'"A" .. "Z" expected           '</span>);
            c := ch; getch;
            <span style="color: #00ffff;">WHILE</span> ch &lt;= <span style="color: #00ff00;">' '</span>  <span style="color: #00ffff;">DO</span> getch;
            <span style="color: #00ffff;">IF</span> ch &lt;&gt; <span style="color: #00ff00;">'='</span> <span style="color: #00ffff;">THEN</span>
                point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'"=" expected                  '</span>);
            scantimevariables[c] := value;
            <span style="color: #00ffff;">END</span>
    <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> dir = <span style="color: #00ff00;">'TRACE           '</span> <span style="color: #00ffff;">THEN</span>
            trace := value
    <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> dir = <span style="color: #00ff00;">'LISTING         '</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            i := writelisting;
            writelisting := value;
            <span style="color: #00ffff;">IF</span> i = 0 <span style="color: #00ffff;">THEN</span> perhapslisting
            <span style="color: #00ffff;">END</span>
    <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> dir = <span style="color: #00ff00;">'STATISTICS      '</span> <span style="color: #00ffff;">THEN</span>
            statistics := value
    <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> dir = <span style="color: #00ff00;">'RADIX           '</span> <span style="color: #00ffff;">THEN</span>
            alternative_radix := value
    <span style="color: #00ffff;">ELSE</span> point(<span style="color: #00ff00;">'F'</span>,<span style="color: #00ff00;">'unknown directive             '</span>);
    getch;
    <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">1</span>
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">directive *)</span>

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">getsym *)</span>
1 :
<span style="color: #00ffff;">WHILE</span> ch &lt;= <span style="color: #00ff00;">' '</span>  <span style="color: #00ffff;">DO</span> getch;
<span style="color: #00ffff;">CASE</span> ch <span style="color: #00ffff;">OF</span>
    <span style="color: #00ff00;">''''</span> :
        <span style="color: #00ffff;">BEGIN</span>
        getch;
        <span style="color: #00ffff;">IF</span> ch = <span style="color: #00ff00;">'\'</span> <span style="color: #00ffff;">THEN</span> num := value <span style="color: #00ffff;">ELSE</span>
            <span style="color: #00ffff;">BEGIN</span> num := ord(ch); getch <span style="color: #00ffff;">END</span>;
        <span style="color: #00ffff;">IF</span> ch = <span style="color: #00ff00;">''''</span> <span style="color: #00ffff;">THEN</span> getch;
        sym := charconst
        <span style="color: #00ffff;">END</span>;
    <span style="color: #00ff00;">'"'</span> :
        <span style="color: #00ffff;">BEGIN</span>
        <span style="color: #00ffff;">WITH</span> toop <span style="color: #00ffff;">DO</span>
            <span style="color: #00ffff;">BEGIN</span>
            <span style="color: #00ffff;">IF</span> strings = maxstringtab <span style="color: #00ffff;">THEN</span>
                point(<span style="color: #00ff00;">'F'</span>,<span style="color: #00ff00;">'too many strings              '</span>);
            strings := strings + 1;
            stringtab[strings] := chars + 1;
            num := strings
            <span style="color: #00ffff;">END</span>;
        getch;
        <span style="color: #00ffff;">WHILE</span> ch &lt;&gt; <span style="color: #00ff00;">'"'</span> <span style="color: #00ffff;">DO</span>
            <span style="color: #00ffff;">BEGIN</span>
            <span style="color: #00ffff;">IF</span> ch = <span style="color: #00ff00;">'\'</span> <span style="color: #00ffff;">THEN</span> c0 := chr(value) <span style="color: #00ffff;">ELSE</span>
                 <span style="color: #00ffff;">BEGIN</span> c0 := ch; getch <span style="color: #00ffff;">END</span>;
            <span style="color: #00ffff;">WITH</span> toop <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">BEGIN</span>
                chars := chars + 1;
                <span style="color: #00ffff;">IF</span> chars &gt; maxchartab <span style="color: #00ffff;">THEN</span>
                    point(<span style="color: #00ff00;">'F'</span>,<span style="color: #00ff00;">'too many characters in strings'</span>);
                chartab[chars] := c0
                <span style="color: #00ffff;">END</span>;
            <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE *)</span>
        getch; stringtab[num+1] := toop.chars; sym := stringconst
        <span style="color: #66f;">(* </span><span style="color: #66f;">FOR i := stringtab[num] TO stringtab[num+1] DO</span>
<span style="color: #66f;">            write(chartab[i]) *)</span>
        <span style="color: #00ffff;">END</span>;
    <span style="color: #00ff00;">'('</span> :
        <span style="color: #00ffff;">BEGIN</span>
        getch;
        <span style="color: #00ffff;">IF</span> ch &lt;&gt; <span style="color: #00ff00;">'*'</span> <span style="color: #00ffff;">THEN</span> sym := leftparenthesis  <span style="color: #00ffff;">ELSE</span>
            <span style="color: #00ffff;">BEGIN</span>
            getch;
            <span style="color: #00ffff;">REPEAT</span>
                <span style="color: #00ffff;">WHILE</span> ch &lt;&gt; <span style="color: #00ff00;">'*'</span> <span style="color: #00ffff;">DO</span> getch;
                getch
                <span style="color: #00ffff;">UNTIL</span> ch = <span style="color: #00ff00;">')'</span>;
            getch; <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">1</span>
            <span style="color: #00ffff;">END</span>
        <span style="color: #00ffff;">END</span>;
    <span style="color: #00ff00;">'-'</span>,<span style="color: #00ff00;">'0'</span>,<span style="color: #00ff00;">'1'</span>,<span style="color: #00ff00;">'2'</span>,<span style="color: #00ff00;">'3'</span>,<span style="color: #00ff00;">'4'</span>,<span style="color: #00ff00;">'5'</span>,<span style="color: #00ff00;">'6'</span>,<span style="color: #00ff00;">'7'</span>,<span style="color: #00ff00;">'8'</span>,<span style="color: #00ff00;">'9'</span> :
        <span style="color: #00ffff;">BEGIN</span>
        <span style="color: #00ffff;">IF</span> ch &lt;&gt; <span style="color: #00ff00;">'-'</span> <span style="color: #00ffff;">THEN</span> negated := false <span style="color: #00ffff;">ELSE</span>
            <span style="color: #00ffff;">BEGIN</span>
            getch;
            <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'0'</span>..<span style="color: #00ff00;">'9'</span>] <span style="color: #00ffff;">THEN</span> negated := true <span style="color: #00ffff;">ELSE</span>
                <span style="color: #00ffff;">BEGIN</span> sym := hyphen;  <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">9</span> <span style="color: #00ffff;">END</span>
            <span style="color: #00ffff;">END</span>;
        sym := numberconst; num := 0;
        <span style="color: #00ffff;">REPEAT</span>
            num := 10 * num + (ord(ch) - ord(<span style="color: #00ff00;">'0'</span>));
            getch;
            <span style="color: #00ffff;">UNTIL</span> <span style="color: #00ffff;">NOT</span> (ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'0'</span>..<span style="color: #00ff00;">'9'</span>]);
        <span style="color: #00ffff;">IF</span> negated <span style="color: #00ffff;">THEN</span> num := - num
        <span style="color: #00ffff;">END</span>;
    <span style="color: #00ff00;">'&amp;'</span> : <span style="color: #66f;">(* </span><span style="color: #66f;">number in alternative radix *)</span>
        <span style="color: #00ffff;">BEGIN</span>
        sym := numberconst; num := 0;
        getch;
        <span style="color: #00ffff;">WHILE</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'0'</span>..<span style="color: #00ff00;">'9'</span>,<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>] <span style="color: #00ffff;">DO</span>
            <span style="color: #00ffff;">BEGIN</span>
            <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>] <span style="color: #00ffff;">THEN</span>
                ch := chr(ord(ch) + ord(succ(<span style="color: #00ff00;">'9'</span>)) - ord(<span style="color: #00ff00;">'A'</span>));
            <span style="color: #00ffff;">IF</span> ord(ch) &gt;= ord(<span style="color: #00ff00;">'0'</span>) + alternative_radix <span style="color: #00ffff;">THEN</span>
                 point(<span style="color: #00ff00;">'E'</span>,<span style="color: #00ff00;">'exceeding alternative radix   '</span>);
            num := alternative_radix * num + (ord(ch) - ord(<span style="color: #00ff00;">'0'</span>));
            getch
            <span style="color: #00ffff;">END</span>
        <span style="color: #00ffff;">END</span>;
    <span style="color: #00ff00;">'a'</span>,<span style="color: #00ff00;">'b'</span>,<span style="color: #00ff00;">'c'</span>,<span style="color: #00ff00;">'d'</span>,<span style="color: #00ff00;">'e'</span>,<span style="color: #00ff00;">'f'</span>,<span style="color: #00ff00;">'g'</span>,<span style="color: #00ff00;">'h'</span>,<span style="color: #00ff00;">'i'</span>,
    <span style="color: #00ff00;">'j'</span>,<span style="color: #00ff00;">'k'</span>,<span style="color: #00ff00;">'l'</span>,<span style="color: #00ff00;">'m'</span>,<span style="color: #00ff00;">'n'</span>,<span style="color: #00ff00;">'o'</span>,<span style="color: #00ff00;">'p'</span>,<span style="color: #00ff00;">'q'</span>,<span style="color: #00ff00;">'r'</span>,
    <span style="color: #00ff00;">'s'</span>,<span style="color: #00ff00;">'t'</span>,<span style="color: #00ff00;">'u'</span>,<span style="color: #00ff00;">'v'</span>,<span style="color: #00ff00;">'w'</span>,<span style="color: #00ff00;">'x'</span>,<span style="color: #00ff00;">'y'</span>,<span style="color: #00ff00;">'z'</span> :
        <span style="color: #00ffff;">BEGIN</span>
        sym := identifier; k := 0; ident := emptyident;
        <span style="color: #00ffff;">REPEAT</span>
            <span style="color: #00ffff;">IF</span> k &lt; identlength <span style="color: #00ffff;">THEN</span>
                <span style="color: #00ffff;">BEGIN</span> k := k + 1; ident[k] := ch <span style="color: #00ffff;">END</span>;
            getch;
            <span style="color: #00ffff;">UNTIL</span> <span style="color: #00ffff;">NOT</span> (ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'a'</span>..<span style="color: #00ff00;">'z'</span>,<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>,<span style="color: #00ff00;">'_'</span>,<span style="color: #00ff00;">'0'</span>..<span style="color: #00ff00;">'9'</span>])
        <span style="color: #00ffff;">END</span>;
    <span style="color: #00ff00;">'%'</span> :
        directive;
    OTHERWISE
        <span style="color: #00ffff;">BEGIN</span>
        k := 1; res := emptyres; ident := emptyident;
        <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>] <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">REPEAT</span>
                <span style="color: #00ffff;">IF</span> k &lt;= reslength <span style="color: #00ffff;">THEN</span> res[k] := ch;
                <span style="color: #00ffff;">IF</span> k &lt;= identlength <span style="color: #00ffff;">THEN</span> ident[k] := ch;
                getch; k := k + 1
                <span style="color: #00ffff;">UNTIL</span> <span style="color: #00ffff;">NOT</span> (ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>,<span style="color: #00ff00;">'a'</span>..<span style="color: #00ff00;">'z'</span>,<span style="color: #00ff00;">'0'</span>..<span style="color: #00ff00;">'9'</span>,<span style="color: #00ff00;">'_'</span>])
        <span style="color: #00ffff;">ELSE</span>
            <span style="color: #00ffff;">REPEAT</span>
                <span style="color: #00ffff;">IF</span> k &lt;= reslength <span style="color: #00ffff;">THEN</span> res[k] := ch;
                <span style="color: #00ffff;">IF</span> k &lt;= identlength <span style="color: #00ffff;">THEN</span> ident[k] := ch;
                getch; k := k + 1
                <span style="color: #00ffff;">UNTIL</span> <span style="color: #00ffff;">NOT</span> (ch <span style="color: #00ffff;">IN</span> specials_repeat);
        i := 1; j := lastresword;
        <span style="color: #00ffff;">REPEAT</span>
            k := (i + j) <span style="color: #00ffff;">div</span> 2;
            <span style="color: #00ffff;">IF</span> res &lt;= reswords[k].alf <span style="color: #00ffff;">THEN</span> j := k -1;
            <span style="color: #00ffff;">IF</span> res &gt;= reswords[k].alf <span style="color: #00ffff;">THEN</span> i := k + 1;
            <span style="color: #00ffff;">UNTIL</span> i &gt; j;
        <span style="color: #00ffff;">IF</span> i - 1 &gt; j
            <span style="color: #00ffff;">THEN</span> sym := reswords[k].symb
            <span style="color: #00ffff;">ELSE</span> sym := identifier;
        <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">OTHERWISE *)</span>
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(*  </span><span style="color: #66f;">CASE *)</span>
9:
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">getsym *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">check</span>(sy : symbol; ss : symset; er : <span style="color: #00ffff;">message</span>);
<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">check *)</span>
<span style="color: #00ffff;">IF</span> sym = sy <span style="color: #00ffff;">THEN</span> getsym <span style="color: #00ffff;">ELSE</span>
    <span style="color: #00ffff;">BEGIN</span> point(<span style="color: #00ff00;">'E'</span>,er); <span style="color: #00ffff;">IF</span> sym <span style="color: #00ffff;">IN</span> ss <span style="color: #00ffff;">THEN</span> getsym <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">check *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">test</span>(s1,s2 : symset; er : <span style="color: #00ffff;">message</span>);
<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">test *)</span>
<span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">NOT</span> (sym <span style="color: #00ffff;">IN</span> s1) <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span>
    point(<span style="color: #00ff00;">'E'</span>,er);
    s1 := s1 + s2;
    <span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">NOT</span> (sym <span style="color: #00ffff;">IN</span> s1) <span style="color: #00ffff;">THEN</span>
        <span style="color: #00ffff;">BEGIN</span>
        <span style="color: #00ffff;">REPEAT</span> getsym <span style="color: #00ffff;">UNTIL</span> sym <span style="color: #00ffff;">IN</span> s1;
        point(<span style="color: #00ff00;">'I'</span>,<span style="color: #00ff00;">'skipped symbols to here       '</span>);
        <span style="color: #00ffff;">END</span>
    <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">test *)</span>

<span style="color: #66f;">(* </span><span style="color: #66f;">- - - - -   MODULE OUTPUT   - - - - - *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">putch</span>(c : <span style="color: #ff00ff;">char</span>);
<span style="color: #00ffff;">BEGIN</span>
<span style="color: #00ffff;">write</span>(output,c);
<span style="color: #00ffff;">IF</span> writelisting &gt; 0 <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span>
    <span style="color: #00ffff;">IF</span> outlinelength = 0 <span style="color: #00ffff;">THEN</span>
        <span style="color: #00ffff;">write</span>(listing,linenumspace,linenumsep);
    <span style="color: #00ffff;">write</span>(listing,c)
    <span style="color: #00ffff;">END</span>;
<span style="color: #00ffff;">IF</span> ord(c) = 13 <span style="color: #66f;">(* </span><span style="color: #66f;">newline character *)</span>
    <span style="color: #00ffff;">THEN</span> outlinelength := 0
    <span style="color: #00ffff;">ELSE</span> outlinelength := outlinelength + 1
<span style="color: #00ffff;">END</span>;

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">writeline</span>;
<span style="color: #00ffff;">BEGIN</span>
writeln(output);
<span style="color: #00ffff;">IF</span> writelisting &gt; 0 <span style="color: #00ffff;">THEN</span> writeln(listing);
outlinelength := 0
<span style="color: #00ffff;">END</span>;

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">writeident</span>(a : identalfa);
<span style="color: #ff00ff;">VAR</span> i,length : <span style="color: #ff00ff;">integer</span>;
<span style="color: #00ffff;">BEGIN</span>
length := identlength;
<span style="color: #00ffff;">WHILE</span> a[length] &lt;= <span style="color: #00ff00;">' '</span> <span style="color: #00ffff;">DO</span> length := length - 1;
<span style="color: #00ffff;">IF</span> outlinelength + length  &gt; maxoutlinelength <span style="color: #00ffff;">THEN</span> writeline;
<span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> length <span style="color: #00ffff;">DO</span> putch(a[i])
<span style="color: #00ffff;">END</span>;

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">writeresword</span>(a : resalfa);
<span style="color: #ff00ff;">VAR</span> i,length : <span style="color: #ff00ff;">integer</span>;
<span style="color: #00ffff;">BEGIN</span>
length := reslength;
<span style="color: #00ffff;">WHILE</span> a[length] &lt;= <span style="color: #00ff00;">' '</span> <span style="color: #00ffff;">DO</span> length := length - 1;
<span style="color: #00ffff;">IF</span> outlinelength + length &gt; maxoutlinelength <span style="color: #00ffff;">THEN</span> writeline;
<span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> length <span style="color: #00ffff;">DO</span> putch(a[i])
<span style="color: #00ffff;">END</span>;

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">writeinteger</span>(i : <span style="color: #ff00ff;">integer</span>);

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">writenatural</span>(n : <span style="color: #ff00ff;">integer</span>);
    <span style="color: #00ffff;">BEGIN</span>
    <span style="color: #00ffff;">IF</span> n &gt;= 10 <span style="color: #00ffff;">THEN</span> writenatural(n <span style="color: #00ffff;">DIV</span> 10);
    putch(chr(ord(<span style="color: #00ff00;">'0'</span>) + n <span style="color: #00ffff;">MOD</span> 10))
    <span style="color: #00ffff;">END</span>;

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">writeinteger *)</span>
<span style="color: #00ffff;">IF</span> outlinelength + 12 &gt; maxoutlinelength <span style="color: #00ffff;">THEN</span> writeline;
<span style="color: #00ffff;">IF</span> i &gt;= 0 <span style="color: #00ffff;">THEN</span> writenatural(i) <span style="color: #00ffff;">ELSE</span>
    <span style="color: #00ffff;">BEGIN</span> putch(<span style="color: #00ff00;">'-'</span>); writenatural(-i) <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">writeinteger *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">finalise</span>;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">fin</span>(<span style="color: #ff00ff;">VAR</span> f : text);
    <span style="color: #00ffff;">BEGIN</span>
    <span style="color: #00ffff;">IF</span> errorcount &gt; 0 <span style="color: #00ffff;">THEN</span> writeln(f,errorcount:0,<span style="color: #00ff00;">' error(s)'</span>);
    writeln(f,clock - start_clock:0,
        <span style="color: #00ff00;">' milliseconds CPU'</span>)
    <span style="color: #00ffff;">END</span>;

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">finalise *)</span>
fin(output);
<span style="color: #00ffff;">IF</span> writelisting &gt; 0 <span style="color: #00ffff;">THEN</span> fin(listing)
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">finalise *)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Remarks and a major project</h2>
<div class="outline-text-2" id="text-5">
<p>
The utilities implemented here are being used by three quite disparate programs in the next three chapters.  None of the programs use all the facilities, but that is unavoidable for something as general as this.  One exercise that might be worthwhile is to make the <code>IF</code> directive more powerful by letting it operate not just on the remainder of the line but on all following lines up to an <code>ENDIF</code> directive.  Clearly an <code>ELSE</code> directive would be useful, too.  The language C has a preprocessor called cpp which does this sort of thing.  Again, being able to define constants would be useful; the preprocessor cpp for the language C has this.  Some of the reading given for Chapter 4 on macro expansion is relevant.
</p>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> <i>A Major Project</i>:</h2>
<div class="outline-text-2" id="text-6">
<p>
This project is not immediately tied to the utilities in this chapter, but it can use them profitably, and it has much less to do with the programs in the later chapters.
</p>

<p>
Design a small procedural language.  It should include declarations of global variables, of procedures and functions which can have value parameters and local variables.  Unlike Pascal, procedure and functions cannot be nested.  Variables and parameters are to be typed, and so are the values returned by functions.  But there will be only three inbuilt types: boolean, char and integer, and no type constructors.  The statements should include assignment, call, <code>IF-THEN(-ELSE)</code> and <code>WHILE-DO</code>.  The expressions should include a reasonable collection of operations on the inbuilt types.
</p>

<p>
You should begin by writing a context free grammar first.  Then write a context free parser which reports errors.  Add error recovery in accordance with Wirth (1976 pp 320 - 322) or Terry (1986 pp 208 - 211).  You should now be able to have a test program that has many context free errors.
</p>

<p>
Next, add a symbol table for entering global variables, procedures and functions and their parameters and local variables.  Note that at the end of a procedure or function declaration the names of the parameters and locals have to become invisible, but the types of the parameters still have to accessible.  Take some care to avoid spurious error messages.  It helps to have an additional type <code>notype</code> in expressions.  Write a test program that has many context sensitive errors.
</p>

<p>
You can now add code generation to this compiler.  There are many possibilities: to translate into some existing language, to translate into some internal language that will be interpreted either recursively or non-recursively, or to translate into some intermediate language first which can then be translated independently into several other languages.
</p>
</div>
</div>
</div>
</body>
</html>
