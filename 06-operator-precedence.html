<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 6 : Operator Precedence Parsing</title>
<!-- 2013-05-31 Fri 19:02 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="author" content="michal"/>
<link rel="stylesheet" type="text/css" href="/etc/style.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Chapter 6 : Operator Precedence Parsing</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. </a></li>
<li><a href="#sec-2">2. Bottom up parsing</a></li>
<li><a href="#sec-3">3. Precedence relations</a>
<ul>
<li><a href="#sec-3-1">3.1. The algorithm</a></li>
<li><a href="#sec-3-2">3.2. The program</a></li>
</ul>
</li>
<li><a href="#sec-4">4. Precedence functions</a>
<ul>
<li><a href="#sec-4-1">4.1. The algorithm</a></li>
<li><a href="#sec-4-2">4.2. The program</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Exercises and reading</a>
<ul>
<li><a href="#sec-5-1">5.1. <i>Ad hoc error detection</i>:</a></li>
<li><a href="#sec-5-2">5.2. <i>Parsing without tables</i>:</a></li>
<li><a href="#sec-5-3">5.3. <i>Changing the tables</i>:</a></li>
<li><a href="#sec-5-4">5.4. <i>Evaluator</i>:</a></li>
<li><a href="#sec-5-5">5.5. <i>Non-recursive truth table program</i>:</a></li>
<li><a href="#sec-5-6">5.6. <i>Reading</i>:</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> <a id="intro" name="intro"></a></h2>
<div class="outline-text-2" id="text-1">
<p>
In previous chapters we have seen several parsers, evaluators and translators.
</p>

<p>
All used <i>recursive descent</i>, one of the top down methods.  This chapter introduces one very simple form of <i>bottom up</i> parsing and translating.
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Bottom up parsing</h2>
<div class="outline-text-2" id="text-2">
<p>
Consider the following fragment of a Pascal program:
</p>

<pre class="example">
IF  x = 0  THEN  y := 1
</pre>

<p>
You can see immediately that this is a statement, and not a program or an expression or a factor or anything else.  A recursive descent compiler for Pascal will recognise it as a statement, but only if the compiler is currently expecting a statement.  If it is currently expecting a program or a type or an expression or something else, then it will respond with error messages.  Note that you were able to recognise the fragment because you had no expectations.  This is an essential difference between a top down parsing method like recursive descent, and the bottom up method you were using in your head.  In this chapter we shall study bottom up methods applied to parsing and translating.  In all of these the parser does not start off with definite expectations but reads symbols as they come along and makes sense of them.
</p>

<p>
The basic idea is that just as expressions can be evaluated by several passes which evaluate subexpressions, so sequences of symbols can be parsed by several passes which parse subexpressions.  First, consider the following equivalent formulas in prefix, in fully parenthesised infix, and in postfix notation: All three are to be evaluated, by rewriting leftmost subformulas by their values when possible; note that <i>time flows from top to bottom</i>:
</p>

<pre class="example">
prefix:                 infix:                      postfix:
&gt; - = 0 - &amp; 1 1 0       (-(0 = -(1 &amp; 1)) &gt; 0)       0 1 1 &amp; - = - 0 &gt;
&gt; - = 0 - 1     0       (-(0 = -   1   ) &gt; 0)       0     1 - = - 0 &gt;
&gt; - = 0 0       0       (-(0 = 0       ) &gt; 0)       0       0 = - 0 &gt;
&gt; - 1           0       (-   1           &gt; 0)                 1 - 0 &gt;
&gt; 0             0       (0               &gt; 0)                   0 0 &gt;
1                                        1                          1
</pre>

<p>
If we ignore the difference in meaning between the various operands and operators and merely consider syntax, then we could rewrite all well-formed subformulas by <code>F</code> to indicate that they are formulas, like this:
</p>

<pre class="example">
prefix:                 infix:                      postfix:
&gt; - = 0 - &amp; 1 1 0       (-(0 = -(1 &amp; 1)) &gt; 0)       0 1 1 &amp; - = - 0 &gt;
&gt; - = F - &amp; 1 1 0       (-(F = -(1 &amp; 1)) &gt; 0)       F 1 1 &amp; - = - 0 &gt;
&gt; - = F - &amp; F 1 0       (-(F = -(F &amp; 1)) &gt; 0)       F F 1 &amp; - = - 0 &gt;
&gt; - = F - &amp; F F 0       (-(F = -(F &amp; F)) &gt; 0)       F F F &amp; - = - 0 &gt;
&gt; - = F - F     0       (-(F = -   F   ) &gt; 0)       F     F - = - 0 &gt;
&gt; - = F F       0       (-(F = F       ) &gt; 0)       F       F = - 0 &gt;
&gt; - F           0       (-   F           &gt; 0)                 F - 0 &gt;
&gt; F             0       (F               &gt; 0)                   F 0 &gt;
&gt; F             F       (F               &gt; F)                   F F &gt;
F                                        F                          F
</pre>

<p>
As described, the method would require us to always start at the beginning of the symbol sequence and perform the first replacement, just as we did for evaluation by replacement.  But from our truth table program you will remember that a very good method for evaluating uses an auxiliary stack which contains whatever needs to be remembered about the values computed so far.  We could even imagine a method which is less efficient than the one we used there, but which is interesting; as we pass through the postfix formula, we push all symbols onto the stack, operands and operators.  If <i>at any time</i> the top few elements of the stack consist of a few operands topped by an operator, we interrupt the pushing and replace the operator and its operands by the result value.  For comparison, here are the two evaluation methods; note that <i>time flows from left to right</i>:
</p>

<pre class="example">
efficient method:               less efficient method:
0 1 1 &amp; - = - 0 &gt;               0 1 1 &amp;   -   =   -   0 &gt;
                                      &amp;
    1                               1 1   -   =         &gt;
  1 1 1 0     0                   1 1 1 1 1 0 0   -   0 0
0 0 0 0 0 1 0 0 1               0 0 0 0 0 0 0 0 1 1 0 0 0 1
</pre>

<p>
For either method, if instead of 0 and 1 on the stack we always had <code>F</code> (for <code>formula</code>), we would have a parsing method which avoids having to restart at the beginning of the formula every time.  This is how it will look:
</p>

<pre class="example">
efficient method:               less efficient method:
0 1 1 &amp; - = - 0 &gt;               0 1 1 &amp;   -   =   -   0 &gt;
                                      &amp;
    F                               F F   -   =         &gt;
  F F F F     F                   F F F F F F F   -   F F
F F F F F F F F F               F F F F F F F F F F F F F F
</pre>

<p>
The less efficient method lends itself to becoming a very general parsing method which can be used for the other notations, too.  Here it is used for fully parenthesised infix notation:
</p>

<pre class="example">
( - ( 0 = - ( 1 &amp; 1 )     )     &gt; 0 )
                    )
                  F F
                &amp; &amp; &amp;
              F F F F
            ( ( ( ( ( F   )
          - - - - - - - F F
        = = = = = = = = = =         )
      F F F F F F F F F F F       F F
    ( ( ( ( ( ( ( ( ( ( ( ( F   &gt; &gt; &gt;
  - - - - - - - - - - - - - - F F F F
( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( F
                      1 2   3 4       5
</pre>

<p>
Note that most steps push the current input symbol onto the stack, but there are five <i>reduction</i> steps, marked <code>1..5</code>.  Here is a brief formulation of the algorithm:
</p>

<pre class="example">
start with an empty stack
REPEAT
    IF the top few symbols on the stack can be replaced by
            a single one in accordance with the grammar
        THEN do the replacement
        ELSE push the next symbol onto the stack
    UNTIL the end of the string has been reached
</pre>

<p>
At the end of this, the stack should contain a single non-terminal of the grammar, and this is what has been recognised.  As described, the algorithm is not very efficient, because for example in the case of fully parenthesised infix formulas up to five symbols on the stack have to be examined in the <code>IF</code> part.  To improve the algorithm, we can make partial reductions and also make the applicability of reductions depend on the next input symbol.  This idea is used in most bottom up parsers, including the two very specialised ones to follow.
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Precedence relations</h2>
<div class="outline-text-2" id="text-3">
<p>
In the remainder of this chapter we shall look at two related bottom up parsing methods which are very simple and efficient, but are applicable only to a rather narrow class of languages.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> The algorithm</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Consider arithmetic or logical expressions in minimally parenthesised notation as written in the first line and their fully parenthesised form in the second line.
</p>

<pre class="example">
x +  y * z                      p v  q &amp; r
x + (y * z)                     p v (q &amp; r)
</pre>

<p>
The usual convention is that <code>*</code> binds more strongly than <code>+</code>, and that <code>&amp;</code> binds more strongly than <code>v</code>.  Hence <code>y</code> is an operand to <code>*</code> and not to <code>+</code>, and <code>q</code> is an operand to <code>&amp;</code> and not to <code>v</code>.  It helps to think of the operators on the left and right of <code>y</code> and <code>q</code> tugging at it, and <code>*</code> and <code>&amp;</code> win.  The technical notion is that <code>*</code> has precedence over <code>+</code>, and that <code>&amp;</code> has precedence over <code>v</code>.  For binary operators that are semantically associative it does not matter whether they have precedence over themselves, but for others it is important to distinguish those that are syntactically left-associative (such as subtraction and implication), and those that are syntactically right-associative (such as exponentiation in arithmetic).
</p>

<p>
We shall now design a parser for logical formulas in minimally parenthesised infix notation.  In the following table, the row headings are for the operator on the left of the disputed operand, and the column headings are for the operator on the right of the operand.  The table entries <code>&gt;</code> indicate that the row operator, when on the left, has precedence over the column operator, when on the right.  The table entries <code>&lt;</code> indicate the reverse.
</p>

<pre class="example">
      "&amp;"   "v"   "&gt;"
    +----------------
"&amp;" |  &gt;     &gt;     &gt;
"v" |  &lt;     &gt;     &gt;
"&gt;" |  &lt;     &lt;     &lt;
</pre>

<p>
This table is part of a larger table which has rows and columns for symbols that are not binary operators: atomic formulas, negation, the two parentheses, and a terminator, say the period <code>.</code> The notion of a symbol having precedence over another now has to be extended to cover these other symbols.  It so turns out that apart from <code>&lt;</code> and <code>&gt;</code> a third entry, <code>=</code>, is needed.  Finally, for illegal combinations, the entries can be error codes.
</p>

<p>
A minor problem arises about <code>v</code> being used as an infix connective and as an atomic formula.  In the case of recursive descent parsing there was no problem, even a formula such as <code>v v v v v</code> is correctly recognised as the three-fold disjunction of <code>v</code> with itself.  However, for operator precedence parsing this will not work, and henceforth we shall use <code>#</code> as the disjunction symbol.
</p>

<p>
That larger table can then be used to drive an algorithm which is a descendant of the one outlined at the end of the last section.  Instead of pushing symbols from the input onto the stack and then comparing them with what is below, the comparison is done between the current input symbol and the top element.  Instead of reducing only when the full right hand side of a production of the grammar has been seen, partial reductions take place.  Instead of reducing non-terminals (such as <code>F</code> in the example), the only symbols on the stack are terminals.  The net effect of the three changes is a very simple and very efficient bottom up parsing method:
</p>

<pre class="example">
Push a marker onto an otherwise empty stack
WHILE stack contains more than one symbol OR
    the current input symbol is not the terminator DO
  LET R be the precedence relation between
    the symbol on top of the stack and the next input symbol
  IF R is &lt; OR R is = THEN
    shift the next input symbol onto the stack
  ELSE IF R is &gt; THEN
    REPEAT
      pop the top element off the stack
      UNTIL the precedence relation between
        the symbol on top of the stack and
        the most recently popped symbol is &lt;
  ELSE abort with error R
</pre>

<p>
With the information given so far, it should not be too difficult to write the program.  The precedence relations can be built into the algorithm at the <code>LET</code> part of the loop.  Alternatively, the algorithm can be left quite general and the <code>LET</code> part implemented as a lookup of a two dimensional array.  In this way it is this array or table which specifies the language; such table driven parsing is a popular implementation technique for bottom up parsers.  No matter which implementation is chosen, the hard part is to specify the precedence relations between symbols other than the infix operators.  A very minor addition to the program turns it into an infix to postfix translator.
</p>

<p>
The following is the record of an interaction with the program.  The program does not echo its input, which is ideal for interactive use.  After each prompt <code>ready</code>, it reads a formula typed by the user.  If the formula is preceded by <code>?</code>, then the program goes into tracing mode.  Note that the first three formulas are being parsed and translated in tracing mode, where the stack is now written horizontally.  For the remaining formulas tracing is switched off.  The last formulas contain intentional errors.
</p>

<pre class="example">
$ RUN 15OPPRER.EXE
ready
?  a &amp; b.
stack               infix-char          postfix-char
                    a
a                   &amp;
                                        a
                    &amp;
&amp;                   b
&amp;b                  .
                                        b
&amp;                   .
                                        &amp;
POSTFIX CODE : ab&amp;
ready
?  (a &amp; b) # (c &amp; d).
stack               infix-char          postfix-char
                    (
(                   a
(a                  &amp;
                                        a
(                   &amp;
(&amp;                  b
(&amp;b                 )
                                        b
(&amp;                  )
                                        &amp;
(                   )
()                  #
                    #
#                   (
#(                  c
#(c                 &amp;
                                        c
#(                  &amp;
#(&amp;                 d
#(&amp;d                )
                                        d
#(&amp;                 )
                                        &amp;
#(                  )
#()                 .
#                   .
                                        #
POSTFIX CODE : ab&amp;cd&amp;#
ready
-a &amp; -b # -(c &gt; d) &gt; e &gt; f.
POSTFIX CODE : a-b-&amp;cd&gt;-#ef&gt;&gt;
ready
a&amp;b&amp;c&amp;d&amp;e&amp;f&amp;g&amp;h&amp;i&amp;j.
POSTFIX CODE : ab&amp;c&amp;d&amp;e&amp;f&amp;g&amp;h&amp;i&amp;j&amp;
ready
a&gt;b&gt;c&gt;d&gt;e&gt;f&gt;g&gt;h&gt;i&gt;j.
POSTFIX CODE : abcdefghij&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
ready
((a=b) # (c&gt;d)) &amp; -(e=f).
POSTFIX CODE : ab=cd&gt;#ef=-&amp;
ready
?  a &amp; b b.
stack               infix-char          postfix-char
                    a
a                   &amp;
                                        a
                    &amp;
&amp;                   b
&amp;b                  b
error 0
ready
(((((((a&amp;-b)).
error 2
ready
.
</pre>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> The program</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The following is the Pascal source program for the operator precedence parser/translator based on precedence relations.  Note that the <code>VALUE</code> declaration is not standard Pascal, it initialises the (two dimensional) <code>ARRAY</code> of precedence relations.  Note that it this <code>ARRAY</code> which specifies the syntax of the input language, the remainder of the program is quite general.  (The <code>VALUE</code> declaration could be replaced by some other initialisation mechanism; one possibility is 64 assignment statements, another is 8 calls of a procedure with 8 parameters, another is reading the matrix from a file.)
</p>

<div class="org-src-container">

<pre class="src src-pascal"><span style="color: #00ffff;">PROGRAM</span> <span style="color: #ffffff; font-weight: bold;">opprer</span>(input,output);
<span style="color: #66f;">(* </span><span style="color: #66f;">OPerator PREcedence Relations *)</span>

LABEL 1;

<span style="color: #ff00ff;">CONST</span>
marker = <span style="color: #00ff00;">'.'</span>;
maxstack = 100;
maxcode = 300;

s_header = <span style="color: #00ff00;">'stack               '</span>;
i_header = <span style="color: #00ff00;">'infix-char          '</span>;
p_header = <span style="color: #00ff00;">'postfix-char        '</span>;
big_tab  = <span style="color: #00ff00;">'                    '</span>;

<span style="color: #ff00ff;">TYPE</span>
symbol =
    (atomsy,notsy,andsy,orsy,implsy,lpar,rpar,period);
<span style="color: #ff00ff;">VAR</span>
p : <span style="color: #ff00ff;">ARRAY</span>[symbol,symbol] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;       <span style="color: #66f;">(* </span><span style="color: #66f;">relations *)</span>
s : <span style="color: #ff00ff;">ARRAY</span>[0..maxstack] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;         <span style="color: #66f;">(* </span><span style="color: #66f;">parsing stack *)</span>
t : <span style="color: #ff00ff;">integer</span>;                            <span style="color: #66f;">(* </span><span style="color: #66f;">top of stack *)</span>
sy : <span style="color: #ff00ff;">ARRAY</span>[<span style="color: #ff00ff;">char</span>] <span style="color: #00ffff;">OF</span> symbol;
ch : <span style="color: #ff00ff;">char</span>;
tracing,finished : <span style="color: #ff00ff;">boolean</span>;
i : <span style="color: #ff00ff;">integer</span>;

code : <span style="color: #ff00ff;">ARRAY</span>[1..maxcode] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;
cx : <span style="color: #ff00ff;">integer</span>;

VALUE
p := ( <span style="color: #66f;">(*        </span><span style="color: #66f;">atm not and or  imp lp  rp  per *)</span>
<span style="color: #66f;">(* </span><span style="color: #66f;">atm *)</span>       (<span style="color: #00ff00;">'0'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'1'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>),
<span style="color: #66f;">(* </span><span style="color: #66f;">not *)</span>       (<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>),
<span style="color: #66f;">(* </span><span style="color: #66f;">and *)</span>       (<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>),
<span style="color: #66f;">(* </span><span style="color: #66f;">or  *)</span>       (<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>),
<span style="color: #66f;">(* </span><span style="color: #66f;">imp *)</span>       (<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>),
<span style="color: #66f;">(* </span><span style="color: #66f;">lp  *)</span>       (<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'='</span>,<span style="color: #00ff00;">'2'</span>),
<span style="color: #66f;">(* </span><span style="color: #66f;">rp  *)</span>       (<span style="color: #00ff00;">'3'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'4'</span>,<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&gt;'</span>),
<span style="color: #66f;">(* </span><span style="color: #66f;">per *)</span>       (<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'5'</span>,<span style="color: #00ff00;">'6'</span>) );

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">getch</span>;
<span style="color: #00ffff;">BEGIN</span>
<span style="color: #00ffff;">REPEAT</span>
    <span style="color: #00ffff;">read</span>(ch)
    <span style="color: #00ffff;">UNTIL</span> ch &gt; <span style="color: #00ff00;">' '</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">getch *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">gen</span>(c:<span style="color: #ff00ff;">char</span>);
<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">gen *)</span>
<span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">NOT</span> (c <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'('</span>,<span style="color: #00ff00;">')'</span>]) <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span>
    <span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span> writeln(big_tab,big_tab,c);
    cx := cx + 1;
    code[cx] := c
    <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">gen *)</span>

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">main *)</span>
<span style="color: #66f;">(* </span><span style="color: #66f;">initialise table SY *)</span>
<span style="color: #00ffff;">FOR</span> ch := chr(0) <span style="color: #00ffff;">TO</span> chr(255) <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>,<span style="color: #00ff00;">'a'</span>..<span style="color: #00ff00;">'z'</span>,<span style="color: #00ff00;">'0'</span>,<span style="color: #00ff00;">'1'</span>]
        <span style="color: #00ffff;">THEN</span> sy[ch] := atomsy
    <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">CASE</span> ch <span style="color: #00ffff;">OF</span>
        <span style="color: #00ff00;">'-'</span>     : sy[ch] := notsy;
        <span style="color: #00ff00;">'&amp;'</span>     : sy[ch] := andsy;
        <span style="color: #00ff00;">'#'</span>     : sy[ch] := orsy;
        <span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'='</span> : sy[ch] := implsy;
        <span style="color: #00ff00;">'('</span>     : sy[ch] := lpar;
        <span style="color: #00ff00;">')'</span>     : sy[ch] := rpar;
        <span style="color: #00ff00;">'.'</span>     : sy[ch] := period;
        OTHERWISE  sy[ch] := period
        <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
1:
finished := false;
<span style="color: #00ffff;">REPEAT</span>
    writeln(<span style="color: #00ff00;">'ready'</span>);
    tracing := false;
    cx := 0;
    getch;
    <span style="color: #00ffff;">IF</span> ch = <span style="color: #00ff00;">'.'</span> <span style="color: #00ffff;">THEN</span> finished := true <span style="color: #00ffff;">ELSE</span>
        <span style="color: #00ffff;">BEGIN</span>
        <span style="color: #00ffff;">IF</span> ch = <span style="color: #00ff00;">'?'</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span> tracing := true; getch <span style="color: #00ffff;">END</span>;

        <span style="color: #66f;">(* </span><span style="color: #66f;">BEGIN operator precedence parsing algorithm *)</span>
        <span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span>
            writeln(s_header,i_header,p_header);
        s[0] := marker; t := 0;
        <span style="color: #00ffff;">WHILE</span> (t &gt; 0) <span style="color: #00ffff;">OR</span> (ch &lt;&gt; marker) <span style="color: #00ffff;">DO</span>
            <span style="color: #00ffff;">BEGIN</span>
            <span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span>
                <span style="color: #00ffff;">BEGIN</span>
                <span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> t <span style="color: #00ffff;">DO</span> <span style="color: #00ffff;">write</span>(s[i]);
                <span style="color: #00ffff;">FOR</span> i := t+1 <span style="color: #00ffff;">TO</span> 15 <span style="color: #00ffff;">DO</span> <span style="color: #00ffff;">write</span>(<span style="color: #00ff00;">' '</span>);
                writeln(<span style="color: #00ff00;">'     '</span>,ch)
                <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">IF *)</span>
            <span style="color: #00ffff;">CASE</span>  p[sy[s[t]],sy[ch]] <span style="color: #00ffff;">OF</span>
                <span style="color: #00ff00;">'&lt;'</span>, <span style="color: #00ff00;">'='</span> :
                    <span style="color: #00ffff;">BEGIN</span>                               <span style="color: #66f;">(* </span><span style="color: #66f;">shift *)</span>
                    t := t+1;
                    s[t] := ch;
                    getch
                    <span style="color: #00ffff;">END</span>;
                <span style="color: #00ff00;">'&gt;'</span> :
                    <span style="color: #00ffff;">BEGIN</span>                               <span style="color: #66f;">(* </span><span style="color: #66f;">reduce *)</span>
                    <span style="color: #00ffff;">REPEAT</span>
                        gen(s[t]);
                        t := t-1
                        <span style="color: #00ffff;">UNTIL</span> p[sy[s[t]],sy[s[t+1]]] = <span style="color: #00ff00;">'&lt;'</span>
                    <span style="color: #00ffff;">END</span>;
                OTHERWISE
                    <span style="color: #00ffff;">BEGIN</span>
                    writeln(<span style="color: #00ff00;">'error '</span>,p[sy[s[t]],sy[ch]]);
                    readln;
                    <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">1</span>
                    <span style="color: #00ffff;">END</span>
                <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
            <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE *)</span>
        <span style="color: #66f;">(* </span><span style="color: #66f;">END operator precedence parsing algorithm *)</span>

        <span style="color: #00ffff;">write</span>(<span style="color: #00ff00;">'POSTFIX CODE : '</span>);
        <span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> cx <span style="color: #00ffff;">DO</span> <span style="color: #00ffff;">write</span>(code[i]);
        writeln
        <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">ELSE *)</span>
    <span style="color: #00ffff;">UNTIL</span> finished
<span style="color: #00ffff;">END</span>. <span style="color: #66f;">(* </span><span style="color: #66f;">main *)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Precedence functions</h2>
<div class="outline-text-2" id="text-4">
<p>
This section describes a variant of the algorithm which replaces the two dimensional (and hence potentially large) array of precedence relations by two one-dimensional arrays.
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> The algorithm</h3>
<div class="outline-text-3" id="text-4-1">
<p>
The precedence relations between binary operators need not be transitive.  It is quite possible to have three infix operators O1, O2 and O3 such that O1 on the left has precedence over O2 on the right, that O2 on the left has precedence over O3 on the right, and yet O3 on the left has precedence over O1 on the right.  But for most purposes this possibility is not required at all, indeed users would probably find it confusing.  If the precedence relation can be made transitive and even linear, then it becomes possible to assign to each symbol a numeric precedence strength.  More precisely, for each symbol <code>s</code> two numbers are needed, conventionally called <code>f(s)</code> for the precedence on the left, and <code>g(s)</code> for the precedence on the right.  The algorithm now becomes:
</p>

<pre class="example">
Push a marker onto an otherwise empty stack
WHILE stack contains more than one symbol OR
    the current input symbol is not the terminator DO
  IF f(the symbol on top of the stack)
      &lt;= g(the next input symbol) THEN
    shift the next input symbol onto the stack
  ELSE
    REPEAT
      pop the top element off the stack
      UNTIL f(the symbol on top of the stack)
        &lt; g(the symbol most recently popped)
</pre>

<p>
The most difficult part is to find, for each input symbol, numeric values for the f and g functions.  When suitable values have been found, it is easy enough to put them into two arrays, say f and g.  Thus, just as the precedence relations program can be driven by a two dimensional array of relations, so the precedence functions program can be driven by two numeric arrays f and g.  There is no way to build error detection into the algorithm, see Aho and Ullman (1977, p 171), except by ad hoc methods.  But it is again an easy matter to extend the program just slightly so that it becomes a translator into postfix.  It is not essential that the postfix version uses exactly the same symbols, it is easy enough translate into a different symbolism.  (The sample program translates the infix constants <code>0</code> and <code>1</code> into the postfix constants <code>T</code> and <code>F</code>.)
</p>

<p>
The following is a record of an interaction with the program.  Like the preceding program, this one does not echo its input.  After each prompt <code>ready</code>, it reads a formula typed by the user.  If the formula is preceded by <code>?</code>, then the program goes into tracing mode.
</p>

<pre class="example">
$ SET VERIFY
$ RUN  15OPPREF.EXE
ready
?  a &amp; b.
stack               infix-char          postfix-char
                    a
a                   &amp;
                                        a
                    &amp;
&amp;                   b
&amp;b                  .
                                        b
&amp;                   .
                                        &amp;
POSTFIX CODE : ab&amp;
ready
?  (a &amp; b) # (c &amp; d).
stack               infix-char          postfix-char
                    (
(                   a
(a                  &amp;
                                        a
(                   &amp;
(&amp;                  b
(&amp;b                 )
                                        b
(&amp;                  )
                                        &amp;
(                   )
()                  #
                    #
#                   (
#(                  c
#(c                 &amp;
                                        c
#(                  &amp;
#(&amp;                 d
#(&amp;d                )
                                        d
#(&amp;                 )
                                        &amp;
#(                  )
#()                 .
#                   .
                                        #
POSTFIX CODE : ab&amp;cd&amp;#
ready
-a &amp; -b # -(c &gt; d) &gt; e &gt; f.
POSTFIX CODE : a-b-&amp;cd&gt;-#ef&gt;&gt;
ready
a&amp;b&amp;c&amp;d&amp;e&amp;f&amp;g&amp;h&amp;i&amp;j.
POSTFIX CODE : ab&amp;c&amp;d&amp;e&amp;f&amp;g&amp;h&amp;i&amp;j&amp;
ready
a&gt;b&gt;c&gt;d&gt;e&gt;f&gt;g&gt;h&gt;i&gt;j.
POSTFIX CODE : abcdefghij&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
ready
((a=b) # (c&gt;d)) &amp; -(e=f).
POSTFIX CODE : ab=cd&gt;#ef=-&amp;
ready
(0 # 1) &amp; (--1 &gt; 0)  =  1 # 0 &amp; 1.
POSTFIX CODE : FT#T--F&gt;&amp;TFT&amp;#=
ready
.
</pre>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> The program</h3>
<div class="outline-text-3" id="text-4-2">
<p>
The following is the standard Pascal source program for the parser/translator based on precedence functions.  Note that the input language and the translation to the output language are specified by the four string constants in the <code>CONST</code> declaration.  The remainder of the program is completely general.
</p>

<div class="org-src-container">

<pre class="src src-pascal"><span style="color: #00ffff;">PROGRAM</span> <span style="color: #ffffff; font-weight: bold;">oppref</span>(input,output);
<span style="color: #66f;">(* </span><span style="color: #66f;">OPerator PREcedence Functions *)</span>
<span style="color: #66f;">(* </span><span style="color: #66f;">CANNOT HANDLE ERRORS - SEE Aho and Ullman (1977, p 171) *)</span>

<span style="color: #ff00ff;">CONST</span>
numterminals = 36;
i0 = <span style="color: #00ff00;">'=&gt;#&amp;-()abcdefghijklmnopqrstuvwxyz01.'</span>;
o0 = <span style="color: #00ff00;">'=&gt;#&amp;-  abcdefghijklmnopqrstuvwxyzFT.'</span>;
f0 = <span style="color: #00ff00;">'114660666666666666666666666666666660'</span>;
g0 = <span style="color: #00ff00;">'223577077777777777777777777777777770'</span>;
marker = <span style="color: #00ff00;">'.'</span>;
maxstack = 100;
maxcode = 300;

s_header = <span style="color: #00ff00;">'stack               '</span>;
i_header = <span style="color: #00ff00;">'infix-char          '</span>;
p_header = <span style="color: #00ff00;">'postfix-char        '</span>;
big_tab  = <span style="color: #00ff00;">'                    '</span>;

<span style="color: #ff00ff;">VAR</span>
o : <span style="color: #ff00ff;">ARRAY</span>[<span style="color: #ff00ff;">char</span>] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;        <span style="color: #66f;">(* </span><span style="color: #66f;">outputs *)</span>
f,g : <span style="color: #ff00ff;">ARRAY</span>[<span style="color: #ff00ff;">char</span>] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">integer</span>;   <span style="color: #66f;">(* </span><span style="color: #66f;">precedences *)</span>
s : <span style="color: #ff00ff;">ARRAY</span>[0..maxstack] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">parsing stack *)</span>
t : <span style="color: #ff00ff;">integer</span>;                    <span style="color: #66f;">(* </span><span style="color: #66f;">top of stack *)</span>
ch : <span style="color: #ff00ff;">char</span>;
code : <span style="color: #ff00ff;">ARRAY</span>[1..maxcode] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;
cx : <span style="color: #ff00ff;">integer</span>;
tracing,finished : <span style="color: #ff00ff;">boolean</span>;
i : <span style="color: #ff00ff;">integer</span>;

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">initialise</span>;
<span style="color: #ff00ff;">VAR</span> i : <span style="color: #ff00ff;">integer</span>;
    i1,o1,f1,g1 : <span style="color: #ff00ff;">PACKED</span> <span style="color: #ff00ff;">ARRAY</span> [1..numterminals] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;
<span style="color: #00ffff;">BEGIN</span>
i1 := i0; o1 := o0; f1 := f0; g1 := g0;
  <span style="color: #66f;">(* </span><span style="color: #66f;">this nonsense was necessary because silly PASCAL</span>
<span style="color: #66f;">  does not allow indexed access into constant strings *)</span>
<span style="color: #00ffff;">FOR</span> ch := chr(0) <span style="color: #00ffff;">TO</span> chr(255) <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">BEGIN</span> f[ch] := -1; g[ch] := -1 <span style="color: #00ffff;">END</span>;
<span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> numterminals <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">BEGIN</span>
    f[i1[i]] := ord(f1[i]) - ord(<span style="color: #00ff00;">'0'</span>);
    g[i1[i]] := ord(g1[i]) - ord(<span style="color: #00ff00;">'0'</span>);
    o[i1[i]] := o1[i]
    <span style="color: #00ffff;">END</span>;
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">initialise *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">getch</span>;
<span style="color: #00ffff;">BEGIN</span>
<span style="color: #00ffff;">REPEAT</span>
    <span style="color: #00ffff;">read</span>(ch)
    <span style="color: #00ffff;">UNTIL</span> ch &gt; <span style="color: #00ff00;">' '</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">getch *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">putch</span>;
<span style="color: #ff00ff;">VAR</span> c : <span style="color: #ff00ff;">char</span>;
<span style="color: #00ffff;">BEGIN</span>
c := o[s[t]];
<span style="color: #00ffff;">IF</span> c &lt;&gt; <span style="color: #00ff00;">' '</span> <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span>
    cx := cx + 1;
    code[cx] := c;
    <span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span> writeln(big_tab,big_tab,c);
    <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">putch *)</span>

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">main *)</span>
initialise;
finished := false;
<span style="color: #00ffff;">REPEAT</span>
    writeln(<span style="color: #00ff00;">'ready'</span>);
    tracing := false;
    getch;
    <span style="color: #00ffff;">IF</span> ch = <span style="color: #00ff00;">'.'</span> <span style="color: #00ffff;">THEN</span> finished := true <span style="color: #00ffff;">ELSE</span>
        <span style="color: #00ffff;">BEGIN</span>
        <span style="color: #00ffff;">IF</span> ch = <span style="color: #00ff00;">'?'</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span> tracing := true; getch <span style="color: #00ffff;">END</span>;
        <span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span> writeln(s_header,i_header,p_header);

        <span style="color: #66f;">(* </span><span style="color: #66f;">BEGIN precedence function algorithm *)</span>
        s[0] := marker; t := 0;
        cx := 0;
        <span style="color: #00ffff;">WHILE</span> (s[t] &lt;&gt; marker) <span style="color: #00ffff;">OR</span> (ch &lt;&gt; marker) <span style="color: #00ffff;">DO</span>
            <span style="color: #00ffff;">BEGIN</span>
            <span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span>
                <span style="color: #00ffff;">BEGIN</span>
                <span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> t <span style="color: #00ffff;">DO</span> <span style="color: #00ffff;">write</span>(s[i]);
                <span style="color: #00ffff;">FOR</span> i := t+1 <span style="color: #00ffff;">TO</span> 15 <span style="color: #00ffff;">DO</span> <span style="color: #00ffff;">write</span>(<span style="color: #00ff00;">' '</span>);
                writeln(<span style="color: #00ff00;">'     '</span>,ch)
                <span style="color: #00ffff;">END</span>;
            <span style="color: #00ffff;">IF</span>  f[s[t]] &lt;= g[ch]  <span style="color: #00ffff;">THEN</span>
                <span style="color: #00ffff;">BEGIN</span>                           <span style="color: #66f;">(* </span><span style="color: #66f;">shift *)</span>
                t := t+1; s[t] := ch;
                getch
                <span style="color: #00ffff;">END</span>
              <span style="color: #00ffff;">ELSE</span>
                <span style="color: #00ffff;">REPEAT</span>                          <span style="color: #66f;">(* </span><span style="color: #66f;">reduce *)</span>
                    putch;
                    t := t-1
                    <span style="color: #00ffff;">UNTIL</span> f[s[t]] &lt; g[s[t+1]]
            <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE *)</span>
        <span style="color: #00ffff;">write</span>(<span style="color: #00ff00;">'POSTFIX CODE : '</span>);
        <span style="color: #00ffff;">FOR</span> i := 1 <span style="color: #00ffff;">TO</span> cx <span style="color: #00ffff;">DO</span> <span style="color: #00ffff;">write</span>(code[i]);
        writeln
        <span style="color: #66f;">(* </span><span style="color: #66f;">END precedence function algorithm *)</span>

        <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">ELSE *)</span>
    <span style="color: #00ffff;">UNTIL</span> finished;
<span style="color: #00ffff;">END</span>. <span style="color: #66f;">(* </span><span style="color: #66f;">main *)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Exercises and reading</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> <i>Ad hoc error detection</i>:</h3>
<div class="outline-text-3" id="text-5-1">
<p>
The precedence function algorithm cannot detect errors, because for any symbol on top of the stack and any input symbol, one of the three relations <code>&gt;</code>, <code>=</code>, <code>&gt;</code> must hold for their <code>f</code>- and <code>g</code>-values.  Hence there is no way of encoding error conditions, as was done with the matrix of precedence relations.  For example, the algorithm will happily shift two adjacent atoms on the stack.  Find a way of adding extra <i>ad hoc</i> code to the algorithm so that errors can be handled correctly.  You might experiment with a further function, say <code>h</code>.
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> <i>Parsing without tables</i>:</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Both programs are general, they are driven by tables which specify the input language and the translation.  It would be possible to write both programs without the tables.  Essentially this amounts to building the information which is now in the tables into the programs.  Rewrite either the precedence relations program or the precedence functions program in this way.
</p>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> <i>Changing the tables</i>:</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Experiment with changing the table in the <code>VALUE</code> part of the precedence relations program, or the tables in the <code>CONST</code> part of the precedence functions program.  Can you change them so that the input language is in fully parenthesised infix or in prefix? If not, why not?
</p>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> <i>Evaluator</i>:</h3>
<div class="outline-text-3" id="text-5-4">
<p>
For either the precedence relations or the precedence functions program, modify the algorithm and then the program and the tables so as to make an evaluator for formulas without variables but only with constants <code>0</code> and <code>1</code>.
</p>

<p>
Write a parser which uses the method described towards the end of the first section of this chapter.  Your program could be, but need not be, driven by some kind of data structure playing the role of the tables used here.  Augment your parser so that it becomes a translator.
</p>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> <i>Non-recursive truth table program</i>:</h3>
<div class="outline-text-3" id="text-5-5">
<p>
Our truth table program had essentially three tasks to perform:
</p>

<ol class="org-ol">
<li>to translate from infix to postfix,
</li>
<li>to generate all combinations of truth values, and
</li>
<li>to evaluate the postfix.
</li>
</ol>

<p>
Our program used recursion for 1) and 2), but used an explicit stack for 3).  Now this chapter has shown how to do 1) without recursion.  Can you think of a non-recursive way of doing 2)?  This would give you a truth table program which does not use recursion at all.  It should even be possible to write the entire program without any procedures; but many people would argue that such a style is unclear.
</p>
</div>
</div>
<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> <i>Reading</i>:</h3>
<div class="outline-text-3" id="text-5-6">
<p>
For a different exposition of operator precedences and a translator from arithmetic infix to postfix which also uses a two dimensional table but with slightly different stack operations, see Collins (1986, pp 117 - 145).
</p>

<p>
For an operator precedence program which translates from infix to postfix but which is not table driven, see McCracken (1987, pp 111 - 120).
</p>

<p>
For a detailed theoretically oriented exposition of operator precedence parsing, see Aho and Ullman (1977, Section 5.3).
</p>

<p>
A short but usable exposition of LR parsing is given in Capon and Jinks (1988, p 95).
</p>

<p>
A more detailed exposition is in Sudkamp (1988, Chapters 15 and 16).
</p>

<p>
For a very comprehensive treatment of LR-parsing,
see Chapman (1987).
</p>
</div>
</div>
</div>
</div>
</body>
</html>
