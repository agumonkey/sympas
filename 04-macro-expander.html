<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 4 : Macro Expander</title>
<!-- 2013-05-31 Fri 19:10 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="author" content="michal"/>
<link rel="stylesheet" type="text/css" href="/etc/sympas/style.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Chapter 4 : Macro Expander</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. </a></li>
<li><a href="#sec-2">2. Text macro</a></li>
<li><a href="#sec-3">3. Designing the implementation</a></li>
<li><a href="#sec-4">4. Exercises and reading</a>
<ul>
<li><a href="#sec-4-1">4.1. <i>Manual</i>:</a></li>
<li><a href="#sec-4-2">4.2. <i>Capitals</i>:</a></li>
<li><a href="#sec-4-3">4.3. <i>Reading</i>:</a></li>
<li><a href="#sec-4-4">4.4. <i>A better macro processor</i>:</a></li>
<li><a href="#sec-4-5">4.5. <i>The C preprocessor</i>:</a></li>
<li><a href="#sec-4-6">4.6. <i>Reading</i>:</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> <a id="intro" name="intro"></a></h2>
<div class="outline-text-2" id="text-1">
<p>
In the previous two chapters we have seen two simple programs which translate and evaluate; the translation process and the evaluation process were fixed once and for all &#x2014; the user could not affect them.  In this chapter we shall see our first example of greater flexibility &#x2014; the user can define new symbols which after the definition can be used to mean whatever they were defined to mean.  Probably the simplest kind of definition is the literal replacement of a short text by a longer text.  This is called macro expansion.
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Text macro</h2>
<div class="outline-text-2" id="text-2">
<p>
Although macro expansion is such a simple notion, it is not all that well known.  For that reason we start off with a very simple example.  The text to follow is actually an input file to the macro expander &#x2014; it could equally well have been typed in directly from the terminal.  Note that it begins with a number of lines which start with a capital letter followed by the identity sign <code>=</code>.  These lines define the capital letter to be short hand for the quoted text to follow on the same line.  The definitions are followed by three skeleton notes &#x2014; to mum, mary and bill - and the capital letters defined earlier occur in these notes.  Here is the input file:
</p>

<pre class="example">
G = "H F"
S = "send more money"
M = "mum"
D = "dad"
H = "how are you?"
F = "i am fine."
J = "jeremy"

dear M,
G
please tell D to S.
    your loving son J

@
dear mary,
G
i have just written to my M.
i hope D will S.
    most affectionately, J

@
P = "%"
hi bill -
just wrote for the old man to S.
do you really expect me to pay 20P interest?
    j
%
</pre>

<p>
If the macro expanding program is run and given the above file as input, then it does the following: When reading the lines with the definitions, it associates with each defined capital letter the text which follows it in the definition.  When there are no more definitions, it starts reading characters from the input file and copies them to the output file &#x2014; except when it sees a capital letter which it will expand in accordance with the definition.  If the text of the definition contains a capital letter, this is expanded also.
</p>

<pre class="example">
dear mum,
how are you? i am fine.
please tell dad to send more money.
    your loving son jeremy

dear mary,
how are you? i am fine.
i have just written to my mum.
i hope dad will send more money.
    most affectionately, jeremy

hi bill -
just wrote for the old man to send more money.
do you really expect me to pay 20% interest?
    j
</pre>

<p>
The example illustrates almost everything the program can do, and it is not very much.  However, the program does illustrate how definitions are implemented, and it is sufficiently simple.  The simplicity was bought in part by not allowing capital letters in the output; one of the exercises invites you to remedy this.
</p>

<p>
The incomplete information you have now about the macro expander is fairly typical of a partial specification which a system designer receives from the client.  The designer then has to fill in the gaps in a reasonable way and present a complete specification to the client for approval.  Such a specification only describes the system as it will appear to the user, it does not describe how the implementation works.  One way to give the specification is to write a user manual for a system that has not been implemented yet.  Write such a manual now, fill in the gaps as you see fit, change minor details as you see fit, but explain your changes in notes.  DO IT NOW, DO NOT READ ANY FURTHER.
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Designing the implementation</h2>
<div class="outline-text-2" id="text-3">
<p>
How should text bodies of defined macros be stored?  This is a design decision that should be made quite early.  One way is to have fixed length strings, one for each of the potential bodies, and then no body can exceed the maximum length.  But then a lot of space is wasted by unused and short macros.  Another way is to have one large memory or string space, and for each of the 26 potential bodies have two pointers into this space, indicating where it starts and where it finishes.  In addition we need an integer to keep track of what the last used part of the memory is.
</p>

<p>
The main program has to initialise each of the 26 starting pointers to zero, indicating that nothing has been defined.  Also, the variable for the last used memory has to be initialised to zero.  At this point the program enters a major loop to read definitions and to expand text.  Each pass through the loop admits an optional definition phase and then an expansion phase.  In the example given, definitions occurred only during the first and third pass; in passes other than the first any previous definitions are still in force, but they could have been overwritten.  Passes through the loop have to be controlled by special characters: if the loop is to be re-entered then a separator character is used at the end of the text to be expanded, otherwise a terminator character is used.  Of course the separator and terminator are not copied to the output file.  To allow for even the (perverse) case of an input file whose first printing character is the terminator, the loop should be a <code>WHILE</code> statement whose entry condition is that the last printing character read is not the terminator.  Before the <code>WHILE</code> loop the program has to read the first printing character, skipping over white space which might precede the definitions.  Since skipping over white space has to be done elsewhere in the program, the task is delegated to a procedure <code>getch</code> whose body is essentially familiar.  The body of the major loop has to process any optional definitions and a text to be expanded; these two tasks have to be done by two minor loops.
</p>

<p>
A minor <code>WHILE</code> loop for the definitions is entered first, its entry condition is that the current character is a capital letter, a permitted macro name.  That character has to be saved in another variable so that access to the as yet unread text body of the current macro definition can be stored there.  The next printing character has to be <code>=</code>, otherwise an error has to be reported.  The next printing but otherwise arbitrary character will serve as the quote to begin and end the text body of the macro; the device enables the body of a macro to contain any characters except the chosen quote.  The next character read will normally be the start character of the body of the current macro, and this has to be recorded.  Now a further loop is needed to read the body of the macro.  Since the body might be empty, it must be a <code>WHILE</code> loop whose entry condition is that the character is not the ending quote.  Inside this loop we have to check that there is space left in the memory, if there is not, then a message to that effect should be written and the program aborted.  (It might be argued that some other action is called for.)  In the normal case the last character read has to be inserted in the next position in the string memory.  Upon exit from this loop the position of the finish character in the body of the current macro can be recorded and the next printing character read.  This might be a capital letter, and if it is then the enclosing <code>WHILE</code> loop is re-entered.  If it is not, it should be the first character of the text to be expanded.
</p>

<p>
But there is a complication.  What happens if the text to be expanded is a macro call, a capital letter?  That would mean that this capital letter would be seen by the previous loop as the beginning of another macro definition.  To allow for this case, an optional masking character is needed which is not a capital letter (and, less importantly, not a character that commonly occurs at the beginning of text to be expanded).  If this masking character is present, it is simply read past.  Only now can the text expansion loop be entered.  To allow for empty text, it is again a <code>WHILE</code> loop which is not even entered if the character is the terminator or the separator.  In the body of this loop the character has to be written or expanded, and in case it was the last character of a line, a new line has to be started on the output.  Only then can the next character be read, and this ends the body of the expansion loop.
</p>

<p>
If the writing or expanding of a single character requires expanding because it is a capital letter, it can lead to further expansion if the body of the macro contains calls to others.  In that case upon return from expanding the other macros the expanding of the current macros has to be resumed.  This calling can go on for several levels, and every return has to be dealt with properly.  The simplest way to handle this is by means of a procedure which calls itself recursively.  As a parameter it takes a character to be written or expanded.  In its body, if the parameter is not a macro call it is written to the output.  If it is a macro letter we have to look up the start and the finish position for the body of this macro, and use a <code>FOR</code> loop to recursively write or expand each of the relevant characters in the string memory.  But what happens if a macro calls itself &#x2014; either directly or indirectly (<code>A</code> calls <code>B</code> which calls <code>C</code> which calls <code>A</code>)?  The expansion process would go on for ever.  Such recursive expansion has to be blocked, and the simplest method is to keep track of which macros have been called.  This is best done by a global set of called macro characters <code>A</code> .. <code>Z</code> which is initialised to empty before the global text expansion loop is entered.  In the procedure any macro expansion is preceded by a test that the parameter character has not yet been expanded, otherwise an error is reported and no expansion takes place.  If the expansion is permissable, then the <code>FOR</code> loop can be executed.  But before the loop the parameter character has to be added to the set of called macros, and, very importantly, after the loop it has to be removed.
</p>

<p>
The only other procedure to mention is the error handler, called during definitions for missing <code>=</code> and during expansion for recursive calls.  It is essentially familiar.  The choice of the terminator, separator and masker characters is somewhat arbitrary and therefore they are best defined in <code>CONST</code> declarations at the beginning of the program.  The characters <code>@</code>, <code>%</code> and <code>:</code> are as reasonable as any.
</p>

<p>
At the end of the previous section you were urged to write a user manual based on incomplete information.  If you did, compare some of your details with the details in this implementation design.  If you did not, write a user manual now which precisely reflects this implementation design.
</p>

<div class="org-src-container">

<pre class="src src-pascal"><span style="color: #00ffff;">PROGRAM</span> <span style="color: #ffffff; font-weight: bold;">macrox</span>(input,output);
<span style="color: #66f;">(* </span><span style="color: #66f;">Macro expander *)</span>

LABEL 1, 99;

<span style="color: #ff00ff;">CONST</span>
  separator = <span style="color: #00ff00;">'@'</span>;
  terminator = <span style="color: #00ff00;">'%'</span>;
  masker = <span style="color: #00ff00;">':'</span>;
  maxmemory = 10000;

<span style="color: #ff00ff;">TYPE</span>
  string20 = <span style="color: #ff00ff;">PACKED</span> <span style="color: #ff00ff;">ARRAY</span> [1..20] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;

<span style="color: #ff00ff;">VAR</span>
  ch, current, quote : <span style="color: #ff00ff;">char</span>;
  macros : <span style="color: #ff00ff;">ARRAY</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">RECORD</span> start,finish : <span style="color: #ff00ff;">integer</span> <span style="color: #00ffff;">END</span>;
  memory : <span style="color: #ff00ff;">ARRAY</span> [1..maxmemory] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;
  lastused : <span style="color: #ff00ff;">integer</span>;
  called : <span style="color: #ff00ff;">SET</span> <span style="color: #00ffff;">OF</span> <span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>;

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">getanych</span>;
<span style="color: #00ffff;">BEGIN</span>
<span style="color: #00ffff;">IF</span> eof <span style="color: #00ffff;">THEN</span>  <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">99</span>;
<span style="color: #00ffff;">read</span>(ch)
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">getanych *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">getch</span>;
<span style="color: #00ffff;">BEGIN</span>
<span style="color: #00ffff;">REPEAT</span>
    getanych
    <span style="color: #00ffff;">UNTIL</span> ch &gt; <span style="color: #00ff00;">' '</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">getch *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">error</span>(s : string20);
<span style="color: #00ffff;">BEGIN</span>
writeln; writeln(<span style="color: #00ff00;">'error : '</span>,s);
readln;
<span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">1</span>
<span style="color: #00ffff;">END</span>;

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">expand</span>(c : <span style="color: #ff00ff;">char</span>);
<span style="color: #ff00ff;">VAR</span> i : <span style="color: #ff00ff;">integer</span>;
<span style="color: #00ffff;">BEGIN</span>
<span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">NOT</span> (c <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>]) <span style="color: #00ffff;">THEN</span> <span style="color: #00ffff;">write</span>(c) <span style="color: #00ffff;">ELSE</span>
    <span style="color: #00ffff;">IF</span> c <span style="color: #00ffff;">IN</span> called <span style="color: #00ffff;">THEN</span> error(<span style="color: #00ff00;">'recursive call      '</span>) <span style="color: #00ffff;">ELSE</span>
        <span style="color: #00ffff;">BEGIN</span>
        called := called + [c];
        <span style="color: #00ffff;">WITH</span> macros[c] <span style="color: #00ffff;">DO</span>
            <span style="color: #00ffff;">FOR</span> i := start <span style="color: #00ffff;">TO</span> finish <span style="color: #00ffff;">DO</span>
                expand(memory[i]);
        called := called - [c]
        <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">expand *)</span>

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">main *)</span>
<span style="color: #00ffff;">FOR</span> current := <span style="color: #00ff00;">'A'</span> <span style="color: #00ffff;">TO</span> <span style="color: #00ff00;">'Z'</span> <span style="color: #00ffff;">DO</span> macros[current].start := 0;
lastused := 0;
1:
writeln;
<span style="color: #00ffff;">WHILE</span> ch &lt;&gt; terminator <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">major loop *)</span>
    getch;
    <span style="color: #00ffff;">WHILE</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>] <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">minor macro definition loop *)</span>
        current := ch; getch;
        <span style="color: #00ffff;">IF</span> ch = <span style="color: #00ff00;">'='</span> <span style="color: #00ffff;">THEN</span> getch <span style="color: #00ffff;">ELSE</span> error(<span style="color: #00ff00;">'"=" expected        '</span>);
        quote := ch; getanych;
        macros[current].start := lastused + 1;
        <span style="color: #00ffff;">WHILE</span> ch &lt;&gt; quote <span style="color: #00ffff;">DO</span>
            <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">macro body *)</span>
            <span style="color: #00ffff;">IF</span> lastused = maxmemory <span style="color: #00ffff;">THEN</span>
                <span style="color: #00ffff;">BEGIN</span>
                writeln(<span style="color: #00ff00;">'string space exhausted, abort'</span>);
                <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">99</span>
                <span style="color: #00ffff;">END</span>;
            lastused := lastused + 1;
            memory[lastused] := ch;
            getanych
            <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE, macro body *)</span>
        macros[current].finish := lastused;
        getch
        <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE, minor macro definition loop *)</span>
    <span style="color: #00ffff;">IF</span> ch = masker <span style="color: #00ffff;">THEN</span> getch;
    called := [];
    <span style="color: #00ffff;">WHILE</span> <span style="color: #00ffff;">NOT</span> (ch <span style="color: #00ffff;">IN</span> [separator,terminator]) <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">minor text expansion loop *)</span>
        expand(ch);
        <span style="color: #00ffff;">IF</span> eoln <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span> readln; writeln <span style="color: #00ffff;">END</span>;
        getanych
        <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE, minor text expansion loop *)</span>
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE, major loop *)</span>
99:
<span style="color: #00ffff;">END</span>. <span style="color: #66f;">(* </span><span style="color: #66f;">main *)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Exercises and reading</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> <i>Manual</i>:</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Write a user manual based on just the information that you have before you now.  (This may or may not include access to the source.)
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> <i>Capitals</i>:</h3>
<div class="outline-text-3" id="text-4-2">
<p>
Modify the macro expander so that it will be able to deal with capital letters as text.  All macro calls should then consist of a <i>wake up</i> character followed by the single letter name of the macro.  For example, <code>$</code> could be the wake up character, and then calls would look like this: <code>Dear $M, &#x2026; Please tell $D to $S.</code>.  You will have to re-think the expansion process in some detail.  Alternatively, though this is less convenient for the user, to get capital letters into the text they could be quoted: ='Dear M, &#x2026; 'Please tell D &#x2026;=.
</p>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> <i>Reading</i>:</h3>
<div class="outline-text-3" id="text-4-3">
<p>
For a really usable and very sophisticated macro processor, see Kernighan and Plauger (1981, Ch. 8).  If you have access to Unix, study the manual for the m4 processor (say <code>man m4</code>).
</p>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> <i>A better macro processor</i>:</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Implement either the first or the second version of the macro processor in Kernighan and Plauger.  Note that their version was originally written in the language C.  Can you write a version with an absolute minimum of procedures, by <i>unfolding</i> as many calls as possible?  Which style do you consider better?
</p>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> <i>The C preprocessor</i>:</h3>
<div class="outline-text-3" id="text-4-5">
<p>
This is a utility that is often invoked automatically with the compiler for the C programming language.  One of its powerful features is macro definition and expansion.  If you have access to UNIX, say <code>man cpp</code>.
</p>
</div>
</div>
<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> <i>Reading</i>:</h3>
<div class="outline-text-3" id="text-4-6">
<p>
For another macro processor, this time geared to processing Pascal programs, see a description in Comer (1979) and the actual program in Comer (1980).
</p>

<p>
Another macro expander, for macros with parameters, is given in Schwartz <i>et al</i> (1986, pp 457 - 462). The program is written in the very high level language SETL which is not widely available; however, the program could serve as a design for a program in a different language such as Pascal.
</p>

<p>
A macro expansion facility is often provided as part of an assembler, and the macros are then geared to the assembly language. An assembler with macros is given as a Pascal program in Terry (1986, Chapter 4).  Calingaert (1979 Chapter 4) gives pseudo-code for several macro expanders of increasing power.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
