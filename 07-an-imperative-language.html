<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 7 : An Imperative Language</title>
<!-- 2013-05-31 Fri 19:02 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="author" content="michal"/>
<link rel="stylesheet" type="text/css" href="/etc/style.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Chapter 7 : An Imperative Language</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. </a></li>
<li><a href="#sec-2">2. User manual</a></li>
<li><a href="#sec-3">3. Designing the implementation</a>
<ul>
<li><a href="#sec-3-1">3.1. Implementing the syntax</a></li>
<li><a href="#sec-3-2">3.2. Step 1: <i>Visibility requirements</i>:</a></li>
<li><a href="#sec-3-3">3.3. Step 2: <i>Bodies of parsing procedures</i>:</a></li>
<li><a href="#sec-3-4">3.4. Step 3: <i>Declarations</i>:</a></li>
<li><a href="#sec-3-5">3.5. Step 4: <i>Type checking</i>:</a>
<ul>
<li><a href="#sec-3-5-1">3.5.1. Implementing the semantics</a></li>
</ul>
</li>
<li><a href="#sec-3-6">3.6. Step 5: <i>Designing the internal code</i>:</a></li>
<li><a href="#sec-3-7">3.7. Step 6: <i>Translating into internal code</i>:</a></li>
<li><a href="#sec-3-8">3.8. Step 7: <i>Interpreting the internal code</i>:</a></li>
</ul>
</li>
<li><a href="#sec-4">4. The program</a></li>
<li><a href="#sec-5">5. Exercises and reading</a>
<ul>
<li><a href="#sec-5-1">5.1. <i>Changing the implementation</i>:</a></li>
<li><a href="#sec-5-2">5.2. <i>Changing the language</i>:</a></li>
<li><a href="#sec-5-3">5.3. <i>Reading</i>:</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> <a id="intro" name="intro"></a></h2>
<div class="outline-text-2" id="text-1">
<p>
This chapter aims to give more fluency in the use of block structure and mutual recursion, and more confidence in writing larger programs than those in Part One of this book.  The program described here is a compiler interpreter for a very small imperative language.  None of the concepts of the language are new, so the language is first described by a user manual.
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> User manual</h2>
<div class="outline-text-2" id="text-2">
<p>
The language TYPROC is a very small imperative language.  It has assignment statements, I-O statements and structured flow of control statements including recursive calls of previously declared procedures.  Variables are global, and they have to be declared as being of either type Boolean or type integer.  Expressions are built from variables and literal constants by means of a small number of inbuilt operators.  Strict type checking is maintained throughout.  The language is not intended for serious use but as an illustration in language implementation and documentation.
</p>

<p>
The language is described by the following BNF productions for the context free syntax, and by the accompanying text for the context sensitive syntax and for the semantics.
</p>

<pre class="example">
input-file ::=
    [ programme ] '.'
</pre>

<p>
The processor reads an input file consisting of zero or more programs which are processed as soon as they have been read, terminated by a period.
</p>

<pre class="example">
programme  ::=
    'BOOLEAN' [ ( 'a' | 'b' .. 'z' ) ]
    'INTEGER' [ ( 'a' | 'b' .. 'z' ) ]
    [ ( 'A' | 'B' .. 'Z' ) body ]
    body '.'
</pre>

<p>
A program consists of declarations of variables and procedures and a body.  Variables are just lower case letters, and they are typed as Boolean or integer.  Procedures are upper case letters, and their declaration is followed by a body.  Variables and procedures have to be declared before they can be used in a body, and they cannot be redeclared.  When a programme has been read, execution begins with its body.
</p>

<pre class="example">
body  ::=
    'BEGIN' statement-sequence 'END'
statement-sequence  ::=
    statement [ ';' statement ]
</pre>

<p>
A body is a statement sequence enclosed in <code>BEGIN</code> and <code>END</code>.  A statement sequence consisting of one or more statements separated by semicolons is executed by executing the statements one after another.
</p>

<pre class="example">
statement  ::=
    ( 'a' | 'b' .. 'z' ) '=' expression |
    'A' | 'B' .. 'Z' |
    'BEGIN' statement-sequence 'END' |
    'IF' expression 'THEN' statement |
    'WHILE' expression 'DO' statement |
    'READ' ( 'a' | 'b' .. 'z' ) |
    'WRITE' expression |
    'LINE' |
    'TAB'
</pre>

<p>
There are several kinds of statements.  Assignment statements are of the form <code>v = e</code>, where <code>v</code> is a variable that has been declared and <code>e</code> is an expression of the same type.  Execution has the effect of evaluating <code>e</code> and assigning its value to <code>v</code>.  Procedure calls are of the form <code>P</code>, where <code>P</code> is a procedure that has been declared; execution has the effect of executing the body of <code>P</code>.  Compound statements provide a means of executing a sequence of statements in <code>IF</code> and <code>WHILE</code> statements.  In <code>IF</code> and <code>WHILE</code> statements the expression must be of type Boolean.  In an <code>IF</code> statement the <code>THEN</code> part is executed only if the expression evaluates to true.  In a <code>WHILE</code> statement the <code>DO</code> part is executed zero or more times, as long as the expression evaluates to true.  In <code>READ</code> statements the variable has to have been declared, execution has the effect of reading from the input file either an integer or a Boolean value and assigning this to the variable.  <code>WRITE</code> statements will evaluate the expression, which may be of either type, and write its value to the output file.  <code>LINE</code> statements start a new line, <code>TAB</code> statements write a tab.
</p>

<pre class="example">
expression  ::=
    simple-expression { ('&gt;' | '&lt;' | '=' ) simple-expression }
</pre>

<p>
An expression is either a simple expression or two simple expressions separated by a comparison operator.  In the second case the type of the expression will be Boolean, and the expression will be evaluated to true if the comparison holds between the values of the two simple expressions.
</p>

<pre class="example">
simple-expression  ::=
    term [ ( '+' | '-' | '#' ) term ]
</pre>

<p>
A simple expression consists of one or more terms separated by addition, subtraction or disjunction operators.  The term on the left and the term on the right have to be of the same type.  For the two arithmetic operators the types have to be integer, for the disjunction operator the types have to be Boolean.  The result type of the simple expression is that of its terms.  During evaluation the terms are evaluated left to right and the operation is applied to their values.
</p>

<pre class="example">
term  ::=
    factor [ ( '*' | '/' | '&amp;' ) factor ]
</pre>

<p>
A term consists of one or more factors separated by multiplication, division or conjunction operators.  The factors have to be of the same type, integer for the arithmetic operators and Boolean for conjunction, and the result type is the same as that of the factors.  Evaluation is left to right.
</p>

<pre class="example">
factor  ::=
    'a' | 'b' .. 'z' |
    ( '0' | '1' .. '9' ) [ ( '0' | '1' .. '9' ) ] |
    '(' expression ')' |
    '-' factor |
    'TRUE' |
    'FALSE |
    'ORD' factor
</pre>

<p>
A factor can be a variable that has been previously declared, the result type of the factor is that of the variable.  A factor can also be a string of decimal digits interpreted as an integer (up to an implementation dependent number of bits, typically 32), and the result type is integer.  A factor can be a parenthesised expression of either type, and that will be the result type.  A factor can be a negated factor of type Boolean, and its result type is Boolean, note that <code>-</code> is <i>overloaded</i>: as an infix operator it means subtraction, as a prefix operator it means negation.  A factor can also be one of the two Boolean constants, giving result type Boolean.  Finally, a factor can be the <code>ORD</code> function applied to a factor of any type, the result type is integer; if the contained factor is of type integer, then <code>ORD</code> is the identity function, and if the contained factor is of type Boolean, then <code>ORD</code> evaluates to 0 for false and to 1 for true.
</p>

<p>
Comments are written just inside curly braces like this: <code>{ this is a comment }</code>.  The grammar as given does not explain this, and indeed most documentations for languages leave such a detail to the informal explanations.  Comments are generally treated like white space.
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Designing the implementation</h2>
<div class="outline-text-2" id="text-3">
<p>
For the implementation of this language we shall distinguish syntax and semantics rather thoroughly.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Implementing the syntax</h3>
<div class="outline-text-3" id="text-3-1">
<p>
In all our previous programs the basic symbols were single printing characters.  In this language symbols consist of either single letters for user declared variables and procedures, or inbuilt single letter special characters, or inbuilt multi capital letter words.  The procedure for reading symbols, called <code>getsym</code>, has to be able to detect these multi character symbols.  After skipping any non-printing characters, it has to examine the current character: If it is a capital and the next character waiting in the input is also a capital, then the two capitals and any following capitals are collected in a short string.  If the current character is an opening brace for a comment, characters are skipped up to the closing brace and the procedure starts again.  In all other cases the procedure does not read beyond the current single character.  The language was designed to make this simple technique possible.  The procedure <code>getsym</code> is an unusually simple scanner for a language with multi-character symbols.  Indeed, it does not have to know much about the language to be parsed.  Other scanners that we shall see in later chapters are much more complex, and some even make use of auxiliary tables.  But often this will have the advantage that the parser does not need to know much about how symbols are written.  The simple scanner given here has to delegate most of the recognition of symbols to the parser.  Consequently, much surface detail has to be spread throughout the program.  For example, the maximum length of the string for multi-character symbols is spread all over the parser.  Hence there cannot be a constant declaration to set the maximum length (to 8 or whatever).
</p>

<p>
For the parsing procedures we now distinguish various steps in the design.  If you are writing the program yourself, you are advised to maintain a discipline of steps similar to the ones used here.  The steps continue in the next section on semantics.
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Step 1: <i>Visibility requirements</i>:</h3>
<div class="outline-text-3" id="text-3-2">
<p>
A detailed examination of the grammar shows that the productions are already ordered in a convenient way: each non-terminal needs access either to one defined earlier, or to itself, or to the one immediately following.  Hence all visibility requirements will be satisfied if all the parsing procedures are nested successively as in the grammar, <code>programme</code> outermost, <code>factor</code> innermost.
</p>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Step 2: <i>Bodies of parsing procedures</i>:</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Most of this should be routine by now, except that a CASE statement can no longer be used for the non-terminals which have alternatives.  Because some symbols are single characters and some are short strings, a cascade of <code>IF-THEN-ELSE-IF-..</code> has to be used in the parsing procedures for factor and for statement.  Wrong symbols produce a call to the by now familiar error handler.
</p>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Step 3: <i>Declarations</i>:</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Inside <code>programme</code>, whenever a variable is declared, then this fact should be noted, and the type also needs recording.  In this simple language we can manage by entering declared variables into an appropriate set &#x2014; one for the integers, and one for the Booleans.  Whenever a procedure is declared, it is entered into a set of procedures.  Then inside <code>statement</code>, for the variable in an assignment statement it has to be checked that it is in one of the two sets of declared variables.  Also inside <code>statement</code>, calls of procedures have to be checked.  Finally, inside <code>factor</code> any variables have to be checked.
</p>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Step 4: <i>Type checking</i>:</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Inside <code>factor</code> all variables, the numeric constants and the Boolean constants have one of two types, and these types have to be transmitted to the procedure which called <code>factor</code>.  Also inside <code>factor</code>, a check has to be made that the negand was of type Boolean, and the result will be of type Boolean.  For <code>ORD</code> no type check is made, but the result will be integer.  For terms, simple expressions and expressions containing infix operators a check has to be made that the operands are appropriate for the infix operator.  For terms and simple expressions the result type is the same as that of the operands, for expressions the result type Boolean is returned.  The appropriate implementation mechanism is similar to the one for returning values in the infix evaluator of Chapter 3: each of the above procedures needs a <code>VAR</code> parameter whose possible values are of two types, and each of the procedures for infix operators need a similar local variable for the second operand.  A local variable is also needed inside <code>statement</code> for calls of <code>expression</code>.  This occurs inside assignment statements for which type agreement of the variable and the expression has to be checked.  It also occurs in <code>IF</code> and <code>WHILE</code> statements for which the expression must be Boolean.  In <code>WRITE</code> statements no type check is needed for the expression, but the type of the expression will determine what code is to be generated later.
</p>
</div>

<div id="outline-container-sec-3-5-1" class="outline-4">
<h4 id="sec-3-5-1"><span class="section-number-4">3.5.1</span> Implementing the semantics</h4>
<div class="outline-text-4" id="text-3-5-1">
<p>
Up to this point we have been concerned with syntax only.  Some earlier authors would have called steps 3 and 4 <i>static semantics</i>, but this was based on the misconception that syntax has to be context free.  Semantics assigns meanings to the symbols of the language and to the more complex constructions.  A simple example is that <code>&amp;</code> means AND.  Assignment of meaning was done directly in the infix evaluator of Chapter 3, but here it has to be done indirectly.  Loops may result in their bodies being executed several times, so for the same reason as for the truth table generator of Chapter 5, the code has to be stored internally.  So the semantics requires an indirect assignment of meaning to the language seen by the user, by first specifying a translation scheme and then assigning meaning to translations.  For example, <code>&amp;</code> is translated internally to <code>conj</code> which means AND.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> Step 5: <i>Designing the internal code</i>:</h3>
<div class="outline-text-3" id="text-3-6">
<p>
Whereas postfix code as in the truth table generator is good for evaluating expressions, something else is needed for the execution of loops or of conditionals.  Essentially we should like to say something like this:
</p>

<pre class="example">
A term can be 'F1 &amp; F2',
        where F1 and F2 are factors,
    and its translation is: and-op(G1,G2)
        where G1 and G2 are the translations of F1 and F2,
    whose value is: V1 AND V2,
        where V1 and V2 are the values of G1 and G2.
A statement can be 'WHILE E DO S'
        where E is an expression, and
        where S is a statement,
    and its translation is: while-op(F,T),
        where F and T are the translations of E and S,
    which is executed:
        WHILE the value of F (is true) DO execute T.
</pre>

<p>
Note that <code>F1 &amp; F2</code> and <code>WHILE E DO S</code>, as they occur in the first lines, belong to the object language whose meaning is being explained; we are not expected to know the meaning of either.  Of course we and the Pascal compiler are supposed to know what <code>AND</code>, <code>WHILE</code> and <code>DO</code> mean where they occur unquoted near the end.
</p>

<p>
We now have to think of a way of representing such translations.  A uniform way of doing this is to think of <code>conj</code> and <code>while</code> as operators with two arguments which are pointers to other, possibly complex things.  Those other things can also consist of operators with two pointers, but ultimately there must be operands which do not point to anything.  Pointers indicate an address where something is to be found, we can use integer pointers into an <code>ARRAY</code> of three-part =RECORD=s with an operator and two integers.  The integers are also used to hold addresses of variables or the code of procedures, and to represent numeric and Boolean constants.
</p>
</div>
</div>
<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> Step 6: <i>Translating into internal code</i>:</h3>
<div class="outline-text-3" id="text-3-7">
<p>
Once the internal code has been designed, it is an easy matter to produce the translations during the parsing.  The translation is very similar to translation into postfix in the truth table generator.  Each translation step is handled by a call to a code generating procedure, which is similar to the one in the truth table generator.  But instead of one parameter, it has three: an operator and two integers, and it deposits the values of the three in another <code>RECORD</code>.  The two integers have to be known at the time the call is made.  For variables and constants in <code>factor</code> this is no problem, for the arithmetic and Boolean operators it has to be done when the address of the code for the operands is known, after the second operand has been processed.  So the order of generation is the same as that for postfix code.  The address of the code for the second operand will be the most recently generated code, so that is easily accessible.  But the address of the code for the first operand will be lost by now; so that has to be saved in a local variable when the infix operator is seen.  Since the procedures for infix operators can each process several, in fact three, different operators each, the source operators also have to be saved in another local variable so that the correct internal code can be generated.  The mechanism is already familiar from the truth table generator in procedure formula.  Essentially the same mechanism is used in the parsing procedure for statements and for statement sequences; for the latter it should be noted that semicolons produce code in the same way that <code>+</code> does.  Inside <code>programme</code> no code is generated for declarations, but for a procedure the last code generated by its body has to be attached to the name of the procedure, so that a call to this code can be generated when the procedure is called inside <code>statement</code>.
</p>
</div>
</div>
<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8"><span class="section-number-3">3.8</span> Step 7: <i>Interpreting the internal code</i>:</h3>
<div class="outline-text-3" id="text-3-8">
<p>
The code for the body of the (main) programme will be the last code that has been generated.  This can now be interpreted by either real hardware or by a software interpreter.  Both would need space for the variables of the program; the way it has been designed here all 26 potential variables need to be given space.  For a hardware interpreter the internal code would have to be loaded into another space, but for our software interpreter it is already there.  So when the entire programme has been read, checked for errors and translated, the main program should pass it onto an interpreter which has an <code>ARRAY</code> of 26 integers for the potential variables.  Then the body of the programme has to be executed.  During execution expressions will have to be evaluated, both Boolean and integer.  So a natural way to think of the entire interpretation is that it involves recursive calls of a procedure for executing statements and two functions for evaluating expressions.  The procedure and the functions each take an integer parameter which is the index of a <code>RECORD</code> in the code <code>ARRAY</code>, and each makes a <code>CASE</code> decision based on the operator part of the <code>RECORD</code>.  The cases resemble those in the infix evaluator and the truth table generator, and when there are recursive calls then one or both of the integer parts of the <code>RECORD</code> are used as parameters of the call.
</p>

<p>
If a program is preceded by <code>?</code>, then the code for every body will be displayed when the body has been read.  If a program is not terminated by <code>.</code> but by <code>?</code>, then the execution will be traced.  These two facilities were not mentioned in the user manual, they are supposedly secret information, known only to the implementor who is checking the internal workings.
</p>

<p>
The following is a sample run from TYPROC:
</p>

<pre class="example">
ready
{ demonstrating generated code and tracing of execution }
{ request to display the code after translation: } ?
INTEGER i
BEGIN
i = 1010101;
WRITE 42 * i
END
                code for this body :
               1             IMMED   1010101         0
               2           IASSIGN         8         1
               3             IMMED        42         0
               4             FETCH         8         0
               5               MUL         3         4
               6            IWRITE         0         5
               7           SEMICOL         2         6

{ request to trace execution: } ?
                interpreting ...
               7           SEMICOL         2         6
               2           IASSIGN         8         1
               1             IMMED   1010101         0
               6            IWRITE         0         5
               5               MUL         3         4
               3             IMMED        42         0
               4             FETCH         8         0
  42424242
  variable     value
         i   1010101
ready

{ request to display the code after translation: } ?
BOOLEAN p q
BEGIN
p = TRUE;
q = FALSE;
WRITE  (p &amp; - FALSE # - q)  &amp;  p ;
LINE
END
                code for this body :
               1             IMMED         1         0
               2           BASSIGN        15         1
               3             IMMED         0         0
               4           BASSIGN        16         3
               5           SEMICOL         2         4
               6             FETCH        15         0
               7             IMMED         0         0
               8             NOTOP         0         7
               9             ANDOP         6         8
              10             FETCH        16         0
              11             NOTOP         0        10
              12              OROP         9        11
              13             FETCH        15         0
              14             ANDOP        12        13
              15            BWRITE         0        14
              16           SEMICOL         5        15
              17            LINEOP         0         0
              18           SEMICOL        16        17
 .
  TRUE
ready

{ demonstration of procedures }

INTEGER
  i { counter }
  s { square }
  c { cube }
  f { fourth power }
  t { total of squares }
  u { total of cubes }
  w { total of fourth powers }

I                               { initialisation }
  BEGIN
  i = 1;  t = 0;  u = 0;  w = 0
  END

C                               { computing and writing }
  BEGIN
  WHILE i &lt; 6 DO
    BEGIN
    s = i * i;  c = s * i;  f = s * s;
    WRITE i;  WRITE s;  WRITE c;  WRITE f;  LINE;
    t = t + s;  u = u + c;  w = w + f;
    i = i + 1
    END
  END

R                               { writing totals }
  BEGIN
  LINE;  TAB;  WRITE t;  WRITE u;  WRITE w;  LINE
  END

BEGIN                           { main program }
I;
C;
R
END .
         1         1         1         1
         2         4         8        16
         3         9        27        81
         4        16        64       256
         5        25       125       625

                  55       225       979
ready

.
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> The program</h2>
<div class="outline-text-2" id="text-4">
<p>
The following is the standard Pascal source program for the imperative language TYPROC.
</p>

<div class="org-src-container">

<pre class="src src-pascal"><span style="color: #00ffff;">PROGRAM</span> <span style="color: #ffffff; font-weight: bold;">typroc</span>(input,output);
<span style="color: #66f;">(* </span><span style="color: #66f;">TYpes, PROCedures, treecode, recursive interpreter *)</span>

LABEL 1,99;

<span style="color: #ff00ff;">CONST</span>
    echo = true; <span style="color: #66f;">(* </span><span style="color: #66f;">echo = usage_is_not_interactive *)</span>
    tt = 16;
    maxcode = 200;

<span style="color: #ff00ff;">TYPE</span>
    types = (booltyp,inttyp);
    operator =
        (fetch,immed,call,notop,andop,orop,less,great,equal,
        add,sub,mul,divid,bassign,iassign,semicol,ifop,whilop,
        bread,iread,bwrite,iwrite,lineop,tabop);
    instruction =
        <span style="color: #ff00ff;">RECORD</span> op : operator; left,right : <span style="color: #ff00ff;">integer</span> <span style="color: #00ffff;">END</span>;
    alfa     = <span style="color: #ff00ff;">PACKED</span> <span style="color: #ff00ff;">ARRAY</span> [1..8] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;
    string20 = <span style="color: #ff00ff;">PACKED</span> <span style="color: #ff00ff;">ARRAY</span> [1..20] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">char</span>;

<span style="color: #ff00ff;">VAR</span>
    ch : <span style="color: #ff00ff;">char</span>;          <span style="color: #66f;">(* </span><span style="color: #66f;">from getsym *)</span>
    al : alfa;
    boolvars,intvars : <span style="color: #ff00ff;">SET</span> <span style="color: #00ffff;">OF</span> <span style="color: #00ff00;">'a'</span>..<span style="color: #00ff00;">'z'</span>;
    procedures : <span style="color: #ff00ff;">SET</span> <span style="color: #00ffff;">OF</span> <span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>;
    procaddresses : <span style="color: #ff00ff;">ARRAY</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">integer</span>;
    code : <span style="color: #ff00ff;">ARRAY</span> [1..maxcode] <span style="color: #00ffff;">OF</span> instruction;
    lastcode : <span style="color: #ff00ff;">integer</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">code index *)</span>
    tracing : <span style="color: #ff00ff;">boolean</span>;
    i : <span style="color: #ff00ff;">integer</span>;

<span style="color: #66f;">(* </span><span style="color: #66f;">- - - - -   C O M P I L E R   - - - - - *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">getsym</span>;
LABEL 1;
<span style="color: #ff00ff;">VAR</span> I : <span style="color: #ff00ff;">integer</span>;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">getch</span>;
    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">getch *)</span>
    <span style="color: #00ffff;">IF</span> eof <span style="color: #00ffff;">THEN</span>
        <span style="color: #00ffff;">BEGIN</span>
        writeln(<span style="color: #00ff00;">'unexepcted end of file'</span>);
        <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">99</span>
        <span style="color: #00ffff;">END</span>;
    <span style="color: #00ffff;">WHILE</span> eoln <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">BEGIN</span> readln; <span style="color: #00ffff;">IF</span> echo <span style="color: #00ffff;">THEN</span> writeln <span style="color: #00ffff;">END</span>;
    <span style="color: #00ffff;">read</span>(ch); <span style="color: #00ffff;">IF</span> echo <span style="color: #00ffff;">THEN</span> <span style="color: #00ffff;">write</span>(ch)
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">getch *)</span>

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">getsym *)</span>
1:
al := <span style="color: #00ff00;">'        '</span>;
<span style="color: #00ffff;">REPEAT</span> getch <span style="color: #00ffff;">UNTIL</span> ch &gt; <span style="color: #00ff00;">' '</span>;
<span style="color: #00ffff;">IF</span> (ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>]) <span style="color: #00ffff;">AND</span> (input^ <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>]) <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span>
    al[1] := ch; i := 2;
    <span style="color: #00ffff;">REPEAT</span>
        getch; <span style="color: #00ffff;">IF</span> i &lt; 8 <span style="color: #00ffff;">THEN</span> al[i] := ch; i := i + 1
        <span style="color: #00ffff;">UNTIL</span> <span style="color: #00ffff;">NOT</span> (input^ <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>]);
    ch := <span style="color: #00ff00;">' '</span>
    <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">IF *)</span>
<span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> ch = <span style="color: #00ff00;">'{'</span> <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">comment *)</span>
    <span style="color: #00ffff;">REPEAT</span> getch <span style="color: #00ffff;">UNTIL</span> ch = <span style="color: #00ff00;">'}'</span>;
    <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">1</span>
    <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">getsym *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">gen</span>(o : operator; l,r : <span style="color: #ff00ff;">integer</span>);
<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">gen *)</span>
lastcode := lastcode + 1;
<span style="color: #00ffff;">WITH</span> code[lastcode] <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">BEGIN</span> op := o; left := l; right := r <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">gen *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">showcode</span>(i : <span style="color: #ff00ff;">integer</span>);
<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">showcode *)</span>
<span style="color: #00ffff;">WITH</span> code[i] <span style="color: #00ffff;">DO</span>
    writeln(i:tt,<span style="color: #00ff00;">'        '</span>,op:10,left:10,right:10)
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">showcode *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">programme</span>;
<span style="color: #ff00ff;">VAR</span> c : <span style="color: #ff00ff;">char</span>;

  <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">error</span>(<span style="color: #00ffff;">message</span> : string20);
  <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">error *)</span>
  <span style="color: #00ffff;">write</span>(<span style="color: #00ff00;">'error : '</span>);
  <span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">message</span>[1] &lt;&gt; <span style="color: #00ff00;">' '</span> <span style="color: #00ffff;">THEN</span>
      <span style="color: #00ffff;">BEGIN</span>
      <span style="color: #00ffff;">IF</span> ch &lt;&gt; <span style="color: #00ff00;">' '</span> <span style="color: #00ffff;">THEN</span> <span style="color: #00ffff;">write</span>(<span style="color: #00ff00;">'"'</span>,ch,<span style="color: #00ff00;">'"'</span>) <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">write</span>(<span style="color: #00ff00;">'"'</span>,al,<span style="color: #00ff00;">'"'</span>);
      <span style="color: #00ffff;">write</span>(<span style="color: #00ff00;">' when '</span>)
      <span style="color: #00ffff;">END</span>;
  writeln(<span style="color: #00ffff;">message</span>); readln; <span style="color: #00ffff;">GOTO</span> <span style="color: #7fffd4;">1</span>
  <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">error *)</span>

  <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">body</span>;
  <span style="color: #ff00ff;">VAR</span> firstcode : <span style="color: #ff00ff;">integer</span>;

    <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">statementsequence</span>;
    <span style="color: #ff00ff;">VAR</span> left : <span style="color: #ff00ff;">integer</span>;

      <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">statement</span>;
      <span style="color: #ff00ff;">VAR</span> typ : types; c : <span style="color: #ff00ff;">char</span>; left : <span style="color: #ff00ff;">integer</span>;

        <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">expression</span>(<span style="color: #ff00ff;">VAR</span> typ : types);
        <span style="color: #ff00ff;">VAR</span> typ2 : types; c : <span style="color: #ff00ff;">char</span>; left : <span style="color: #ff00ff;">integer</span>;

          <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">simpexpression</span>(<span style="color: #ff00ff;">VAR</span> typ : types);
          <span style="color: #ff00ff;">VAR</span> typ2 : types; c : <span style="color: #ff00ff;">char</span>; left : <span style="color: #ff00ff;">integer</span>;

            <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">term</span>(<span style="color: #ff00ff;">VAR</span> typ : types);
            <span style="color: #ff00ff;">VAR</span> typ2 : types; c : <span style="color: #ff00ff;">char</span>; left : <span style="color: #ff00ff;">integer</span>;

              <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">factor</span>(<span style="color: #ff00ff;">VAR</span> typ : types);
              <span style="color: #ff00ff;">VAR</span> num : <span style="color: #ff00ff;">integer</span>;
              <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">factor *)</span>
              <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'a'</span>..<span style="color: #00ff00;">'z'</span>] <span style="color: #00ffff;">THEN</span>
                  <span style="color: #00ffff;">BEGIN</span>
                  <span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">NOT</span> (ch <span style="color: #00ffff;">IN</span> boolvars + intvars)
                      <span style="color: #00ffff;">THEN</span> error(<span style="color: #00ff00;">'undeclared variable '</span>);
                  <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> boolvars
                      <span style="color: #00ffff;">THEN</span> typ := booltyp
                      <span style="color: #00ffff;">ELSE</span> typ := inttyp;
                  gen(fetch,ord(ch) - ord(<span style="color: #00ff00;">'a'</span>),0);
                  getsym
                  <span style="color: #00ffff;">END</span>
              <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'0'</span>..<span style="color: #00ff00;">'9'</span>] <span style="color: #00ffff;">THEN</span>
                  <span style="color: #00ffff;">BEGIN</span>
                  num := 0;
                  <span style="color: #00ffff;">REPEAT</span>
                      num := 10 * num + ord(ch) - ord(<span style="color: #00ff00;">'0'</span>);
                      getsym;
                      <span style="color: #00ffff;">UNTIL</span> <span style="color: #00ffff;">NOT</span> (ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'0'</span>..<span style="color: #00ff00;">'9'</span>]);
                  typ := inttyp;
                  gen(immed,num,0)
                  <span style="color: #00ffff;">END</span>
              <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> ch = <span style="color: #00ff00;">'('</span> <span style="color: #00ffff;">THEN</span>
                  <span style="color: #00ffff;">BEGIN</span>
                  getsym;
                  expression(typ);
                  <span style="color: #00ffff;">IF</span> ch &lt;&gt; <span style="color: #00ff00;">')'</span> <span style="color: #00ffff;">THEN</span>
                      error(<span style="color: #00ff00;">'")" expected        '</span>);
                  getsym
                  <span style="color: #00ffff;">END</span>
              <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> ch = <span style="color: #00ff00;">'-'</span> <span style="color: #00ffff;">THEN</span>
                  <span style="color: #00ffff;">BEGIN</span>
                  getsym;
                  factor(typ);
                  <span style="color: #00ffff;">IF</span> typ &lt;&gt; booltyp <span style="color: #00ffff;">THEN</span>
                      error(<span style="color: #00ff00;">' boolean expected   '</span>);
                  gen(notop,0,lastcode)
                  <span style="color: #00ffff;">END</span>
              <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> (al = <span style="color: #00ff00;">'TRUE    '</span>)
                    <span style="color: #00ffff;">OR</span> (al = <span style="color: #00ff00;">'FALSE   '</span>) <span style="color: #00ffff;">THEN</span>
                  <span style="color: #00ffff;">BEGIN</span>
                  typ := booltyp;
                  gen(immed,ord(al = <span style="color: #00ff00;">'TRUE    '</span>),0);
                  getsym
                  <span style="color: #00ffff;">END</span>
              <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> al = <span style="color: #00ff00;">'ORD     '</span> <span style="color: #00ffff;">THEN</span>
                  <span style="color: #00ffff;">BEGIN</span>
                  getsym;
                  factor(typ);
                  typ := inttyp
                  <span style="color: #00ffff;">END</span>
              <span style="color: #00ffff;">ELSE</span> error(<span style="color: #00ff00;">'illegal IN factor   '</span>)
              <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">factor *)</span>

            <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">term *)</span>
            factor(typ);
            <span style="color: #00ffff;">WHILE</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'*'</span>,<span style="color: #00ff00;">'/'</span>,<span style="color: #00ff00;">'&amp;'</span>] <span style="color: #00ffff;">DO</span>
                <span style="color: #00ffff;">BEGIN</span>
                <span style="color: #00ffff;">IF</span> (typ = booltyp) <span style="color: #00ffff;">AND</span> (ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'*'</span>,<span style="color: #00ff00;">'/'</span>])
                      <span style="color: #00ffff;">OR</span> (typ = inttyp) <span style="color: #00ffff;">AND</span> (ch = <span style="color: #00ff00;">'&amp;'</span>)
                    <span style="color: #00ffff;">THEN</span> error(<span style="color: #00ff00;">'operand conflict    '</span>);
                c := ch; left := lastcode;
                getsym;
                factor(typ2);
                <span style="color: #00ffff;">IF</span> typ &lt;&gt; typ2 <span style="color: #00ffff;">THEN</span>
                    error(<span style="color: #00ff00;">' different types    '</span>);
                <span style="color: #00ffff;">CASE</span> c <span style="color: #00ffff;">OF</span>
                    <span style="color: #00ff00;">'*'</span> : gen(mul,left,lastcode);
                    <span style="color: #00ff00;">'/'</span> : gen(divid,left,lastcode);
                    <span style="color: #00ff00;">'&amp;'</span> : gen(andop,left,lastcode)
                    <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
                <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE *)</span>
            <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">term *)</span>

          <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">simpexpression *)</span>
          term(typ);
          <span style="color: #00ffff;">WHILE</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'+'</span>,<span style="color: #00ff00;">'-'</span>,<span style="color: #00ff00;">'#'</span>] <span style="color: #00ffff;">DO</span>
              <span style="color: #00ffff;">BEGIN</span>
              <span style="color: #00ffff;">IF</span> (typ = booltyp) <span style="color: #00ffff;">AND</span> (ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'+'</span>,<span style="color: #00ff00;">'-'</span>])
                    <span style="color: #00ffff;">OR</span> (typ = inttyp) <span style="color: #00ffff;">AND</span> (ch = <span style="color: #00ff00;">'#'</span>)
                  <span style="color: #00ffff;">THEN</span> error(<span style="color: #00ff00;">'operand conflict    '</span>);
              c := ch; left := lastcode;
              getsym;
              term(typ2);
              <span style="color: #00ffff;">IF</span> typ &lt;&gt; typ2 <span style="color: #00ffff;">THEN</span>
                error(<span style="color: #00ff00;">' different types    '</span>);
              <span style="color: #00ffff;">CASE</span> c <span style="color: #00ffff;">OF</span>
                  <span style="color: #00ff00;">'+'</span> : gen(add,left,lastcode);
                  <span style="color: #00ff00;">'-'</span> : gen(sub,left,lastcode);
                  <span style="color: #00ff00;">'#'</span> : gen(orop,left,lastcode)
                  <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
              <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">while *)</span>
          <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">simpexpression *)</span>

        <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">expression *)</span>
        simpexpression(typ);
        <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'&gt;'</span>,<span style="color: #00ff00;">'&lt;'</span>,<span style="color: #00ff00;">'='</span>] <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            c := ch; left := lastcode;
            getsym;
            simpexpression(typ2);
            <span style="color: #00ffff;">IF</span> typ &lt;&gt; typ2 <span style="color: #00ffff;">THEN</span>
                error(<span style="color: #00ff00;">' different types    '</span>);
            typ := booltyp;
            <span style="color: #00ffff;">CASE</span> c <span style="color: #00ffff;">OF</span>
                <span style="color: #00ff00;">'&gt;'</span> : gen(great,left,lastcode);
                <span style="color: #00ff00;">'&lt;'</span> : gen(less,left,lastcode);
                <span style="color: #00ff00;">'='</span> : gen(equal,left,lastcode)
                <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
            <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">IF *)</span>
        <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">expression *)</span>

      <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">statement *)</span>
      <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'a'</span>..<span style="color: #00ff00;">'z'</span>] <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">assignment statement *)</span>
            <span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">NOT</span> (ch <span style="color: #00ffff;">IN</span> boolvars + intvars) <span style="color: #00ffff;">THEN</span>
                error(<span style="color: #00ff00;">'undeclared variable '</span>);
            c := ch; left := ord(ch) - ord(<span style="color: #00ff00;">'a'</span>); getsym;
            <span style="color: #00ffff;">IF</span> ch &lt;&gt; <span style="color: #00ff00;">'='</span> <span style="color: #00ffff;">THEN</span> error(<span style="color: #00ff00;">'"=" expected        '</span>);
            getsym; expression(typ);
            <span style="color: #00ffff;">IF</span> (c <span style="color: #00ffff;">IN</span> boolvars) <span style="color: #00ffff;">AND</span> (typ = inttyp)
                    <span style="color: #00ffff;">OR</span> (c <span style="color: #00ffff;">IN</span> intvars) <span style="color: #00ffff;">AND</span> (typ = booltyp)
                <span style="color: #00ffff;">THEN</span> error(<span style="color: #00ff00;">' assignment conflict'</span>);
            <span style="color: #00ffff;">IF</span> typ = booltyp
                <span style="color: #00ffff;">THEN</span> gen(bassign,left,lastcode)
                <span style="color: #00ffff;">ELSE</span> gen(iassign,left,lastcode)
            <span style="color: #00ffff;">END</span>
      <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>] <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">procedure call *)</span>
            <span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">NOT</span> (ch <span style="color: #00ffff;">IN</span> procedures) <span style="color: #00ffff;">THEN</span>
                error(<span style="color: #00ff00;">'undeclared procedure'</span>);
            gen(call,procaddresses[ch],0); getsym
            <span style="color: #00ffff;">END</span>
      <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> al = <span style="color: #00ff00;">'BEGIN   '</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            getsym; statementsequence;
            <span style="color: #00ffff;">IF</span> al &lt;&gt; <span style="color: #00ff00;">'END     '</span> <span style="color: #00ffff;">THEN</span> error(<span style="color: #00ff00;">'"END" expected      '</span>);
            getsym
            <span style="color: #00ffff;">END</span>
      <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> al = <span style="color: #00ff00;">'IF      '</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            getsym; expression(typ);
            <span style="color: #00ffff;">IF</span> typ &lt;&gt; booltyp <span style="color: #00ffff;">THEN</span>
                error(<span style="color: #00ff00;">'must be boolean expr'</span>);
            left := lastcode;
            <span style="color: #00ffff;">IF</span> al &lt;&gt; <span style="color: #00ff00;">'THEN    '</span> <span style="color: #00ffff;">THEN</span>
                error(<span style="color: #00ff00;">'"THEN" expected     '</span>);
            getsym; statement; gen(ifop,left,lastcode)
            <span style="color: #00ffff;">END</span>
      <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> al = <span style="color: #00ff00;">'WHILE   '</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            getsym; expression(typ);
            <span style="color: #00ffff;">IF</span> typ &lt;&gt; booltyp <span style="color: #00ffff;">THEN</span>
                error(<span style="color: #00ff00;">'must be boolean expr'</span>);
            left := lastcode;
            <span style="color: #00ffff;">IF</span> al &lt;&gt; <span style="color: #00ff00;">'DO      '</span> <span style="color: #00ffff;">THEN</span>
                error(<span style="color: #00ff00;">'"DO" expected       '</span>);
            getsym; statement; gen(whilop,left,lastcode)
            <span style="color: #00ffff;">END</span>
      <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> al = <span style="color: #00ff00;">'READ    '</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            getsym;
            <span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">NOT</span> (ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'a'</span>..<span style="color: #00ff00;">'z'</span>])
                <span style="color: #00ffff;">THEN</span> error(<span style="color: #00ff00;">'"a..z" expected     '</span>);
            <span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">NOT</span> (ch <span style="color: #00ffff;">IN</span> boolvars + intvars)
                <span style="color: #00ffff;">THEN</span> error(<span style="color: #00ff00;">'undeclared variable '</span>);
            <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> boolvars
                <span style="color: #00ffff;">THEN</span> gen(bread,ord(ch) - ord(<span style="color: #00ff00;">'a'</span>),0)
                <span style="color: #00ffff;">ELSE</span> gen(iread,ord(ch) - ord(<span style="color: #00ff00;">'a'</span>),0);
            getsym
            <span style="color: #00ffff;">END</span>
      <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> al = <span style="color: #00ff00;">'WRITE   '</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span>
            getsym; expression(typ);
            <span style="color: #00ffff;">IF</span> typ = booltyp
                <span style="color: #00ffff;">THEN</span> gen(bwrite,0,lastcode)
                <span style="color: #00ffff;">ELSE</span> gen(iwrite,0,lastcode)
            <span style="color: #00ffff;">END</span>
      <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> al = <span style="color: #00ff00;">'LINE    '</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span> getsym; gen(lineop,0,0) <span style="color: #00ffff;">END</span>
      <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">IF</span> al = <span style="color: #00ff00;">'TAB     '</span> <span style="color: #00ffff;">THEN</span>
            <span style="color: #00ffff;">BEGIN</span> getsym; gen(tabop,0,0) <span style="color: #00ffff;">END</span>
      <span style="color: #00ffff;">ELSE</span> error(<span style="color: #00ff00;">'illegal in statement'</span>)
      <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">statement *)</span>

    <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">statementsequence *)</span>
    statement;
    <span style="color: #00ffff;">WHILE</span> ch = <span style="color: #00ff00;">';'</span> <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">BEGIN</span>
        left := lastcode;
        getsym;
        statement;
        gen(semicol,left,lastcode)
        <span style="color: #00ffff;">END</span>
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">statementsequence *)</span>

  <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">body *)</span>
  <span style="color: #00ffff;">IF</span> al &lt;&gt; <span style="color: #00ff00;">'BEGIN   '</span> <span style="color: #00ffff;">THEN</span>
      error(<span style="color: #00ff00;">'"BEGIN" expected    '</span>);
  getsym;
  firstcode := lastcode + 1;
  statementsequence;
  <span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span>
      <span style="color: #00ffff;">BEGIN</span>
      writeln; writeln(<span style="color: #00ff00;">' '</span>:tt,<span style="color: #00ff00;">'code for this body :'</span>);
      <span style="color: #00ffff;">FOR</span> i := firstcode <span style="color: #00ffff;">TO</span> lastcode <span style="color: #00ffff;">DO</span> showcode(i)
      <span style="color: #00ffff;">END</span>;
  <span style="color: #00ffff;">IF</span> al &lt;&gt; <span style="color: #00ff00;">'END     '</span> <span style="color: #00ffff;">THEN</span>
      error(<span style="color: #00ff00;">'"END" expected      '</span>);
  getsym
  <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">body *)</span>

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">programme *)</span>
boolvars := []; intvars := []; procedures := [];
lastcode := 0;
<span style="color: #00ffff;">IF</span> al = <span style="color: #00ff00;">'BOOLEAN '</span> <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span>
    getsym;
    <span style="color: #00ffff;">WHILE</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'a'</span>..<span style="color: #00ff00;">'z'</span>] <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">BEGIN</span>
        <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> boolvars <span style="color: #00ffff;">THEN</span>
            error(<span style="color: #00ff00;">'existing variable   '</span>);
        boolvars := boolvars + [ch]; getsym
        <span style="color: #00ffff;">END</span>
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">IF *)</span>
<span style="color: #00ffff;">IF</span> al = <span style="color: #00ff00;">'INTEGER '</span> <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span>
    getsym;
    <span style="color: #00ffff;">WHILE</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'a'</span>..<span style="color: #00ff00;">'z'</span>] <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">BEGIN</span>
        <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> boolvars + intvars <span style="color: #00ffff;">THEN</span>
            error(<span style="color: #00ff00;">'existing variable   '</span>);
        intvars := intvars + [ch]; getsym
        <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE *)</span>
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">IF *)</span>
<span style="color: #00ffff;">WHILE</span> ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'A'</span>..<span style="color: #00ff00;">'Z'</span>] <span style="color: #00ffff;">DO</span>
    <span style="color: #00ffff;">BEGIN</span>
    <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> procedures <span style="color: #00ffff;">THEN</span>
        error(<span style="color: #00ff00;">'existing procedure  '</span>);
    procedures := procedures + [ch]; c := ch; getsym;
    body; procaddresses[c] := lastcode
    <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">WHILE *)</span>
body;
<span style="color: #00ffff;">IF</span> <span style="color: #00ffff;">NOT</span> (ch <span style="color: #00ffff;">IN</span> [<span style="color: #00ff00;">'.'</span>,<span style="color: #00ff00;">'?'</span>]) <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span> writeln(<span style="color: #00ff00;">'"." assumed'</span>); ch := <span style="color: #00ff00;">'.'</span> <span style="color: #00ffff;">END</span>;
tracing := ch = <span style="color: #00ff00;">'?'</span>;
ch := <span style="color: #00ff00;">' '</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">programme *)</span>

<span style="color: #66f;">(* </span><span style="color: #66f;">- - - - -   I N T E R P R E T E R   - - - - - *)</span>

<span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">interpret</span>;
<span style="color: #ff00ff;">VAR</span>  mem : <span style="color: #ff00ff;">ARRAY</span> [0..25] <span style="color: #00ffff;">OF</span> <span style="color: #ff00ff;">integer</span>;

  <span style="color: #00ffff;">FUNCTION</span> <span style="color: #ffffff; font-weight: bold;">ival</span>(n : <span style="color: #ff00ff;">integer</span>) : <span style="color: #ff00ff;">integer</span>;
  <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">ival *)</span>
  <span style="color: #00ffff;">WITH</span> code[n] <span style="color: #00ffff;">DO</span>
      <span style="color: #00ffff;">BEGIN</span>
      <span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span> showcode(n);
      <span style="color: #00ffff;">CASE</span> op <span style="color: #00ffff;">OF</span>
          fetch : ival := mem[left];
          immed : ival := left;
          add   : ival := ival(left)  +  ival(right);
          sub   : ival := ival(left)  -  ival(right);
          mul   : ival := ival(left)  *  ival(right);
          divid : ival := ival(left) <span style="color: #00ffff;">DIV</span> ival(right);
          <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
      <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">WITH *)</span>
  <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">ival *)</span>

  <span style="color: #00ffff;">FUNCTION</span> <span style="color: #ffffff; font-weight: bold;">bval</span>(n : <span style="color: #ff00ff;">integer</span>) : <span style="color: #ff00ff;">boolean</span>;
  <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">bval *)</span>
  <span style="color: #00ffff;">WITH</span> code[n] <span style="color: #00ffff;">DO</span>
      <span style="color: #00ffff;">BEGIN</span>
      <span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span> showcode(n);
      <span style="color: #00ffff;">CASE</span> op <span style="color: #00ffff;">OF</span>
          fetch : bval := mem[left] = 1;
          immed : bval := left = 1;
          notop : bval :=            <span style="color: #00ffff;">NOT</span> bval(right);
          andop : bval := bval(left) <span style="color: #00ffff;">AND</span> bval(right);
          orop  : bval := bval(left) <span style="color: #00ffff;">OR</span>  bval(right);
          less  : bval := ival(left)  &lt;  ival(right);
          great : bval := ival(left)  &gt;  ival(right);
          equal : bval := ival(left)  =  ival(right)
          <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
      <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">WITH *)</span>
  <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">bval *)</span>

  <span style="color: #00ffff;">PROCEDURE</span> <span style="color: #ffffff; font-weight: bold;">exe</span>(n : <span style="color: #ff00ff;">integer</span>);
  <span style="color: #ff00ff;">VAR</span> b : <span style="color: #ff00ff;">boolean</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">for reading *)</span>
  <span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">exe *)</span>
  <span style="color: #00ffff;">WITH</span> code[n] <span style="color: #00ffff;">DO</span>
      <span style="color: #00ffff;">BEGIN</span>
      <span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span> showcode(n);
      <span style="color: #00ffff;">CASE</span> op <span style="color: #00ffff;">OF</span>
          bassign : mem[left] := ord(bval(right));
          iassign : mem[left] := ival(right);
          call    : exe(left);
          semicol : <span style="color: #00ffff;">BEGIN</span> exe(left); exe(right) <span style="color: #00ffff;">END</span>;
          ifop    : <span style="color: #00ffff;">IF</span> bval(left) <span style="color: #00ffff;">THEN</span> exe(right);
          whilop  : <span style="color: #00ffff;">WHILE</span> bval(left) <span style="color: #00ffff;">DO</span> exe(right);
          bread   : <span style="color: #00ffff;">BEGIN</span> <span style="color: #00ffff;">read</span>(b); mem[left] := ord(b) <span style="color: #00ffff;">END</span>;
          iread   :       <span style="color: #00ffff;">read</span>(mem[left]);
          bwrite  : <span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span> writeln(bval(right))
                               <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">write</span>  (bval(right));
          iwrite  : <span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span> writeln(ival(right))
                               <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">write</span>  (ival(right));
          lineop  : writeln;
          tabop   : <span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span> writeln
                               <span style="color: #00ffff;">ELSE</span> <span style="color: #00ffff;">write</span>(<span style="color: #00ff00;">' '</span>:10)
          <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">CASE *)</span>
      <span style="color: #00ffff;">END</span> <span style="color: #66f;">(* </span><span style="color: #66f;">WITH *)</span>
  <span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">exe *)</span>

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">interpret *)</span>
<span style="color: #00ffff;">IF</span> echo <span style="color: #00ffff;">THEN</span> writeln;
<span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span> writeln(<span style="color: #00ff00;">' '</span>:tt,<span style="color: #00ff00;">'interpreting ...'</span>);
exe(lastcode);
<span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">AND</span> (boolvars + intvars &lt;&gt; []) <span style="color: #00ffff;">THEN</span>
    <span style="color: #00ffff;">BEGIN</span>
    writeln(<span style="color: #00ff00;">'variable'</span>:10,<span style="color: #00ff00;">'value'</span>:10);
    <span style="color: #00ffff;">FOR</span> ch := <span style="color: #00ff00;">'a'</span> <span style="color: #00ffff;">TO</span> <span style="color: #00ff00;">'z'</span> <span style="color: #00ffff;">DO</span>
        <span style="color: #00ffff;">IF</span> ch <span style="color: #00ffff;">IN</span> boolvars + intvars <span style="color: #00ffff;">THEN</span>
            writeln(ch:10,mem[ord(ch)-ord(<span style="color: #00ff00;">'a'</span>)]:10)
    <span style="color: #00ffff;">END</span>
<span style="color: #00ffff;">END</span>; <span style="color: #66f;">(* </span><span style="color: #66f;">interpret *)</span>

<span style="color: #66f;">(* </span><span style="color: #66f;">- - - - -   M A I N   - - - - - *)</span>

<span style="color: #00ffff;">BEGIN</span> <span style="color: #66f;">(* </span><span style="color: #66f;">main *)</span>
1:
<span style="color: #00ffff;">REPEAT</span>
    writeln(<span style="color: #00ff00;">'ready'</span>);
    getsym;
    <span style="color: #00ffff;">IF</span> ch &lt;&gt; <span style="color: #00ff00;">'.'</span> <span style="color: #00ffff;">THEN</span>
        <span style="color: #00ffff;">BEGIN</span>
        tracing := ch = <span style="color: #00ff00;">'?'</span>; <span style="color: #00ffff;">IF</span> tracing <span style="color: #00ffff;">THEN</span> getsym;
        programme; interpret
        <span style="color: #00ffff;">END</span>
    <span style="color: #00ffff;">UNTIL</span> ch = <span style="color: #00ff00;">'.'</span>;
99:
<span style="color: #00ffff;">END</span>. <span style="color: #66f;">(* </span><span style="color: #66f;">main *)</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Exercises and reading</h2>
<div class="outline-text-2" id="text-5">
<p>
The exercises below are divided into two groups:
those that leave the language as it is and merely
change the implementation,
and those that change the language.
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> <i>Changing the implementation</i>:</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Improve the error reporting so that when an error has occurred, a marker is placed under the currently visible symbol and the error message is written next.  You will need to use an input line buffer, so that the whole line is written out when an error has been seen.  This affects procedure <code>getch</code> &#x2014; it now has to maintain this buffer, extract characters from it sequentially, and read a whole new line when the buffer is empty.
</p>

<p>
Rewrite the scanner so that it recognises reserved words like <code>BEGIN</code> and <code>IF</code> rather than leaving the recognition to the parser.  This will mean that procedure <code>getsym</code> reports to the parsing procedures that it has recognised a begin-symbol, or an if-symbol, and so on.  You will need to define an enumeration type for these symbols.  This enumeration type should include symbols for the single characters, too.  As a consequence, the parsing procedures do not have to know anything about the surface syntax of the language.
</p>

<p>
Study the notion of error recovery, and implement it in this compiler.  See Wirth (1976, p 320 - 322) for a description of error recovery.
</p>

<p>
Instead of implementing the binary tree code in <code>ARRAY</code>, use pointers.  Do not forget to dispose of unwanted pointers when a <code>programme</code> has been executed.
</p>

<p>
In the interpreter, add a check which prevents attempted division by zero.
</p>

<p>
Rewrite the interpreter without using recursion.
</p>

<p>
Redesign the internal code so that it is closer to a conventional machine language.  The simplest kind is code for a stack machine for evaluating expressions and for holding return addresses for procedures that have been called.  You will have to write a completely new interpreter.
</p>

<p>
Rewrite the program in a different language such as C or Lisp or Basic.
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> <i>Changing the language</i>:</h3>
<div class="outline-text-3" id="text-5-2">
<p>
Just 26 lowercase variables and 26 uppercase procedures do not make programs very readable.  Change this so that variables and procedures can be any (perhaps lowercase) identifier &#x2014; starting with a letter optionally followed by further letters, digits (and perhaps underscores).  You will need to implement a symbol table in which such identifiers are stored when they are being declared.
</p>

<p>
The third little program in the sample run uses procedures, but they are not recursive.  Write a little program in the language which uses recursion.  Without actually running it, but by inspecting the Pascal program in the previous section, determine whether your program would work correctly.  If yes, explain how; if no, fix it.
</p>

<p>
Add the type <code>CHAR</code> to the language.  Define a method which allows users to write character strings.  This is particularly useful for obtaing readable output.  Do not attempt to implement string variables of arbitrary length &#x2014; this is quite difficult.
</p>

<p>
Implement <code>ELSE</code>, <code>REPEAT</code>, <code>FOR</code> and <code>CASE</code> statements.  Note that the latter two are much harder than the first two.
</p>

<p>
Add declarations for <code>ARRAY</code>\s of integers or of Booleans or of characters.  The declaration should specify their size, do not attempt to implement dynamically varying sizes.
</p>

<p>
Add local variables to procedures.  Since procedures should allow recursion, the local variables will have to be allocated on a stack.
</p>

<p>
Allow procedures to be called before they have been defined, but ensure that they have been defined before the body of the main program.
</p>

<p>
Add a facility for defining (parameterless) functions.  In one way functions are like procedures in that they have an executable code body.  In another way functions are like variables in that they have a type.  The type is given in the declaration, and it has to be recorded in the symbol table for later checking.
</p>

<p>
Implement value parameters for procedures (and functions).  Such parameters are just like local variables except that they are being initialised at the time of call.  So they will have to live on the stack, too.
</p>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> <i>Reading</i>:</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Allison (1986, pp 52 - 59) gives a denotational semantics for a small imperative language, and (pp 120 - 127) a Pascal interpreter for the language.  Note that the interpreter is a close, almost literal, translation of the semantics into Pascal.  The closeness of the translation is intentional, it is bought at the price of efficiency.  You might like to write a more efficient version, but do try to understand why Allison made his translation so close.
</p>

<p>
If you wish to pursue the topic of compilers, you may wish to skip to Chapter 14 to study a somewhat more complex but still quite small compiler for another, more useable language.  Alternatively, you may wish to pursue the reading given in that chapter.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
